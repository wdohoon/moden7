/*!
 * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */
(function(t) {
    const e = t["ko"] = t["ko"] || {};
    e.dictionary = Object.assign(e.dictionary || {}, {
        "%0 of %1": "0% / %1",
        Aquamarine: "Aquamarine",
        Black: "Black",
        Blue: "Blue",
        Bold: "Bold",
        "Bulleted List": "Bulleted List",
        "Bulleted list styles toolbar": "",
        Cancel: "Cancel",
        "Change image text alternative": "Change image text alternative",
        Circle: "",
        Decimal: "",
        "Decimal with leading zero": "",
        "Dim grey": "Dim grey",
        Disc: "",
        "Document colors": "Document colors",
        Downloadable: "Downloadable",
        "Dropdown toolbar": "드롭다운 툴바",
        "Edit link": "링크 편집",
        "Editor toolbar": "에디터 툴바",
        "Font Background Color": "Font Background Color",
        "Font Color": "Font Color",
        Green: "Green",
        Grey: "Grey",
        "image widget": "image widget",
        "Insert image": "Insert image",
        "Insert media": "Insert media",
        "Insert paragraph after block": "",
        "Insert paragraph before block": "",
        Italic: "Italic",
        "Light blue": "Light blue",
        "Light green": "Light green",
        "Light grey": "Light grey",
        Link: "Link",
        "Link URL": "Link URL",
        "Lower-latin": "",
        "Lower–roman": "",
        "Media URL": "Media URL",
        "media widget": "미디어 위젯",
        Next: "다음",
        "Numbered List": "Numbered List",
        "Numbered list styles toolbar": "",
        "Open in a new tab": "새 탭에서 열기",
        "Open link in new tab": "새 탭에서 링크 열기",
        Orange: "Orange",
        "Paste the media URL in the input.": "Paste the media URL in the input.",
        Previous: "이전",
        Purple: "Purple",
        Red: "Red",
        Redo: "다시 실행",
        "Remove color": "Remove color",
        "Rich Text Editor": "리치 텍스트 편집기",
        "Rich Text Editor, %0": "리치 텍스트 편집기, %0",
        Save: "Save",
        "Select all": "전체 선택",
        "Show more items": "더보기",
        Square: "",
        Strikethrough: "Strikethrough",
        "Text alternative": "대체 문구",
        "The URL must not be empty.": "URL이 비어있을 수 없습니다.",
        "This link has no URL": "이 링크에는 URL이 없습니다.",
        "This media URL is not supported.": "이 미디어 URL은 지원되지 않습니다.",
        "Tip: Paste the URL into the content to embed faster.": "팁: URL을 붙여넣기하면 더 빨리 삽입할 수 있습니다.",
        "Toggle the circle list style": "",
        "Toggle the decimal list style": "",
        "Toggle the decimal with leading zero list style": "",
        "Toggle the disc list style": "",
        "Toggle the lower–latin list style": "",
        "Toggle the lower–roman list style": "",
        "Toggle the square list style": "",
        "Toggle the upper–latin list style": "",
        "Toggle the upper–roman list style": "",
        Turquoise: "Turquoise",
        Underline: "Underline",
        Undo: "Undo",
        Unlink: "Unlink",
        "Upload failed": "Upload failed",
        "Upload in progress": "pload in progress",
        "Upper-latin": "",
        "Upper-roman": "",
        White: "White",
        Yellow: "Yellow"
    });
    e.getPluralForm = function(t) {
        return 0
    }
})(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {}));
(function t(e, n) {
    if (typeof exports === "object" && typeof module === "object") module.exports = n();
    else if (typeof define === "function" && define.amd) define([], n);
    else if (typeof exports === "object") exports["ClassicEditor"] = n();
    else e["ClassicEditor"] = n()
})(window, (function() {
    return function(t) {
        var e = {};

        function n(o) {
            if (e[o]) {
                return e[o].exports
            }
            var i = e[o] = {
                i: o,
                l: false,
                exports: {}
            };
            t[o].call(i.exports, i, i.exports, n);
            i.l = true;
            return i.exports
        }
        n.m = t;
        n.c = e;
        n.d = function(t, e, o) {
            if (!n.o(t, e)) {
                Object.defineProperty(t, e, {
                    enumerable: true,
                    get: o
                })
            }
        };
        n.r = function(t) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                Object.defineProperty(t, Symbol.toStringTag, {
                    value: "Module"
                })
            }
            Object.defineProperty(t, "__esModule", {
                value: true
            })
        };
        n.t = function(t, e) {
            if (e & 1) t = n(t);
            if (e & 8) return t;
            if (e & 4 && typeof t === "object" && t && t.__esModule) return t;
            var o = Object.create(null);
            n.r(o);
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: t
            });
            if (e & 2 && typeof t != "string")
                for (var i in t) n.d(o, i, function(e) {
                    return t[e]
                }.bind(null, i));
            return o
        };
        n.n = function(t) {
            var e = t && t.__esModule ? function e() {
                return t["default"]
            } : function e() {
                return t
            };
            n.d(e, "a", e);
            return e
        };
        n.o = function(t, e) {
            return Object.prototype.hasOwnProperty.call(t, e)
        };
        n.p = "";
        return n(n.s = 52)
    }([function(t, e, n) {
        "use strict";
        n.d(e, "a", (function() {
            return i
        }));
        n.d(e, "c", (function() {
            return r
        }));
        n.d(e, "b", (function() {
            return s
        }));
        const o = "https://ckeditor.com/docs/ckeditor5/latest/framework/guides/support/error-codes.html";
        class i extends Error {
            constructor(t, e, n) {
                const o = `${t}${n?` ${JSON.stringify(n)}`:""}${a(t)}`;
                super(o);
                this.name = "CKEditorError";
                this.context = e;
                this.data = n
            }
            is(t) {
                return t === "CKEditorError"
            }
            static rethrowUnexpectedError(t, e) {
                if (t.is && t.is("CKEditorError")) {
                    throw t
                }
                const n = new i(t.message, e);
                n.stack = t.stack;
                throw n
            }
        }

        function r(t, e) {
            console.warn(...c(t, e))
        }

        function s(t, e) {
            console.error(...c(t, e))
        }

        function a(t) {
            return `\nRead more: ${o}#error-${t}`
        }

        function c(t, e) {
            const n = a(t);
            return e ? [t, e, n] : [t, n]
        }
    }, function(t, e, n) {
        "use strict";
        var o = function t() {
            var e;
            return function t() {
                if (typeof e === "undefined") {
                    e = Boolean(window && document && document.all && !window.atob)
                }
                return e
            }
        }();
        var i = function t() {
            var e = {};
            return function t(n) {
                if (typeof e[n] === "undefined") {
                    var o = document.querySelector(n);
                    if (window.HTMLIFrameElement && o instanceof window.HTMLIFrameElement) {
                        try {
                            o = o.contentDocument.head
                        } catch (t) {
                            o = null
                        }
                    }
                    e[n] = o
                }
                return e[n]
            }
        }();
        var r = [];

        function s(t) {
            var e = -1;
            for (var n = 0; n < r.length; n++) {
                if (r[n].identifier === t) {
                    e = n;
                    break
                }
            }
            return e
        }

        function a(t, e) {
            var n = {};
            var o = [];
            for (var i = 0; i < t.length; i++) {
                var a = t[i];
                var c = e.base ? a[0] + e.base : a[0];
                var l = n[c] || 0;
                var d = "".concat(c, " ").concat(l);
                n[c] = l + 1;
                var u = s(d);
                var h = {
                    css: a[1],
                    media: a[2],
                    sourceMap: a[3]
                };
                if (u !== -1) {
                    r[u].references++;
                    r[u].updater(h)
                } else {
                    r.push({
                        identifier: d,
                        updater: m(h, e),
                        references: 1
                    })
                }
                o.push(d)
            }
            return o
        }

        function c(t) {
            var e = document.createElement("style");
            var o = t.attributes || {};
            if (typeof o.nonce === "undefined") {
                var r = true ? n.nc : undefined;
                if (r) {
                    o.nonce = r
                }
            }
            Object.keys(o).forEach((function(t) {
                e.setAttribute(t, o[t])
            }));
            if (typeof t.insert === "function") {
                t.insert(e)
            } else {
                var s = i(t.insert || "head");
                if (!s) {
                    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.")
                }
                s.appendChild(e)
            }
            return e
        }

        function l(t) {
            if (t.parentNode === null) {
                return false
            }
            t.parentNode.removeChild(t)
        }
        var d = function t() {
            var e = [];
            return function t(n, o) {
                e[n] = o;
                return e.filter(Boolean).join("\n")
            }
        }();

        function u(t, e, n, o) {
            var i = n ? "" : o.media ? "@media ".concat(o.media, " {").concat(o.css, "}") : o.css;
            if (t.styleSheet) {
                t.styleSheet.cssText = d(e, i)
            } else {
                var r = document.createTextNode(i);
                var s = t.childNodes;
                if (s[e]) {
                    t.removeChild(s[e])
                }
                if (s.length) {
                    t.insertBefore(r, s[e])
                } else {
                    t.appendChild(r)
                }
            }
        }

        function h(t, e, n) {
            var o = n.css;
            var i = n.media;
            var r = n.sourceMap;
            if (i) {
                t.setAttribute("media", i)
            } else {
                t.removeAttribute("media")
            }
            if (r && typeof btoa !== "undefined") {
                o += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(r)))), " */")
            }
            if (t.styleSheet) {
                t.styleSheet.cssText = o
            } else {
                while (t.firstChild) {
                    t.removeChild(t.firstChild)
                }
                t.appendChild(document.createTextNode(o))
            }
        }
        var f = null;
        var p = 0;

        function m(t, e) {
            var n;
            var o;
            var i;
            if (e.singleton) {
                var r = p++;
                n = f || (f = c(e));
                o = u.bind(null, n, r, false);
                i = u.bind(null, n, r, true)
            } else {
                n = c(e);
                o = h.bind(null, n, e);
                i = function t() {
                    l(n)
                }
            }
            o(t);
            return function e(n) {
                if (n) {
                    if (n.css === t.css && n.media === t.media && n.sourceMap === t.sourceMap) {
                        return
                    }
                    o(t = n)
                } else {
                    i()
                }
            }
        }
        t.exports = function(t, e) {
            e = e || {};
            if (!e.singleton && typeof e.singleton !== "boolean") {
                e.singleton = o()
            }
            t = t || [];
            var n = a(t, e);
            return function t(o) {
                o = o || [];
                if (Object.prototype.toString.call(o) !== "[object Array]") {
                    return
                }
                for (var i = 0; i < n.length; i++) {
                    var c = n[i];
                    var l = s(c);
                    r[l].references--
                }
                var d = a(o, e);
                for (var u = 0; u < n.length; u++) {
                    var h = n[u];
                    var f = s(h);
                    if (r[f].references === 0) {
                        r[f].updater();
                        r.splice(f, 1)
                    }
                }
                n = d
            }
        }
    }, function(t, e, n) {
        "use strict";

        function o(t, e) {
            return c(t) || a(t, e) || r(t, e) || i()
        }

        function i() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }

        function r(t, e) {
            if (!t) return;
            if (typeof t === "string") return s(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            if (n === "Object" && t.constructor) n = t.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(t);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return s(t, e)
        }

        function s(t, e) {
            if (e == null || e > t.length) e = t.length;
            for (var n = 0, o = new Array(e); n < e; n++) {
                o[n] = t[n]
            }
            return o
        }

        function a(t, e) {
            if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(t))) return;
            var n = [];
            var o = true;
            var i = false;
            var r = undefined;
            try {
                for (var s = t[Symbol.iterator](), a; !(o = (a = s.next()).done); o = true) {
                    n.push(a.value);
                    if (e && n.length === e) break
                }
            } catch (t) {
                i = true;
                r = t
            } finally {
                try {
                    if (!o && s["return"] != null) s["return"]()
                } finally {
                    if (i) throw r
                }
            }
            return n
        }

        function c(t) {
            if (Array.isArray(t)) return t
        }
        t.exports = function t(e) {
            var n = o(e, 4),
                i = n[1],
                r = n[3];
            if (typeof btoa === "function") {
                var s = btoa(unescape(encodeURIComponent(JSON.stringify(r))));
                var a = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(s);
                var c = "/*# ".concat(a, " */");
                var l = r.sources.map((function(t) {
                    return "/*# sourceURL=".concat(r.sourceRoot || "").concat(t, " */")
                }));
                return [i].concat(l).concat([c]).join("\n")
            }
            return [i].join("\n")
        }
    }, function(t, e, n) {
        "use strict";
        t.exports = function(t) {
            var e = [];
            e.toString = function e() {
                return this.map((function(e) {
                    var n = t(e);
                    if (e[2]) {
                        return "@media ".concat(e[2], " {").concat(n, "}")
                    }
                    return n
                })).join("")
            };
            e.i = function(t, n, o) {
                if (typeof t === "string") {
                    t = [
                        [null, t, ""]
                    ]
                }
                var i = {};
                if (o) {
                    for (var r = 0; r < this.length; r++) {
                        var s = this[r][0];
                        if (s != null) {
                            i[s] = true
                        }
                    }
                }
                for (var a = 0; a < t.length; a++) {
                    var c = [].concat(t[a]);
                    if (o && i[c[0]]) {
                        continue
                    }
                    if (n) {
                        if (!c[2]) {
                            c[2] = n
                        } else {
                            c[2] = "".concat(n, " and ").concat(c[2])
                        }
                    }
                    e.push(c)
                }
            };
            return e
        }
    }, , function(t, e, n) {
        "use strict";
        var o = n(9);
        var i = typeof self == "object" && self && self.Object === Object && self;
        var r = o["a"] || i || Function("return this")();
        e["a"] = r
    }, function(t, e, n) {
        "use strict";
        (function(t) {
            var o = n(5);
            var i = n(51);
            var r = typeof exports == "object" && exports && !exports.nodeType && exports;
            var s = r && typeof t == "object" && t && !t.nodeType && t;
            var a = s && s.exports === r;
            var c = a ? o["a"].Buffer : undefined;
            var l = c ? c.isBuffer : undefined;
            var d = l || i["a"];
            e["a"] = d
        }).call(this, n(11)(t))
    }, function(t, e, n) {
        "use strict";
        (function(t) {
            var o = n(9);
            var i = typeof exports == "object" && exports && !exports.nodeType && exports;
            var r = i && typeof t == "object" && t && !t.nodeType && t;
            var s = r && r.exports === i;
            var a = s && o["a"].process;
            var c = function() {
                try {
                    var t = r && r.require && r.require("util").types;
                    if (t) {
                        return t
                    }
                    return a && a.binding && a.binding("util")
                } catch (t) {}
            }();
            e["a"] = c
        }).call(this, n(11)(t))
    }, function(t, e, n) {
        "use strict";
        (function(t) {
            var e = n(0);
            const o = "24.0.0";
            const i = typeof window === "object" ? window : t;
            if (i.CKEDITOR_VERSION) {
                throw new e["a"]("ckeditor-duplicated-modules", null)
            } else {
                i.CKEDITOR_VERSION = o
            }
        }).call(this, n(50))
    }, function(t, e, n) {
        "use strict";
        (function(t) {
            var n = typeof t == "object" && t && t.Object === Object && t;
            e["a"] = n
        }).call(this, n(50))
    }, function(t, e, n) {
        "use strict";
        (function(t) {
            var o = n(5);
            var i = typeof exports == "object" && exports && !exports.nodeType && exports;
            var r = i && typeof t == "object" && t && !t.nodeType && t;
            var s = r && r.exports === i;
            var a = s ? o["a"].Buffer : undefined,
                c = a ? a.allocUnsafe : undefined;

            function l(t, e) {
                if (e) {
                    return t.slice()
                }
                var n = t.length,
                    o = c ? c(n) : new t.constructor(n);
                t.copy(o);
                return o
            }
            e["a"] = l
        }).call(this, n(11)(t))
    }, function(t, e) {
        t.exports = function(t) {
            if (!t.webpackPolyfill) {
                var e = Object.create(t);
                if (!e.children) e.children = [];
                Object.defineProperty(e, "loaded", {
                    enumerable: true,
                    get: function() {
                        return e.l
                    }
                });
                Object.defineProperty(e, "id", {
                    enumerable: true,
                    get: function() {
                        return e.i
                    }
                });
                Object.defineProperty(e, "exports", {
                    enumerable: true
                });
                e.webpackPolyfill = 1
            }
            return e
        }
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck.ck-placeholder:before,.ck .ck-placeholder:before{content:attr(data-placeholder);pointer-events:none}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-placeholder:before,.ck .ck-placeholder:before{cursor:text;color:var(--ck-color-engine-placeholder-text)}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/placeholder.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css"],
            names: [],
            mappings: "AAQC,qDACC,8BAA+B,CAG/B,mBACD,CAKA,wCACC,YACD,CCbA,qDACC,WAAY,CACZ,6CACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder,\n.ck .ck-placeholder {\n\t&::before {\n\t\tcontent: attr(data-placeholder);\n\n\t\t/* See ckeditor/ckeditor5#469. */\n\t\tpointer-events: none;\n\t}\n}\n\n/* See ckeditor/ckeditor5#1987. */\n.ck.ck-read-only .ck-placeholder {\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder, .ck .ck-placeholder {\n\t&::before {\n\t\tcursor: text;\n\t\tcolor: var(--ck-color-engine-placeholder-text);\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck-hidden{display:none!important}.ck.ck-reset,.ck.ck-reset_all,.ck.ck-reset_all *{box-sizing:border-box;width:auto;height:auto;position:static}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#c4c4c4;--ck-color-base-action:#61b045;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#198cf0;--ck-color-base-active-focus:#0e7fe1;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:208,79%,51%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#bcdefb;--ck-color-focus-disabled-shadow:rgba(119,186,248,0.3);--ck-color-focus-error-shadow:rgba(255,64,31,0.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,0.15);--ck-color-shadow-drop-active:rgba(0,0,0,0.2);--ck-color-shadow-inner:rgba(0,0,0,0.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#e6e6e6;--ck-color-button-default-active-background:#d9d9d9;--ck-color-button-default-active-shadow:#bfbfbf;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#dedede;--ck-color-button-on-hover-background:#c4c4c4;--ck-color-button-on-active-background:#bababa;--ck-color-button-on-active-shadow:#a1a1a1;--ck-color-button-on-disabled-background:#dedede;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#579e3d;--ck-color-button-action-active-background:#53973b;--ck-color-button-action-active-shadow:#498433;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#b0b0b0;--ck-color-switch-button-off-hover-background:#a3a3a3;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#579e3d;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,0.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:#c7c7c7;--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:#c7c7c7;--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-base-active);--ck-color-list-button-on-background-focus:var(--ck-color-base-active-focus);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-foreground);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,177,255,0.1);--ck-color-link-fake-selection:rgba(31,177,255,0.3);--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck.ck-reset,.ck.ck-reset_all,.ck.ck-reset_all *{margin:0;padding:0;border:0;background:transparent;text-decoration:none;vertical-align:middle;transition:none;word-wrap:break-word}.ck.ck-reset_all,.ck.ck-reset_all *{border-collapse:collapse;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);color:var(--ck-color-text);text-align:left;white-space:nowrap;cursor:auto;float:none}.ck.ck-reset_all .ck-rtl *{text-align:right}.ck.ck-reset_all iframe{vertical-align:inherit}.ck.ck-reset_all textarea{white-space:pre-wrap}.ck.ck-reset_all input[type=password],.ck.ck-reset_all input[type=text],.ck.ck-reset_all textarea{cursor:text}.ck.ck-reset_all input[type=password][disabled],.ck.ck-reset_all input[type=text][disabled],.ck.ck-reset_all textarea[disabled]{cursor:default}.ck.ck-reset_all fieldset{padding:10px;border:2px groove #dfdee3}.ck.ck-reset_all button::-moz-focus-inner{padding:0;border:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_hidden.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_reset.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_zindex.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_transition.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css"],
            names: [],
            mappings: "AAQA,WAGC,sBACD,CCPA,iDAGC,qBAAsB,CACtB,UAAW,CACX,WAAY,CACZ,eACD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAgD,CAChD,8BAAmD,CACnD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAmD,CACnD,oCAAuD,CACvD,6BAAkD,CAIlD,+CAAwD,CACxD,qEAA+E,CAC/E,qCAAwD,CACxD,sDAA8D,CAC9D,iDAAyD,CACzD,yCAAqD,CACrD,uCAAsD,CACtD,6CAA0D,CAC1D,uCAAsD,CAItD,gDAAuD,CACvD,kDAA+D,CAC/D,mDAAgE,CAChE,+CAA6D,CAC7D,yDAA8D,CAE9D,uCAAuD,CACvD,6CAA4D,CAC5D,8CAA4D,CAC5D,0CAAyD,CACzD,gDAA8D,CAE9D,+DAAsE,CACtE,iDAAkE,CAClE,kDAAkE,CAClE,8CAA+D,CAC/D,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA4D,CAC5D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAmE,CACnE,yEAA8E,CAC9E,qDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,+BAAiD,CACjD,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,wCAAwD,CACxD,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,gEAAuE,CACvE,4EAAiF,CACjF,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,wDAAmE,CACnE,mDAAgE,CCpGhE,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJoGD,CI9FA,iDAIC,QAAS,CACT,SAAU,CACV,QAAS,CACT,sBAAuB,CACvB,oBAAqB,CACrB,qBAAsB,CACtB,eAAgB,CAGhB,oBACD,CAKA,oCAGC,wBAAyB,CACzB,iGAAkG,CAClG,0BAA2B,CAC3B,eAAgB,CAChB,kBAAmB,CACnB,WAAY,CACZ,UACD,CAGC,2BACC,gBACD,CAEA,wBAEC,sBACD,CAEA,0BACC,oBACD,CAEA,kGAGC,WACD,CAEA,gIAGC,cACD,CAEA,0BACC,YAAa,CACb,yBACD,CAEA,0CAEC,SAAU,CACV,QACD,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which hides an element in DOM.\n */\n.ck-hidden {\n\t/* Override selector specificity. Otherwise, all elements with some display\n\tstyle defined will override this one, which is not a desired result. */\n\tdisplay: none !important;\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck.ck-reset_all * {\n\tbox-sizing: border-box;\n\twidth: auto;\n\theight: auto;\n\tposition: static;\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-z-default: 1;\n\t--ck-z-modal: calc( var(--ck-z-default) + 999 );\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class that disables all transitions of the element and its children.\n */\n.ck-transitions-disabled,\n.ck-transitions-disabled * {\n\ttransition: none !important;\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-base-foreground: \t\t\t\t\t\t\t\thsl(0, 0%, 98%);\n\t--ck-color-base-background: \t\t\t\t\t\t\t\thsl(0, 0%, 100%);\n\t--ck-color-base-border: \t\t\t\t\t\t\t\t\thsl(0, 0%, 77%);\n\t--ck-color-base-action: \t\t\t\t\t\t\t\t\thsl(104, 44%, 48%);\n\t--ck-color-base-focus: \t\t\t\t\t\t\t\t\t\thsl(209, 92%, 70%);\n\t--ck-color-base-text: \t\t\t\t\t\t\t\t\t\thsl(0, 0%, 20%);\n\t--ck-color-base-active: \t\t\t\t\t\t\t\t\thsl(208, 88%, 52%);\n\t--ck-color-base-active-focus:\t\t\t\t\t\t\t\thsl(208, 88%, 47%);\n\t--ck-color-base-error:\t\t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t/* -- Generic colors ------------------------------------------------------------------------ */\n\n\t--ck-color-focus-border-coordinates: \t\t\t\t\t\t208, 79%, 51%;\n\t--ck-color-focus-border: \t\t\t\t\t\t\t\t\thsl(var(--ck-color-focus-border-coordinates));\n\t--ck-color-focus-outer-shadow:\t\t\t\t\t\t\t\thsl(207, 89%, 86%);\n\t--ck-color-focus-disabled-shadow:\t\t\t\t\t\t\thsla(209, 90%, 72%,.3);\n\t--ck-color-focus-error-shadow:\t\t\t\t\t\t\t\thsla(9,100%,56%,.3);\n\t--ck-color-text: \t\t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-shadow-drop: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.15);\n\t--ck-color-shadow-drop-active:\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.2);\n\t--ck-color-shadow-inner: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Buttons ------------------------------------------------------------------------------- */\n\n\t--ck-color-button-default-background: \t\t\t\t\t\ttransparent;\n\t--ck-color-button-default-hover-background: \t\t\t\thsl(0, 0%, 90%);\n\t--ck-color-button-default-active-background: \t\t\t\thsl(0, 0%, 85%);\n\t--ck-color-button-default-active-shadow: \t\t\t\t\thsl(0, 0%, 75%);\n\t--ck-color-button-default-disabled-background: \t\t\t\ttransparent;\n\n\t--ck-color-button-on-background: \t\t\t\t\t\t\thsl(0, 0%, 87%);\n\t--ck-color-button-on-hover-background: \t\t\t\t\t\thsl(0, 0%, 77%);\n\t--ck-color-button-on-active-background: \t\t\t\t\thsl(0, 0%, 73%);\n\t--ck-color-button-on-active-shadow: \t\t\t\t\t\thsl(0, 0%, 63%);\n\t--ck-color-button-on-disabled-background: \t\t\t\t\thsl(0, 0%, 87%);\n\n\t--ck-color-button-action-background: \t\t\t\t\t\tvar(--ck-color-base-action);\n\t--ck-color-button-action-hover-background: \t\t\t\t\thsl(104, 44%, 43%);\n\t--ck-color-button-action-active-background: \t\t\t\thsl(104, 44%, 41%);\n\t--ck-color-button-action-active-shadow: \t\t\t\t\thsl(104, 44%, 36%);\n\t--ck-color-button-action-disabled-background: \t\t\t\thsl(104, 44%, 58%);\n\t--ck-color-button-action-text: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t--ck-color-button-save: \t\t\t\t\t\t\t\t\thsl(120, 100%, 27%);\n\t--ck-color-button-cancel: \t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t--ck-color-switch-button-off-background:\t\t\t\t\thsl(0, 0%, 69%);\n\t--ck-color-switch-button-off-hover-background:\t\t\t\thsl(0, 0%, 64%);\n\t--ck-color-switch-button-on-background:\t\t\t\t\t\tvar(--ck-color-button-action-background);\n\t--ck-color-switch-button-on-hover-background:\t\t\t\thsl(104, 44%, 43%);\n\t--ck-color-switch-button-inner-background:\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-switch-button-inner-shadow:\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Dropdown ------------------------------------------------------------------------------ */\n\n\t--ck-color-dropdown-panel-background: \t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-dropdown-panel-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Input --------------------------------------------------------------------------------- */\n\n\t--ck-color-input-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-input-border: \t\t\t\t\t\t\t\t\thsl(0, 0%, 78%);\n\t--ck-color-input-error-border:\t\t\t\t\t\t\t\tvar(--ck-color-base-error);\n\t--ck-color-input-text: \t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-input-disabled-background: \t\t\t\t\t\thsl(0, 0%, 95%);\n\t--ck-color-input-disabled-border: \t\t\t\t\t\t\thsl(0, 0%, 78%);\n\t--ck-color-input-disabled-text: \t\t\t\t\t\t\thsl(0, 0%, 46%);\n\n\t/* -- List ---------------------------------------------------------------------------------- */\n\n\t--ck-color-list-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-list-button-hover-background: \t\t\t\t\tvar(--ck-color-button-default-hover-background);\n\t--ck-color-list-button-on-background: \t\t\t\t\t\tvar(--ck-color-base-active);\n\t--ck-color-list-button-on-background-focus: \t\t\t\tvar(--ck-color-base-active-focus);\n\t--ck-color-list-button-on-text:\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Panel --------------------------------------------------------------------------------- */\n\n\t--ck-color-panel-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-panel-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Toolbar ------------------------------------------------------------------------------- */\n\n\t--ck-color-toolbar-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-foreground);\n\t--ck-color-toolbar-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Tooltip ------------------------------------------------------------------------------- */\n\n\t--ck-color-tooltip-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-tooltip-text: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Engine -------------------------------------------------------------------------------- */\n\n\t--ck-color-engine-placeholder-text: \t\t\t\t\t\thsl(0, 0%, 44%);\n\n\t/* -- Upload -------------------------------------------------------------------------------- */\n\n\t--ck-color-upload-bar-background:\t\t \t\t\t\t\thsl(209, 92%, 70%);\n\n\t/* -- Link -------------------------------------------------------------------------------- */\n\n\t--ck-color-link-default:\t\t\t\t\t\t\t\t\thsl(240, 100%, 47%);\n\t--ck-color-link-selected-background:\t\t\t\t\t\thsla(201, 100%, 56%, 0.1);\n\t--ck-color-link-fake-selection:\t\t\t\t\t\t\t\thsla(201, 100%, 56%, 0.3);\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * An opacity value of disabled UI item.\n\t */\n\t--ck-disabled-opacity: .5;\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * The geometry of the of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow-geometry: 0 0 0 3px;\n\n\t/**\n\t * A visual style of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when disabled).\n\t */\n\t--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when has errors).\n\t */\n\t--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);\n\n\t/**\n\t * A visual style of focused element's border or outline.\n\t */\n\t--ck-focus-ring: 1px solid var(--ck-color-focus-border);\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-font-size-base: 13px;\n\t--ck-line-height-base: 1.84615;\n\t--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;\n\n\t--ck-font-size-tiny: 0.7em;\n\t--ck-font-size-small: 0.75em;\n\t--ck-font-size-normal: 1em;\n\t--ck-font-size-big: 1.4em;\n\t--ck-font-size-large: 1.8em;\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* This is super-important. This is **manually** adjusted so a button without an icon\n\tis never smaller than a button with icon, additionally making sure that text-less buttons\n\tare perfect squares. The value is also shared by other components which should stay "in-line"\n\twith buttons. */\n\t--ck-ui-component-min-height: 2.3em;\n}\n\n/**\n * Resets an element, ignoring its children.\n */\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck.ck-reset_all * {\n\t/* Do not include inheritable rules here. */\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tbackground: transparent;\n\ttext-decoration: none;\n\tvertical-align: middle;\n\ttransition: none;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */\n\tword-wrap: break-word;\n}\n\n/**\n * Resets an element AND its children.\n */\n.ck.ck-reset_all,\n.ck.ck-reset_all * {\n\t/* These are rule inherited by all children elements. */\n\tborder-collapse: collapse;\n\tfont: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);\n\tcolor: var(--ck-color-text);\n\ttext-align: left;\n\twhite-space: nowrap;\n\tcursor: auto;\n\tfloat: none;\n}\n\n.ck.ck-reset_all {\n\t& .ck-rtl * {\n\t\ttext-align: right;\n\t}\n\n\t& iframe {\n\t\t/* For IE */\n\t\tvertical-align: inherit;\n\t}\n\n\t& textarea {\n\t\twhite-space: pre-wrap;\n\t}\n\n\t& textarea,\n\t& input[type="text"],\n\t& input[type="password"] {\n\t\tcursor: text;\n\t}\n\n\t& textarea[disabled],\n\t& input[type="text"][disabled],\n\t& input[type="password"][disabled] {\n\t\tcursor: default;\n\t}\n\n\t& fieldset {\n\t\tpadding: 10px;\n\t\tborder: 2px groove hsl(255, 7%, 88%);\n\t}\n\n\t& button::-moz-focus-inner {\n\t\t/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */\n\t\tpadding: 0;\n\t\tborder: 0\n\t}\n}\n\n/**\n * Default UI rules for RTL languages.\n */\n.ck[dir="rtl"],\n.ck[dir="rtl"] .ck {\n\ttext-align: right;\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Default border-radius value.\n */\n:root{\n\t--ck-border-radius: 2px;\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * A visual style of element's inner shadow (i.e. input).\n\t */\n\t--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;\n\n\t/**\n\t * A visual style of element's drop shadow (i.e. panel).\n\t */\n\t--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);\n\n\t/**\n\t * A visual style of element's active shadow (i.e. comment or suggestion).\n\t */\n\t--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-spacing-unit: \t\t\t\t\t\t0.6em;\n\t--ck-spacing-large: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 1.5);\n\t--ck-spacing-standard: \t\t\t\t\tvar(--ck-spacing-unit);\n\t--ck-spacing-medium: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.8);\n\t--ck-spacing-small: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.5);\n\t--ck-spacing-tiny: \t\t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.3);\n\t--ck-spacing-extra-tiny: \t\t\t\tcalc(var(--ck-spacing-unit) * 0.16);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-focused{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0}.ck.ck-editor__editable_inline{overflow:auto;padding:0 var(--ck-spacing-standard);border:1px solid transparent}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"],
            names: [],
            mappings: "AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEERA,YAAa,CACb,2BAA2B,CCF3B,qCHYA,CAGD,+BACC,aAAc,CACd,oCAAqC,CACrC,4BAwBD,CAtBC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CACC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,mDACD,CAIA,gEACC,gDACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_focus.css";\n@import "../../mixins/_button.css";\n\n:root {\n\t--ck-color-editable-blur-selection: hsl(0, 0%, 85%);\n}\n\n.ck.ck-editor__editable:not(.ck-editor__nested-editable) {\n\t@mixin ck-rounded-corners;\n\n\t&.ck-focused {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\t}\n}\n\n.ck.ck-editor__editable_inline {\n\toverflow: auto;\n\tpadding: 0 var(--ck-spacing-standard);\n\tborder: 1px solid transparent;\n\n\t&[dir="ltr"] {\n\t\ttext-align: left;\n\t}\n\n\t&[dir="rtl"] {\n\t\ttext-align: right;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */\n\t& > *:first-child {\n\t\tmargin-top: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/847 */\n\t& > *:last-child {\n\t\tmargin-bottom: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/6517 */\n\t&.ck-blurred ::selection {\n\t\tbackground: var(--ck-color-editable-blur-selection);\n\t}\n}\n\n/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {\n\t&::after {\n\t\tborder-bottom-color: var(--ck-color-base-foreground);\n\t}\n}\n\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {\n\t&::after {\n\t\tborder-top-color: var(--ck-color-base-foreground);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/label/label.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css"],
            names: [],
            mappings: "AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tdisplay: block;\n}\n\n.ck.ck-voice-label {\n\tdisplay: none;\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tfont-weight: bold;\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{z-index:var(--ck-z-modal);position:fixed;top:0}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{top:auto;position:absolute}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{box-shadow:var(--ck-drop-shadow),0 0;border-width:0 1px 1px;border-top-left-radius:0;border-top-right-radius:0}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/stickypanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"],
            names: [],
            mappings: "AAMC,qDACC,yBAA0B,CAC1B,cAAe,CACf,KACD,CAEA,kEACC,QAAS,CACT,iBACD,CCPA,qDCCA,oCAA8B,CDE7B,sBAAuB,CACvB,wBAAyB,CACzB,yBACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\tz-index: var(--ck-z-modal); /* #315 */\n\t\tposition: fixed;\n\t\ttop: 0;\n\t}\n\n\t& .ck-sticky-panel__content_sticky_bottom-limit {\n\t\ttop: auto;\n\t\tposition: absolute;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\t@mixin ck-drop-shadow;\n\n\t\tborder-width: 0 1px 1px;\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on .ck-tooltip{display:none}.ck.ck-dropdown .ck-dropdown__panel{-webkit-backface-visibility:hidden;display:none;z-index:var(--ck-z-modal);position:absolute}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{top:100%;bottom:auto}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{width:7em;overflow:hidden;text-overflow:ellipsis}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{box-shadow:var(--ck-drop-shadow),0 0;background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/dropdown.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"],
            names: [],
            mappings: "AAOA,gBACC,oBAAqB,CACrB,iBAyDD,CAvDC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UAOD,CCcA,iEACC,YACD,CDdA,oCAGC,kCAAmC,CAEnC,YAAa,CACb,yBAA0B,CAE1B,iBA8BD,CA5BC,+DACC,oBACD,CAEA,oHAEC,WACD,CAEA,oHAMC,QAAS,CACT,WACD,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAQF,mCACC,mCACD,CEhEA,MACC,sDACD,CAEA,gBAEC,iBAiED,CA/DC,oCACC,mCACD,CAGC,8CACC,gCAAiC,CAGjC,sCACD,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEACC,SAAU,CACV,eAAgB,CAChB,sBACD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAIF,uBExEC,eFoGD,CA5BA,qFEpEE,qCFgGF,CA5BA,uBG1EC,oCAA8B,CH8E9B,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CAGT,cAmBD,CAfC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import \"../tooltip/mixins/_tooltip.css\";\n\n.ck.ck-dropdown {\n\tdisplay: inline-block;\n\tposition: relative;\n\n\t& .ck-dropdown__arrow {\n\t\tpointer-events: none;\n\t\tz-index: var(--ck-z-default);\n\t}\n\n\t/* Dropdown button should span horizontally, e.g. in vertical toolbars */\n\t& .ck-button.ck-dropdown__button {\n\t\twidth: 100%;\n\n\t\t/* Disable main button's tooltip when the dropdown is open. Otherwise the panel may\n\t\tpartially cover the tooltip */\n\t\t&.ck-on {\n\t\t\t@mixin ck-tooltip_disabled;\n\t\t}\n\t}\n\n\t& .ck-dropdown__panel {\n\t\t/* This is to get rid of flickering when the tooltip is shown under the panel,\n\t\twhich looks like the panel moves vertically a pixel down and up. */\n\t\t-webkit-backface-visibility: hidden;\n\n\t\tdisplay: none;\n\t\tz-index: var(--ck-z-modal);\n\n\t\tposition: absolute;\n\n\t\t&.ck-dropdown__panel-visible {\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_nw {\n\t\t\tbottom: 100%;\n\t\t}\n\n\t\t&.ck-dropdown__panel_se,\n\t\t&.ck-dropdown__panel_sw {\n\t\t\t/*\n\t\t\t * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.\n\t\t\t * See https://github.com/ckeditor/ckeditor5/issues/1053.\n\t\t\t */\n\t\t\ttop: 100%;\n\t\t\tbottom: auto;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_se {\n\t\t\tleft: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_sw {\n\t\t\tright: 0px;\n\t\t}\n\t}\n}\n\n/*\n * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.\n * See https://github.com/ckeditor/ckeditor5/issues/7874\n */\n.ck.ck-toolbar .ck-dropdown__panel {\n\tz-index: calc( var(--ck-z-modal) + 1 );\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Enables the tooltip, which is the tooltip is in DOM but\n * not yet displayed.\n */\n@define-mixin ck-tooltip_enabled {\n\t& .ck-tooltip {\n\t\tdisplay: block;\n\n\t\t/*\n\t\t * Don't display tooltips in devices which don't support :hover.\n\t\t * In fact, it's all about iOS, which forces user to click UI elements twice to execute\n\t\t * the primary action, when tooltips are enabled.\n\t\t *\n\t\t * Q: OK, but why not the following query?\n\t\t *\n\t\t *   @media (hover) {\n\t\t *       display: block;\n\t\t *   }\n\t\t *\n\t\t * A: Because FF does not support it and it would completely disable tooltips\n\t\t * in that browser.\n\t\t *\n\t\t * More in https://github.com/ckeditor/ckeditor5/issues/920.\n\t\t */\n\t\t@media (hover:none) {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/**\n * Disables the tooltip making it disappear from DOM.\n */\n@define-mixin ck-tooltip_disabled {\n\t& .ck-tooltip {\n\t\tdisplay: none;\n\t}\n}\n\n/**\n * Shows the tooltip, which is already in DOM.\n * Requires `ck-tooltip_enabled` first.\n */\n@define-mixin ck-tooltip_visible {\n\t& .ck-tooltip {\n\t\tvisibility: visible;\n\t\topacity: 1;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n\t--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-dropdown {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-dropdown__arrow {\n\t\twidth: var(--ck-dropdown-arrow-size);\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-dropdown__arrow {\n\t\t\tright: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-dropdown__arrow {\n\t\t\tleft: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-dropdown__arrow {\n\t\t@mixin ck-disabled;\n\t}\n\n\t& .ck-button.ck-dropdown__button {\n\t\t@mixin ck-dir ltr {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-right: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t/* #23 */\n\t\t& .ck-button__label {\n\t\t\twidth: 7em;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t\t&.ck-disabled .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/816 */\n\t\t&.ck-on {\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t&.ck-dropdown__button_label-width_auto .ck-button__label {\n\t\t\twidth: auto;\n\t\t}\n\t}\n}\n\n.ck.ck-dropdown__panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tbackground: var(--ck-color-dropdown-panel-background);\n\tborder: 1px solid var(--ck-color-dropdown-panel-border);\n\tbottom: 0;\n\n\t/* Make sure the panel is at least as wide as the drop-down\'s button. */\n\tmin-width: 100%;\n\n\t/* Disabled corner border radius to be consistent with the .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-dropdown__panel_se {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_sw {\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_ne {\n\t\tborder-bottom-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_nw {\n\t\tborder-bottom-right-radius: 0;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{width:var(--ck-icon-size);height:var(--ck-icon-size);font-size:.8333350694em;will-change:transform}.ck.ck-icon,.ck.ck-icon *{color:inherit;cursor:inherit}.ck.ck-icon :not([fill]){fill:currentColor}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/icon/icon.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css"],
            names: [],
            mappings: "AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YACC,yBAA0B,CAC1B,0BAA2B,CAG3B,uBAAwB,CAQxB,qBAcD,CAZC,0BARA,aAAc,CAGd,cAgBA,CAJC,yBAEC,iBACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-icon {\n\tvertical-align: middle;\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));\n}\n\n.ck.ck-icon {\n\twidth: var(--ck-icon-size);\n\theight: var(--ck-icon-size);\n\n\t/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */\n\tfont-size: .8333350694em;\n\n\tcolor: inherit;\n\n\t/* Inherit cursor style (#5). */\n\tcursor: inherit;\n\n\t/* This will prevent blurry icons on Firefox. See #340. */\n\twill-change: transform;\n\n\t& * {\n\t\t/* Inherit cursor style (#5). */\n\t\tcursor: inherit;\n\n\t\t/* Allows dynamic coloring of the icons. */\n\t\tcolor: inherit;\n\n\t\t&:not([fill]) {\n\t\t\t/* Needed by FF. */\n\t\t\tfill: currentColor;\n\t\t}\n\t}\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, '.ck.ck-tooltip,.ck.ck-tooltip .ck-tooltip__text:after{position:absolute;pointer-events:none;-webkit-backface-visibility:hidden}.ck.ck-tooltip{visibility:hidden;opacity:0;display:none;z-index:var(--ck-z-modal)}.ck.ck-tooltip .ck-tooltip__text{display:inline-block}.ck.ck-tooltip .ck-tooltip__text:after{content:"";width:0;height:0}:root{--ck-tooltip-arrow-size:5px}.ck.ck-tooltip{left:50%;top:0;transition:opacity .2s ease-in-out .2s}.ck.ck-tooltip .ck-tooltip__text{border-radius:0}.ck-rounded-corners .ck.ck-tooltip .ck-tooltip__text,.ck.ck-tooltip .ck-tooltip__text.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-tooltip .ck-tooltip__text{font-size:.9em;line-height:1.5;color:var(--ck-color-tooltip-text);padding:var(--ck-spacing-small) var(--ck-spacing-medium);background:var(--ck-color-tooltip-background);position:relative;left:-50%}.ck.ck-tooltip .ck-tooltip__text:after{transition:opacity .2s ease-in-out .2s;border-style:solid;left:50%}.ck.ck-tooltip.ck-tooltip_s,.ck.ck-tooltip.ck-tooltip_se,.ck.ck-tooltip.ck-tooltip_sw{bottom:calc(var(--ck-tooltip-arrow-size)*-1);transform:translateY(100%)}.ck.ck-tooltip.ck-tooltip_s .ck-tooltip__text:after,.ck.ck-tooltip.ck-tooltip_se .ck-tooltip__text:after,.ck.ck-tooltip.ck-tooltip_sw .ck-tooltip__text:after{top:calc(var(--ck-tooltip-arrow-size)*-1 + 1px);transform:translateX(-50%);border-left-color:transparent;border-bottom-color:var(--ck-color-tooltip-background);border-right-color:transparent;border-top-color:transparent;border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:var(--ck-tooltip-arrow-size);border-right-width:var(--ck-tooltip-arrow-size);border-top-width:0}.ck.ck-tooltip.ck-tooltip_sw{right:50%;left:auto}.ck.ck-tooltip.ck-tooltip_sw .ck-tooltip__text{left:auto;right:calc(var(--ck-tooltip-arrow-size)*-2)}.ck.ck-tooltip.ck-tooltip_sw .ck-tooltip__text:after{left:auto;right:0}.ck.ck-tooltip.ck-tooltip_se{left:50%;right:auto}.ck.ck-tooltip.ck-tooltip_se .ck-tooltip__text{right:auto;left:calc(var(--ck-tooltip-arrow-size)*-2)}.ck.ck-tooltip.ck-tooltip_se .ck-tooltip__text:after{right:auto;left:0;transform:translateX(50%)}.ck.ck-tooltip.ck-tooltip_n{top:calc(var(--ck-tooltip-arrow-size)*-1);transform:translateY(-100%)}.ck.ck-tooltip.ck-tooltip_n .ck-tooltip__text:after{bottom:calc(var(--ck-tooltip-arrow-size)*-1);transform:translateX(-50%);border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;border-top-color:var(--ck-color-tooltip-background);border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:0;border-right-width:var(--ck-tooltip-arrow-size);border-top-width:var(--ck-tooltip-arrow-size)}.ck.ck-tooltip.ck-tooltip_e{left:calc(100% + var(--ck-tooltip-arrow-size));top:50%}.ck.ck-tooltip.ck-tooltip_e .ck-tooltip__text{left:0;transform:translateY(-50%)}.ck.ck-tooltip.ck-tooltip_e .ck-tooltip__text:after{left:calc(var(--ck-tooltip-arrow-size)*-1);top:calc(50% - var(--ck-tooltip-arrow-size)*1);border-left-color:transparent;border-bottom-color:transparent;border-right-color:var(--ck-color-tooltip-background);border-top-color:transparent;border-left-width:0;border-bottom-width:var(--ck-tooltip-arrow-size);border-right-width:var(--ck-tooltip-arrow-size);border-top-width:var(--ck-tooltip-arrow-size)}.ck.ck-tooltip.ck-tooltip_w{right:calc(100% + var(--ck-tooltip-arrow-size));left:auto;top:50%}.ck.ck-tooltip.ck-tooltip_w .ck-tooltip__text{left:0;transform:translateY(-50%)}.ck.ck-tooltip.ck-tooltip_w .ck-tooltip__text:after{left:100%;top:calc(50% - var(--ck-tooltip-arrow-size)*1);border-left-color:var(--ck-color-tooltip-background);border-bottom-color:transparent;border-right-color:transparent;border-top-color:transparent;border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:var(--ck-tooltip-arrow-size);border-right-width:0;border-top-width:var(--ck-tooltip-arrow-size)}', "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/tooltip.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
            names: [],
            mappings: "AAKA,sDAEC,iBAAkB,CAGlB,mBAAoB,CAIpB,kCACD,CAEA,eAEC,iBAAkB,CAClB,SAAU,CACV,YAAa,CACb,yBAWD,CATC,iCACC,oBAOD,CALC,uCACC,UAAW,CACX,OAAQ,CACR,QACD,CCxBF,MACC,2BACD,CAEA,eACC,QAAS,CAMT,KAAM,CAON,sCAwKD,CAtKC,iCChBA,eDqCA,CArBA,yGCZC,qCDiCD,CArBA,iCAGC,cAAe,CACf,eAAgB,CAChB,kCAAmC,CACnC,wDAAyD,CACzD,6CAA8C,CAC9C,iBAAkB,CAClB,SAYD,CAVC,uCAMC,sCAAuC,CACvC,kBAAmB,CACnB,QACD,CAYD,sFAGC,4CAA+C,CAC/C,0BASD,CAPC,8JAEC,+CAAkD,CAClD,0BAA6B,CAC7B,6BAAoF,CAApF,sDAAoF,CAApF,8BAAoF,CAApF,4BAAoF,CACpF,8CAAsG,CAAtG,gDAAsG,CAAtG,+CAAsG,CAAtG,kBACD,CAaD,6BACC,SAAU,CACV,SAWD,CATC,+CACC,SAAU,CACV,2CACD,CAEA,qDACC,SAAU,CACV,OACD,CAYD,6BACC,QAAS,CACT,UAYD,CAVC,+CACC,UAAW,CACX,0CACD,CAEA,qDACC,UAAW,CACX,MAAO,CACP,yBACD,CAYD,4BACC,yCAA4C,CAC5C,2BAQD,CANC,oDACC,4CAA+C,CAC/C,0BAA6B,CAC7B,6BAAoF,CAApF,+BAAoF,CAApF,8BAAoF,CAApF,mDAAoF,CACpF,8CAAsG,CAAtG,qBAAsG,CAAtG,+CAAsG,CAAtG,6CACD,CAUD,4BACC,8CAA+C,CAC/C,OAaD,CAXC,8CACC,MAAO,CACP,0BAQD,CANC,oDACC,0CAA6C,CAC7C,8CAAiD,CACjD,6BAAoF,CAApF,+BAAoF,CAApF,qDAAoF,CAApF,4BAAoF,CACpF,mBAAsG,CAAtG,gDAAsG,CAAtG,+CAAsG,CAAtG,6CACD,CAWF,4BACC,+CAAgD,CAChD,SAAU,CACV,OAaD,CAXC,8CACC,MAAO,CACP,0BAQD,CANC,oDACC,SAAU,CACV,8CAAiD,CACjD,oDAAoF,CAApF,+BAAoF,CAApF,8BAAoF,CAApF,4BAAoF,CACpF,8CAAsG,CAAtG,gDAAsG,CAAtG,oBAAsG,CAAtG,6CACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-tooltip,\n.ck.ck-tooltip .ck-tooltip__text::after {\n\tposition: absolute;\n\n\t/* Without this, hovering the tooltip could keep it visible. */\n\tpointer-events: none;\n\n\t/* This is to get rid of flickering when transitioning opacity in Chrome.\n\tIt\'s weird but it works. */\n\t-webkit-backface-visibility: hidden;\n}\n\n.ck.ck-tooltip {\n\t/* Tooltip is hidden by default. */\n\tvisibility: hidden;\n\topacity: 0;\n\tdisplay: none;\n\tz-index: var(--ck-z-modal);\n\n\t& .ck-tooltip__text {\n\t\tdisplay: inline-block;\n\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t}\n\t}\n}\n', '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-tooltip-arrow-size: 5px;\n}\n\n.ck.ck-tooltip {\n\tleft: 50%;\n\n\t/*\n\t * Prevent blurry tooltips in LoDPI environments.\n\t * See https://github.com/ckeditor/ckeditor5/issues/1802.\n\t */\n\ttop: 0;\n\n\t/*\n\t * For the transition to work, the tooltip must be controlled\n\t * using visibility+opacity. A delay prevents a "tooltip avalanche"\n\t * i.e. when scanning the toolbar with mouse cursor.\n\t */\n\ttransition: opacity .2s ease-in-out .2s;\n\n\t& .ck-tooltip__text {\n\t\t@mixin ck-rounded-corners;\n\n\t\tfont-size: .9em;\n\t\tline-height: 1.5;\n\t\tcolor: var(--ck-color-tooltip-text);\n\t\tpadding: var(--ck-spacing-small) var(--ck-spacing-medium);\n\t\tbackground: var(--ck-color-tooltip-background);\n\t\tposition: relative;\n\t\tleft: -50%;\n\n\t\t&::after {\n\t\t\t/*\n\t\t\t * For the transition to work, the tooltip must be controlled\n\t\t\t * using visibility+opacity. A delay prevents a "tooltip avalanche"\n\t\t\t * i.e. when scanning the toolbar with mouse cursor.\n\t\t\t */\n\t\t\ttransition: opacity .2s ease-in-out .2s;\n\t\t\tborder-style: solid;\n\t\t\tleft: 50%;\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip south of the element.\n\t *\n\t *       [element]\n\t *           ^\n\t *     +-----------+\n\t *     |  Tooltip  |\n\t *     +-----------+\n\t */\n\t&.ck-tooltip_s,\n\t&.ck-tooltip_sw,\n\t&.ck-tooltip_se {\n\t\tbottom: calc(-1 * var(--ck-tooltip-arrow-size));\n\t\ttransform: translateY( 100% );\n\n\t\t& .ck-tooltip__text::after {\n\t\t\t/* 1px addresses gliches in rendering causing gap between the triangle and the text */\n\t\t\ttop: calc(-1 * var(--ck-tooltip-arrow-size) + 1px);\n\t\t\ttransform: translateX( -50% );\n\t\t\tborder-color: transparent transparent var(--ck-color-tooltip-background) transparent;\n\t\t\tborder-width: 0 var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size);\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip south-west of the element.\n\t *\n\t *        [element]\n\t *            ^\n\t *  +-----------+\n\t *  |  Tooltip  |\n\t *  +-----------+\n\t */\n\n\t&.ck-tooltip_sw {\n\t\tright: 50%;\n\t\tleft: auto;\n\n\t\t& .ck-tooltip__text {\n\t\t\tleft: auto;\n\t\t\tright: calc( -2 * var(--ck-tooltip-arrow-size));\n\t\t}\n\n\t\t& .ck-tooltip__text::after {\n\t\t\tleft: auto;\n\t\t\tright: 0;\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip south-east of the element.\n\t *\n\t *  [element]\n\t *      ^\n\t *    +-----------+\n\t *    |  Tooltip  |\n\t *    +-----------+\n\t */\n\t&.ck-tooltip_se {\n\t\tleft: 50%;\n\t\tright: auto;\n\n\t\t& .ck-tooltip__text {\n\t\t\tright: auto;\n\t\t\tleft: calc( -2 * var(--ck-tooltip-arrow-size));\n\t\t}\n\n\t\t& .ck-tooltip__text::after {\n\t\t\tright: auto;\n\t\t\tleft: 0;\n\t\t\ttransform: translateX( 50% );\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip north of the element.\n\t *\n\t *     +-----------+\n\t *     |  Tooltip  |\n\t *     +-----------+\n\t *           V\n\t *       [element]\n\t */\n\t&.ck-tooltip_n {\n\t\ttop: calc(-1 * var(--ck-tooltip-arrow-size));\n\t\ttransform: translateY( -100% );\n\n\t\t& .ck-tooltip__text::after {\n\t\t\tbottom: calc(-1 * var(--ck-tooltip-arrow-size));\n\t\t\ttransform: translateX( -50% );\n\t\t\tborder-color: var(--ck-color-tooltip-background) transparent transparent transparent;\n\t\t\tborder-width: var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) 0 var(--ck-tooltip-arrow-size);\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip east of the element.\n\t *\n\t *                +----------+\n\t *    [element] < |   east   |\n\t *                +----------+\n\t */\n\t&.ck-tooltip_e {\n\t\tleft: calc(100% + var(--ck-tooltip-arrow-size));\n\t\ttop: 50%;\n\n\t\t& .ck-tooltip__text {\n\t\t\tleft: 0;\n\t\t\ttransform: translateY( -50% );\n\n\t\t\t&::after {\n\t\t\t\tleft: calc(-1 * var(--ck-tooltip-arrow-size));\n\t\t\t\ttop: calc(50% - 1 * var(--ck-tooltip-arrow-size));\n\t\t\t\tborder-color: transparent var(--ck-color-tooltip-background) transparent transparent;\n\t\t\t\tborder-width: var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip west of the element.\n\t *\n\t *    +----------+\n\t *    |   west   | > [element]\n\t *    +----------+\n\t */\n\t&.ck-tooltip_w {\n\t\tright: calc(100% + var(--ck-tooltip-arrow-size));\n\t\tleft: auto;\n\t\ttop: 50%;\n\n\t\t& .ck-tooltip__text {\n\t\t\tleft: 0;\n\t\t\ttransform: translateY( -50% );\n\n\t\t\t&::after {\n\t\t\t\tleft: 100%;\n\t\t\t\ttop: calc(50% - 1 * var(--ck-tooltip-arrow-size));\n\t\t\t\tborder-color: transparent transparent transparent var(--ck-color-tooltip-background);\n\t\t\t\tborder-width: var(--ck-tooltip-arrow-size) 0 var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size);\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck.ck-button,a.ck.ck-button{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-tooltip,a.ck.ck-button .ck-tooltip{display:block}@media (hover:none){.ck.ck-button .ck-tooltip,a.ck.ck-button .ck-tooltip{display:none}}.ck.ck-button,a.ck.ck-button{position:relative;display:inline-flex;align-items:center;justify-content:left}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button:hover .ck-tooltip,a.ck.ck-button:hover .ck-tooltip{visibility:visible;opacity:1}.ck.ck-button:focus:not(:hover) .ck-tooltip,a.ck.ck-button:focus:not(:hover) .ck-tooltip{display:none}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-default-active-shadow)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{white-space:nowrap;cursor:default;vertical-align:middle;padding:var(--ck-spacing-tiny);text-align:center;min-width:var(--ck-ui-component-min-height);min-height:var(--ck-ui-component-min-height);line-height:1;font-size:inherit;border:1px solid transparent;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;-webkit-appearance:none}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{font-size:inherit;font-weight:inherit;color:inherit;cursor:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__icon{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-right:calc(var(--ck-spacing-small)*-1);margin-left:var(--ck-spacing-small)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-on-active-shadow)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-action-active-shadow)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/button.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css"],
            names: [],
            mappings: "AAQA,6BCCC,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6BD,CE/BC,qDACC,aAqBD,CAHC,oBAnBD,qDAoBE,YAEF,CADC,CFvBF,6BAKC,iBAAkB,CAClB,mBAAoB,CACpB,kBAAmB,CACnB,oBAyBD,CAvBC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEkBA,iEACC,kBAAmB,CACnB,SACD,CAbA,yFACC,YACD,CC7BD,6BCAC,oDD0ID,CCvIE,6EACC,0DACD,CAEA,+EACC,2DAA4C,CAC5C,uEACD,CAID,qDACC,6DACD,CDhBD,6BEDC,eF2ID,CA1IA,wIEGE,qCFuIF,CA1IA,6BAKC,kBAAmB,CACnB,cAAe,CACf,qBAAsB,CACtB,8BAA+B,CAC/B,iBAAkB,CAGlB,2CAA4C,CAC5C,4CAA6C,CAI7C,aAAc,CAGd,iBAAkB,CAGlB,4BAA6B,CAG7B,4DAA8D,CAG9D,uBA6GD,CA3GC,oFGjCA,YAAa,CACb,2BAA2B,CCF3B,2CJsCA,CAIC,kJAEC,aACD,CAGD,iEAEC,iBAAkB,CAClB,mBAAoB,CACpB,aAAc,CACd,cAAe,CAIf,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAEA,uFK3FD,kCL6FC,CAGA,yFKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAOE,6CAAgD,CAChD,mCAEF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDiIA,CC9HC,yFACC,qDACD,CAEA,2FACC,sDAA4C,CAC5C,kEACD,CAID,iEACC,wDACD,CDmHA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC7IC,mDDkJD,CC/IE,2FACC,yDACD,CAEA,6FACC,0DAA4C,CAC5C,sEACD,CAID,mEACC,4DACD,CD6HD,2CAIC,wCACD,CAEA,uCAEC,eACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n@import "../tooltip/mixins/_tooltip.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-unselectable;\n\t@mixin ck-tooltip_enabled;\n\n\tposition: relative;\n\tdisplay: inline-flex;\n\talign-items: center;\n\tjustify-content: left;\n\n\t& .ck-button__label {\n\t\tdisplay: none;\n\t}\n\n\t&.ck-button_with-text {\n\t\t& .ck-button__label {\n\t\t\tdisplay: inline-block;\n\t\t}\n\t}\n\n\t/* Center the icon horizontally in a button without text. */\n\t&:not(.ck-button_with-text)  {\n\t\tjustify-content: center;\n\t}\n\n\t&:hover {\n\t\t@mixin ck-tooltip_visible;\n\t}\n\n\t/* Get rid of the native focus outline around the tooltip when focused (but not :hover). */\n\t&:focus:not(:hover) {\n\t\t@mixin ck-tooltip_disabled;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Enables the tooltip, which is the tooltip is in DOM but\n * not yet displayed.\n */\n@define-mixin ck-tooltip_enabled {\n\t& .ck-tooltip {\n\t\tdisplay: block;\n\n\t\t/*\n\t\t * Don't display tooltips in devices which don't support :hover.\n\t\t * In fact, it's all about iOS, which forces user to click UI elements twice to execute\n\t\t * the primary action, when tooltips are enabled.\n\t\t *\n\t\t * Q: OK, but why not the following query?\n\t\t *\n\t\t *   @media (hover) {\n\t\t *       display: block;\n\t\t *   }\n\t\t *\n\t\t * A: Because FF does not support it and it would completely disable tooltips\n\t\t * in that browser.\n\t\t *\n\t\t * More in https://github.com/ckeditor/ckeditor5/issues/920.\n\t\t */\n\t\t@media (hover:none) {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/**\n * Disables the tooltip making it disappear from DOM.\n */\n@define-mixin ck-tooltip_disabled {\n\t& .ck-tooltip {\n\t\tdisplay: none;\n\t}\n}\n\n/**\n * Shows the tooltip, which is already in DOM.\n * Requires `ck-tooltip_enabled` first.\n */\n@define-mixin ck-tooltip_visible {\n\t& .ck-tooltip {\n\t\tvisibility: visible;\n\t\topacity: 1;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../mixins/_button.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-button-colors --ck-color-button-default;\n\t@mixin ck-rounded-corners;\n\n\twhite-space: nowrap;\n\tcursor: default;\n\tvertical-align: middle;\n\tpadding: var(--ck-spacing-tiny);\n\ttext-align: center;\n\n\t/* A very important piece of styling. Go to variable declaration to learn more. */\n\tmin-width: var(--ck-ui-component-min-height);\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Normalize the height of the line. Removing this will break consistent height\n\tamong text and text-less buttons (with icons). */\n\tline-height: 1;\n\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t/* Avoid flickering when the foucs border shows up. */\n\tborder: 1px solid transparent;\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .2s ease-in-out, border .2s ease-in-out;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */\n\t-webkit-appearance: none;\n\n\t&:active,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t/* Allow icon coloring using the text "color" property. */\n\t& .ck-button__icon {\n\t\t& use,\n\t\t& use * {\n\t\t\tcolor: inherit;\n\t\t}\n\t}\n\n\t& .ck-button__label {\n\t\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\t\tfont-size: inherit;\n\t\tfont-weight: inherit;\n\t\tcolor: inherit;\n\t\tcursor: inherit;\n\n\t\t/* Must be consistent with .ck-icon\'s vertical align. Otherwise, buttons with and\n\t\twithout labels (but with icons) have different sizes in Chrome */\n\t\tvertical-align: middle;\n\n\t\t@mixin ck-dir ltr {\n\t\t\ttext-align: left;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttext-align: right;\n\t\t}\n\t}\n\n\t& .ck-button__keystroke {\n\t\tcolor: inherit;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t}\n\n\t\tfont-weight: bold;\n\t\topacity: .7;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t&.ck-disabled {\n\t\t&:active,\n\t\t&:focus {\n\t\t\t/* The disabled button should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t\t& .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t& .ck-button__keystroke {\n\t\t\topacity: .3;\n\t\t}\n\t}\n\n\t&.ck-button_with-text {\n\t\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-standard);\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-button_with-keystroke {\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__label {\n\t\t\tflex-grow: 1;\n\t\t}\n\t}\n\n\t/* A style of the button which is currently on, e.g. its feature is active. */\n\t&.ck-on {\n\t\t@mixin ck-button-colors --ck-color-button-on;\n\t}\n\n\t&.ck-button-save {\n\t\tcolor: var(--ck-color-button-save);\n\t}\n\n\t&.ck-button-cancel {\n\t\tcolor: var(--ck-color-button-cancel);\n\t}\n}\n\n/* A style of the button which handles the primary action. */\n.ck.ck-button-action,\na.ck.ck-button-action {\n\t@mixin ck-button-colors --ck-color-button-action;\n\n\tcolor: var(--ck-color-button-action-text);\n}\n\n.ck.ck-button-bold,\na.ck.ck-button-bold {\n\tfont-weight: bold;\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements a button of given background color.\n *\n * @param {String} $background - Background color of the button.\n * @param {String} $border - Border color of the button.\n */\n@define-mixin ck-button-colors $prefix {\n\tbackground: var($(prefix)-background);\n\n\t&:not(.ck-disabled) {\n\t\t&:hover {\n\t\t\tbackground: var($(prefix)-hover-background);\n\t\t}\n\n\t\t&:active {\n\t\t\tbackground: var($(prefix)-active-background);\n\t\t\tbox-shadow: inset 0 2px 2px var($(prefix)-active-shadow);\n\t\t}\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t&.ck-disabled {\n\t\tbackground: var($(prefix)-disabled-background);\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck.ck-list{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-direction:column}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{list-style-type:none;background:var(--ck-color-list-background)}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{min-height:unset;width:100%;text-align:left;border-radius:0;padding:calc(var(--ck-line-height-base)*0.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*0.4*var(--ck-font-size-base))}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{height:1px;width:100%;background:var(--ck-color-base-border)}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/list/list.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
            names: [],
            mappings: "AAOA,YCEC,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBAAgB,CDFhB,YAAa,CACb,qBAcD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAGC,oBAAqB,CACrB,0CACD,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BACC,gBAAiB,CACjB,UAAW,CACX,eAAgB,CAChB,eAAgB,CAKhB,mIAiCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,2DACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,uBACC,UAAW,CACX,UAAW,CACX,sCACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-list {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-direction: column;\n\n\t& .ck-list__item,\n\t& .ck-list__separator {\n\t\tdisplay: block;\n\t}\n\n\t/* Make sure that whatever child of the list item gets focus, it remains on the\n\ttop. Thanks to that, styles like box-shadow, outline, etc. are not masked by\n\tadjacent list items. */\n\t& .ck-list__item > *:focus {\n\t\tposition: relative;\n\t\tz-index: var(--ck-z-default);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-list {\n\t@mixin ck-rounded-corners;\n\n\tlist-style-type: none;\n\tbackground: var(--ck-color-list-background);\n}\n\n.ck.ck-list__item {\n\tcursor: default;\n\tmin-width: 12em;\n\n\t& .ck-button {\n\t\tmin-height: unset;\n\t\twidth: 100%;\n\t\ttext-align: left;\n\t\tborder-radius: 0;\n\n\t\t/* List items should have the same height. Use absolute units to make sure it is so\n\t\t   because e.g. different heading styles may have different height\n\t\t   https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\tpadding:\n\t\t\tcalc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))\n\t\t\tcalc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\n\t\t& .ck-button__label {\n\t\t\t/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\t\tline-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-button-on-background);\n\t\t\tcolor: var(--ck-color-list-button-on-text);\n\n\t\t\t&:active {\n\t\t\t\tbox-shadow: none;\n\t\t\t}\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-on-background-focus);\n\t\t\t}\n\n\t\t\t&:focus:not(.ck-disabled) {\n\t\t\t\tborder-color: var(--ck-color-base-background);\n\t\t\t}\n\t\t}\n\n\t\t&:hover:not(.ck-disabled) {\n\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t}\n\t}\n\n\t/* It\'s unnecessary to change the background/text of a switch toggle; it has different ways\n\tof conveying its state (like the switcher) */\n\t& .ck-switchbutton {\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-background);\n\t\t\tcolor: inherit;\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t\t\tcolor: inherit;\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-list__separator {\n\theight: 1px;\n\twidth: 100%;\n\tbackground: var(--ck-color-base-border);\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:1.0769230769em;--ck-switch-button-toggle-spacing:1px;--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - var(--ck-switch-button-toggle-spacing)*2)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{transition:background .4s ease;width:var(--ck-switch-button-toggle-width);background:var(--ck-color-switch-button-off-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*0.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{margin:var(--ck-switch-button-toggle-spacing);width:var(--ck-switch-button-toggle-inner-size);height:var(--ck-switch-button-toggle-inner-size);background:var(--ck-color-switch-button-inner-background);transition:all .3s ease}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var(--ck-switch-button-translation))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var(--ck-switch-button-translation)*-1))}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/switchbutton.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css"],
            names: [],
            mappings: "AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,mDAAoD,CACpD,qCAAsC,CACtC,gKAKD,CAGC,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDC3BA,eDoEA,CAzCA,yICvBC,qCDgED,CAzCA,2DAKE,gBAoCF,CAzCA,2DAUE,iBA+BF,CAzCA,iDAcC,8BAAiC,CAEjC,0CAA2C,CAC3C,uDAwBD,CAtBC,2EC9CD,eD2DC,CAbA,6LC1CA,qCAAsC,CD4CpC,+CAWF,CAbA,2EAMC,6CAA8C,CAC9C,+CAAgD,CAChD,gDAAiD,CACjD,yDAA0D,CAG1D,uBACD,CAEA,uDACC,6DAKD,CAHC,iFACC,+DACD,CAIF,6DExEA,kCF0EA,CAEA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,yDAMF,CAXA,2FASE,kEAEF",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__toggle {\n\t\tdisplay: block;\n\n\t\t& .ck-button__toggle__inner {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature\nof the component, floating–point numbers have been used which, for the default font size\n(see: --ck-font-size-base), will generate simple integers. */\n:root {\n\t/* 34px at 13px font-size */\n\t--ck-switch-button-toggle-width: 2.6153846154em;\n\t/* 14px at 13px font-size */\n\t--ck-switch-button-toggle-inner-size: 1.0769230769em;\n\t--ck-switch-button-toggle-spacing: 1px;\n\t--ck-switch-button-translation: calc(\n\t\tvar(--ck-switch-button-toggle-width) -\n\t\tvar(--ck-switch-button-toggle-inner-size) -\n\t\t2 * var(--ck-switch-button-toggle-spacing)\n\t);\n}\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__label {\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-right: calc(2 * var(--ck-spacing-large));\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-left: calc(2 * var(--ck-spacing-large));\n\t\t}\n\t}\n\n\t& .ck-button__toggle {\n\t\t@mixin ck-rounded-corners;\n\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Make sure the toggle is always to the right as far as possible. */\n\t\t\tmargin-left: auto;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Make sure the toggle is always to the left as far as possible. */\n\t\t\tmargin-right: auto;\n\t\t}\n\n\t\t/* Gently animate the background color of the toggle switch */\n\t\ttransition: background 400ms ease;\n\n\t\twidth: var(--ck-switch-button-toggle-width);\n\t\tbackground: var(--ck-color-switch-button-off-background);\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: calc(.5 * var(--ck-border-radius));\n\t\t\t}\n\n\t\t\t/* Leave some tiny bit of space around the inner part of the switch */\n\t\t\tmargin: var(--ck-switch-button-toggle-spacing);\n\t\t\twidth: var(--ck-switch-button-toggle-inner-size);\n\t\t\theight: var(--ck-switch-button-toggle-inner-size);\n\t\t\tbackground: var(--ck-color-switch-button-inner-background);\n\n\t\t\t/* Gently animate the inner part of the toggle switch */\n\t\t\ttransition: all 300ms ease;\n\t\t}\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-off-hover-background);\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\tbox-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-button__toggle {\n\t\t@mixin ck-disabled;\n\t}\n\n\t&.ck-on .ck-button__toggle {\n\t\tbackground: var(--ck-color-switch-button-on-background);\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-on-hover-background);\n\t\t}\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t/*\n\t\t\t * Move the toggle switch to the right. It will be animated.\n\t\t\t */\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\ttransform: translateX( var( --ck-switch-button-translation ) );\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\ttransform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ":root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown .ck-dropdown__panel{width:max-content;max-width:var(--ck-toolbar-dropdown-max-width)}.ck.ck-toolbar-dropdown .ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/toolbardropdown.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css"],
            names: [],
            mappings: "AAKA,MACC,oCACD,CAGC,4CAEC,iBAAkB,CAClB,8CAOD,CAJE,6DACC,qCACD,CCbH,oCACC,QACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-toolbar-dropdown-max-width: 60vw;\n}\n\n.ck.ck-toolbar-dropdown {\n\t& .ck-dropdown__panel {\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/5586 */\n\t\twidth: max-content;\n\t\tmax-width: var(--ck-toolbar-dropdown-max-width);\n\n\t\t& .ck-button {\n\t\t\t&:focus {\n\t\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t\t}\n\t\t}\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown .ck-toolbar {\n\tborder: 0;\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
            names: [],
            mappings: "AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDIpC,wBAAyB,CACzB,2BAA4B,CAC5B,4BAEF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-dropdown .ck-dropdown__panel .ck-list {\n\t/* Disabled radius of top-left border to be consistent with .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t/* Make sure the button belonging to the first/last child of the list goes well with the\n\tborder radius of the entire panel. */\n\t& .ck-list__item {\n\t\t&:first-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\n\t\t&:last-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck.ck-toolbar{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-flow:row nowrap;align-items:center}.ck.ck-toolbar>.ck-toolbar__items{display:flex;flex-flow:row wrap;align-items:center;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);padding:0 var(--ck-spacing-small);border:1px solid var(--ck-color-toolbar-border)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;width:1px;min-width:1px;background:var(--ck-color-toolbar-border);margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{width:100%;margin:0;border-radius:0;border:0}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar[dir=rtl].ck-toolbar_compact>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-toolbar[dir=rtl].ck-toolbar_compact>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-top-right-radius:0;border-bottom-right-radius:0}.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl].ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child){margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar[dir=ltr].ck-toolbar_compact>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-top-right-radius:0;border-bottom-right-radius:0}.ck.ck-toolbar[dir=ltr].ck-toolbar_compact>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr].ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child){margin-right:var(--ck-spacing-small)}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/toolbar.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
            names: [],
            mappings: "AAOA,eCEC,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBAAgB,CDFhB,YAAa,CACb,oBAAqB,CACrB,kBA6CD,CA3CC,kCACC,YAAa,CACb,kBAAmB,CACnB,kBAAmB,CACnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eD0FD,CA7FA,qECOE,qCDsFF,CA7FA,eAGC,6CAA8C,CAC9C,iCAAkC,CAClC,+CAwFD,CAtFC,yCACC,kBAAmB,CACnB,SAAU,CACV,aAAc,CACd,yCAA0C,CAM1C,kCAAmC,CACnC,qCACD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAGC,kCAAmC,CACnC,qCACD,CAEA,mCAEC,SAgBD,CAbC,0DAEC,UAAW,CAGX,QAAS,CAGT,eAAgB,CAGhB,QACD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAvFF,qCA2FE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JACC,wBAAyB,CACzB,2BACD,CAGA,2JACC,yBAA0B,CAC1B,4BACD,CAID,qGACC,mCACD,CAGA,yLACC,mCACD,CAWA,qHACC,cACD,CAIC,6JACC,yBAA0B,CAC1B,4BACD,CAGA,2JACC,wBAAyB,CACzB,2BACD,CAID,qGACC,oCACD,CAGA,yLACC,oCACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-flow: row nowrap;\n\talign-items: center;\n\n\t& > .ck-toolbar__items {\n\t\tdisplay: flex;\n\t\tflex-flow: row wrap;\n\t\talign-items: center;\n\t\tflex-grow: 1;\n\n\t}\n\n\t& .ck.ck-toolbar__separator {\n\t\tdisplay: inline-block;\n\n\t\t/*\n\t\t * A leading or trailing separator makes no sense (separates from nothing on one side).\n\t\t * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and\n\t\t * moved to another toolbar in the dropdown.\n\t\t */\n\t\t&:first-child,\n\t\t&:last-child {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\tflex-basis: 100%;\n\t}\n\n\t&.ck-toolbar_grouping > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t&.ck-toolbar_vertical > .ck-toolbar__items {\n\t\tflex-direction: column;\n\t}\n\n\t&.ck-toolbar_floating > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t& > .ck-dropdown__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-toolbar-background);\n\tpadding: 0 var(--ck-spacing-small);\n\tborder: 1px solid var(--ck-color-toolbar-border);\n\n\t& .ck.ck-toolbar__separator {\n\t\talign-self: stretch;\n\t\twidth: 1px;\n\t\tmin-width: 1px;\n\t\tbackground: var(--ck-color-toolbar-border);\n\n\t\t/*\n\t\t * These margins make the separators look better in balloon toolbars (when aligned with the "tip").\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/7493.\n\t\t */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\theight: 0;\n\t}\n\n\t& > .ck-toolbar__items {\n\t\t& > *:not(.ck-toolbar__line-break) {\n\t\t\t/* (#11) Separate toolbar items. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\n\t\t/* Don\'t display a separator after an empty items container, for instance,\n\t\twhen all items were grouped */\n\t\t&:empty + .ck.ck-toolbar__separator {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/* Make sure items wrapped to the next line have v-spacing */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t&.ck-toolbar_vertical {\n\t\t/* Items in a vertical toolbar span the entire width. */\n\t\tpadding: 0;\n\n\t\t/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */\n\t\t& > .ck-toolbar__items > .ck {\n\t\t\t/* Items in a vertical toolbar should span the horizontal space. */\n\t\t\twidth: 100%;\n\n\t\t\t/* Items in a vertical toolbar should have no margin. */\n\t\t\tmargin: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */\n\t\t\tborder-radius: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so any border is pointless. */\n\t\t\tborder: 0;\n\t\t}\n\t}\n\n\t&.ck-toolbar_compact {\n\t\t/* No spacing around items. */\n\t\tpadding: 0;\n\n\t\t& > .ck-toolbar__items > * {\n\t\t\t/* Compact toolbar items have no spacing between them. */\n\t\t\tmargin: 0;\n\n\t\t\t/* "Middle" children should have no rounded corners. */\n\t\t\t&:not(:first-child):not(:last-child) {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/*\n\t\t * Dropdown button has asymmetric padding to fit the arrow.\n\t\t * This button has no arrow so let\'s revert that padding back to normal.\n\t\t */\n\t\t& > .ck.ck-button.ck-dropdown__button {\n\t\t\tpadding-left: var(--ck-spacing-tiny);\n\t\t}\n\t}\n\n\t@nest .ck-toolbar-container & {\n\t\tborder: 0;\n\t}\n}\n\n/* stylelint-disable */\n\n/*\n * Styles for RTL toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="rtl"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="rtl"] {\n\t& > .ck-toolbar__items > .ck {\n\t\tmargin-right: 0;\n\t}\n\n\t&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {\n\t\t/* (#11) Separate toolbar items. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-left: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n/*\n * Styles for LTR toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="ltr"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="ltr"] {\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-right: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n}\n\n/* stylelint-enable */\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-modal)}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-bottom-width:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px;border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;height:45vh;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-editor-classic/theme/classiceditor.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-editor-classic/classiceditor.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
            names: [],
            mappings: "AAKA,cAIC,iBAMD,CAJC,2DAEC,yBACD,CCLC,gDCED,eDKC,CAPA,uICMA,qCAAsC,CDJpC,2BAA4B,CAC5B,4BAIF,CAPA,gDAMC,qBACD,CAEA,iFACC,uBAAwB,CCR1B,eDaC,CANA,yMCHA,qCAAsC,CDOpC,eAEF,CAKF,yCAEC,0CAA2C,CCpB3C,eD8BD,CAZA,yHCdE,qCAAsC,CDmBtC,wBAAyB,CACzB,yBAMF,CAHC,0DACC,wCACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor {\n\t/* All the elements within `.ck-editor` are positioned relatively to it.\n\t If any element needs to be positioned with respect to the <body>, etc.,\n\t it must land outside of the `.ck-editor` in DOM. */\n\tposition: relative;\n\n\t& .ck-editor__top .ck-sticky-panel .ck-toolbar {\n\t\t/* https://github.com/ckeditor/ckeditor5-editor-classic/issues/62 */\n\t\tz-index: var(--ck-z-modal);\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_rounded.css";\n\n.ck.ck-editor__top {\n\t& .ck-sticky-panel {\n\t\t& .ck-toolbar {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\n\t\t\tborder-bottom-width: 0;\n\t\t}\n\n\t\t& .ck-sticky-panel__content_sticky .ck-toolbar {\n\t\t\tborder-bottom-width: 1px;\n\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Note: Use ck-editor__main to make sure these styles don\'t apply to other editor types */\n.ck.ck-editor__main > .ck-editor__editable {\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/113 */\n\tbackground: var(--ck-color-base-background);\n\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&:not(.ck-focused) {\n\t\tborder-color: var(--ck-color-base-border);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#000}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{width:var(--ck-color-grid-tile-size);height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;border:0}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{display:none;color:var(--ck-color-color-grid-check-icon)}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorgrid/colorgrid.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css"],
            names: [],
            mappings: "AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,qCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBACC,oCAAqC,CACrC,qCAAsC,CACtC,wCAAyC,CACzC,yCAA0C,CAC1C,SAAU,CACV,8BAA+B,CAC/B,QAmCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,4DACC,gDACD,CAEA,oCACC,YAAa,CACb,2CACD,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-color-grid {\n\tdisplay: grid;\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-grid-tile-size: 24px;\n\n\t/* Not using global colors here because these may change but some colors in a pallette\n\t * require special treatment. For instance, this ensures no matter what the UI text color is,\n\t * the check icon will look good on the black color tile. */\n\t--ck-color-color-grid-check-icon: hsl(0, 0%, 0%);\n}\n\n.ck.ck-color-grid {\n\tgrid-gap: 5px;\n\tpadding: 8px;\n}\n\n.ck.ck-color-grid__tile {\n\twidth: var(--ck-color-grid-tile-size);\n\theight: var(--ck-color-grid-tile-size);\n\tmin-width: var(--ck-color-grid-tile-size);\n\tmin-height: var(--ck-color-grid-tile-size);\n\tpadding: 0;\n\ttransition: .2s ease box-shadow;\n\tborder: 0;\n\n\t&.ck-disabled {\n\t\tcursor: unset;\n\t\ttransition: unset;\n\t}\n\n\t&.ck-color-table__color-tile_bordered {\n\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\tdisplay: none;\n\t\tcolor: var(--ck-color-color-grid-check-icon);\n\t}\n\n\t&.ck-on {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);\n\n\t\t& .ck.ck-icon {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t&.ck-on,\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\t/* Disable the default .ck-button\'s border ring. */\n\t\tborder: 0;\n\t}\n\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\n\t}\n}\n\n.ck.ck-color-grid__label {\n\tpadding: 0 var(--ck-spacing-standard);\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck .ck-button.ck-color-table__remove-color{display:flex;align-items:center;width:100%}label.ck.ck-color-grid__label{font-weight:unset}.ck .ck-button.ck-color-table__remove-color{padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck .ck-button.ck-color-table__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-base-border)}[dir=ltr] .ck .ck-button.ck-color-table__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck .ck-button.ck-color-table__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard)}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-font/theme/fontcolor.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-font/fontcolor.css"],
            names: [],
            mappings: "AAKA,4CACC,YAAa,CACb,kBAAmB,CACnB,UACD,CAEA,8BACC,iBACD,CCNA,4CACC,qEAAyE,CACzE,2BAA4B,CAC5B,4BAeD,CAbC,wDACC,mDACD,CAEA,kEAEE,uCAMF,CARA,kEAME,sCAEF",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-button.ck-color-table__remove-color {\n\tdisplay: flex;\n\talign-items: center;\n\twidth: 100%;\n}\n\nlabel.ck.ck-color-grid__label {\n\tfont-weight: unset;\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck .ck-button.ck-color-table__remove-color {\n\tpadding: calc(var(--ck-spacing-standard) / 2 ) var(--ck-spacing-standard);\n\tborder-bottom-left-radius: 0;\n\tborder-bottom-right-radius: 0;\n\n\t&:not(:focus) {\n\t\tborder-bottom: 1px solid var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-right: var(--ck-spacing-standard);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n}\n\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{width:0;height:0;border-style:solid}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:var(--ck-balloon-arrow-height);border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:0}.ck.ck-balloon-panel[class*=arrow_n]:before{border-bottom-color:var(--ck-color-panel-border)}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-color:transparent;border-right-color:transparent;border-top-color:transparent}.ck.ck-balloon-panel[class*=arrow_n]:after{border-bottom-color:var(--ck-color-panel-background);margin-top:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:0;border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-top-color:var(--ck-color-panel-border);filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent}.ck.ck-balloon-panel[class*=arrow_s]:after{border-top-color:var(--ck-color-panel-background);margin-bottom:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{right:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{right:25%;margin-right:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{right:25%;margin-right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}', "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonpanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"],
            names: [],
            mappings: "AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCJC,eD4ID,CAxIA,iFCAE,qCDwIF,CAxIA,qBENC,oCAA8B,CFU9B,eAAgB,CAEhB,2CAA4C,CAC5C,6CAiID,CA9HE,+GAEC,OAAQ,CACR,QAAS,CACT,kBACD,CAIA,uFAEC,oDAAoH,CAApH,kDAAoH,CAApH,qDAAoH,CAApH,kBACD,CAEA,4CACC,gDACD,CAEA,uFAHC,6BAA8E,CAA9E,8BAA8E,CAA9E,4BAMD,CAHA,2CACC,oDAAkF,CAClF,yCACD,CAIA,uFAEC,oDAAoH,CAApH,qBAAoH,CAApH,qDAAoH,CAApH,+CACD,CAEA,4CACC,6CAAkE,CAClE,uDACD,CAEA,uFAJC,6BAAkE,CAAlE,+BAAkE,CAAlE,8BAOD,CAHA,2CACC,iDAAkF,CAClF,4CACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,8CACD,CAIA,2GAEC,+CAAkD,CAClD,8CACD,CAIA,2GAEC,gDAAmD,CACnD,8CACD,CAIA,6GAEC,SAAU,CACV,uDAA0D,CAC1D,8CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,8CACD,CAIA,6GAEC,SAAU,CACV,uDAA0D,CAC1D,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* Make sure the balloon arrow does not float over its children. */\n\t--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);\n}\n\n.ck.ck-balloon-panel {\n\tdisplay: none;\n\tposition: absolute;\n\n\tz-index: var(--ck-z-modal);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tposition: absolute;\n\t\t}\n\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_visible {\n\t\tdisplay: block;\n\t}\n}\n', '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-arrow-offset: 2px;\n\t--ck-balloon-arrow-height: 10px;\n\t--ck-balloon-arrow-half-width: 8px;\n\t--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);\n}\n\n.ck.ck-balloon-panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t\tborder-style: solid;\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-border) transparent;\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-background) transparent;\n\t\t\tmargin-top: var(--ck-balloon-arrow-offset);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: var(--ck-color-panel-border) transparent transparent;\n\t\t\tfilter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: var(--ck-color-panel-background) transparent transparent transparent;\n\t\t\tmargin-bottom: var(--ck-balloon-arrow-offset);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_n {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_ne {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_s {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_se {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_smw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nmw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, '.ck .ck-widget .ck-widget__type-around__button{display:block;position:absolute;overflow:hidden;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{position:absolute;top:50%;left:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{top:calc(var(--ck-widget-outline-thickness)*-0.5);left:min(10%,30px);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-0.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;position:absolute;top:1px;left:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;position:absolute;left:0;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{top:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{width:var(--ck-widget-type-around-button-size);height:var(--ck-widget-type-around-button-size);background:var(--ck-color-widget-type-around-button);border-radius:100px;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);opacity:0;pointer-events:none}.ck .ck-widget .ck-widget__type-around__button svg{width:10px;height:8px;transform:translate(-50%,-50%);transition:transform .5s ease;margin-top:1px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{width:calc(var(--ck-widget-type-around-button-size) - 2px);height:calc(var(--ck-widget-type-around-button-size) - 2px);border-radius:100px;background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3))}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{pointer-events:none;height:1px;animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;outline:1px solid hsla(0,0%,100%,.5);background:var(--ck-color-base-text)}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}', "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgettypearound.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css"],
            names: [],
            mappings: "AASC,+CACC,aAAc,CACd,iBAAkB,CAClB,eAAgB,CAChB,2BAwBD,CAtBC,mDACC,iBAAkB,CAClB,OAAQ,CACR,QAAS,CACT,qCACD,CAEA,qFAEC,iDAAoD,CACpD,kBAAoB,CAEpB,0BACD,CAEA,oFAEC,oDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CACd,iBAAkB,CAClB,OAAQ,CACR,QAAS,CACT,qCACD,CAMD,2EACC,YAAa,CACb,iBAAkB,CAClB,MAAO,CACP,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHACC,qDAA0D,CAC1D,aACD,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CACC,8CAA+C,CAC/C,+CAAgD,CAChD,oDAAqD,CACrD,mBAAoB,CACpB,uMAAyM,CAb1M,SAAU,CACV,mBA0DA,CA1CC,mDACC,UAAW,CACX,UAAW,CACX,8BAA+B,CAC/B,6BAA8B,CAC9B,cAgBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLACC,0DAA2D,CAC3D,2DAA4D,CAC5D,mBAAoB,CACpB,uEACD,CAOD,8GACC,gBACD,CAKA,mDACC,mBAAoB,CACpB,UAAW,CACX,mFAAoF,CAMpF,oCAAwC,CACxC,oCACD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CASE,0jBACC,SACD,CASF,mPACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t\toverflow: hidden;\n\t\tz-index: var(--ck-z-default);\n\n\t\t& svg {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\tleft: 50%;\n\t\t\tz-index: calc(var(--ck-z-default) + 2);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_before {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\ttop: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tleft: min(10%, 30px);\n\n\t\t\ttransform: translateY(-50%);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_after {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\tbottom: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tright: min(10%, 30px);\n\n\t\t\ttransform: translateY(50%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tdisplay: block;\n\t\t\tposition: absolute;\n\t\t\ttop: 1px;\n\t\t\tleft: 1px;\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tdisplay: none;\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t}\n\n\t/*\n\t * When the widget is hovered the "fake caret" would normally be narrower than the\n\t * extra outline displayed around the widget. Let\'s extend the "fake caret" to match\n\t * the full width of the widget.\n\t */\n\t&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tleft: calc( -1 * var(--ck-widget-outline-thickness) );\n\t\tright: calc( -1 * var(--ck-widget-outline-thickness) );\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\ttop: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tbottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n}\n\n/*\n * Integration with the read-only mode of the editor.\n */\n.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the restricted editing mode (feature) of the editor.\n */\n.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the #isEnabled property of the WidgetTypeAround plugin.\n */\n.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {\n\tdisplay: none;\n}\n', '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-widget-type-around-button-size: 20px;\n\t--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);\n\t--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);\n\t--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);\n\t--ck-color-widget-type-around-button-radar-start-alpha: 0;\n\t--ck-color-widget-type-around-button-radar-end-alpha: .3;\n\t--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);\n}\n\n@define-mixin ck-widget-type-around-button-visible {\n\topacity: 1;\n\tpointer-events: auto;\n}\n\n@define-mixin ck-widget-type-around-button-hidden {\n\topacity: 0;\n\tpointer-events: none;\n}\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\twidth: var(--ck-widget-type-around-button-size);\n\t\theight: var(--ck-widget-type-around-button-size);\n\t\tbackground: var(--ck-color-widget-type-around-button);\n\t\tborder-radius: 100px;\n\t\ttransition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t@mixin ck-widget-type-around-button-hidden;\n\n\t\t& svg {\n\t\t\twidth: 10px;\n\t\t\theight: 8px;\n\t\t\ttransform: translate(-50%,-50%);\n\t\t\ttransition: transform .5s ease;\n\t\t\tmargin-top: 1px;\n\n\t\t\t& * {\n\t\t\t\tstroke-dasharray: 10;\n\t\t\t\tstroke-dashoffset: 0;\n\n\t\t\t\tfill: none;\n\t\t\t\tstroke: var(--ck-color-widget-type-around-button-icon);\n\t\t\t\tstroke-width: 1.5px;\n\t\t\t\tstroke-linecap: round;\n\t\t\t\tstroke-linejoin: round;\n\t\t\t}\n\n\t\t\t& line {\n\t\t\t\tstroke-dasharray: 7;\n\t\t\t}\n\t\t}\n\n\t\t&:hover {\n\t\t\t/*\n\t\t\t * Display the "sonar" around the button when hovered.\n\t\t\t */\n\t\t\tanimation: ck-widget-type-around-button-sonar 1s ease infinite;\n\n\t\t\t/*\n\t\t\t * Animate active button\'s icon.\n\t\t\t */\n\t\t\t& svg {\n\t\t\t\t& polyline {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-dash 2s linear;\n\t\t\t\t}\n\n\t\t\t\t& line {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-tip-dash 2s linear;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Show type around buttons when the widget gets selected or being hovered.\n\t */\n\t&.ck-widget_selected,\n\t&:hover {\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-visible;\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when the widget is NOT selected (but the buttons are visible\n\t * and still can be hovered).\n\t */\n\t&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\tbackground: var(--ck-color-widget-type-around-button-hover);\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\tbackground: var(--ck-color-widget-type-around-button-active);\n\n\t\t&::after {\n\t\t\twidth: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\theight: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\tborder-radius: 100px;\n\t\t\tbackground: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the "before" button when the widget has a selection handle. Because some space\n\t * is consumed by the handle, the button must be moved slightly to the right to let it breathe.\n\t */\n\t&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {\n\t\tmargin-left: 20px;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& .ck-widget__type-around__fake-caret {\n\t\tpointer-events: none;\n\t\theight: 1px;\n\t\tanimation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;\n\n\t\t/*\n\t\t * The semi-transparent-outline+background combo improves the contrast\n\t\t * when the background underneath the fake caret is dark.\n\t\t */\n\t\toutline: solid 1px hsla(0, 0%, 100%, .5);\n\t\tbackground: var(--ck-color-base-text);\n\t}\n\n\t/*\n\t * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t * Despite the widget being physically selected in the model, its outline should disappear.\n\t */\n\t&.ck-widget_selected {\n\t\t&.ck-widget_type-around_show-fake-caret_before,\n\t\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t\toutline-color: transparent;\n\t\t}\n\t}\n\n\t&.ck-widget_type-around_show-fake-caret_before,\n\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t/*\n\t\t * When the "fake caret" is visible we simulate that the widget is not selected\n\t\t * (despite being physically selected), so the outline color should be for the\n\t\t * unselected widget.\n\t\t */\n\t\t&.ck-widget_selected:hover {\n\t\t\toutline-color: var(--ck-color-widget-hover-border);\n\t\t}\n\n\t\t/*\n\t\t * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t\t * In this state, the type around buttons would collide with the fake carets so they should disappear.\n\t\t */\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the selection handle. When the caret is visible, simply\n\t\t * hide the handle because it intersects with the caret (and does not make much sense anyway).\n\t\t */\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t&.ck-widget_selected,\n\t\t\t&.ck-widget_selected:hover {\n\t\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\t\topacity: 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the resize UI. When the caret is visible, simply\n\t\t * hide the resize UI because it creates too much noise. It can be visible when the user\n\t\t * hovers the widget, though.\n\t\t */\n\t\t&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {\n\t\t\topacity: 0\n\t\t}\n\t}\n}\n\n/*\n * Styles for the "before" button when the widget has a selection handle in an RTL environment.\n * The selection handler is aligned to the right side of the widget so there is no need to create\n * additional space for it next to the "before" button.\n */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {\n\tmargin-left: 0;\n\tmargin-right: 20px;\n}\n\n/*\n * Hide type around buttons when the widget is selected as a child of a selected\n * nested editable (e.g. mulit-cell table selection).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/7263.\n */\n.ck-editor__nested-editable.ck-editor__editable_selected {\n\t& .ck-widget {\n\t\t&.ck-widget_selected,\n\t\t&:hover {\n\t\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).\n */\n.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {\n\tbackground: var(--ck-color-widget-type-around-button-blurred-editable);\n\n\t& svg * {\n\t\tstroke: hsl(0,0%,60%);\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-dash {\n\t0% {\n\t\tstroke-dashoffset: 10;\n\t}\n\t20%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-tip-dash {\n\t0%, 20% {\n\t\tstroke-dashoffset: 7;\n\t}\n\t40%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-button-sonar {\n\t0% {\n\t\tbox-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n\t50% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));\n\t}\n\t100% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n}\n\n@keyframes ck-widget-type-around-fake-caret-pulse {\n\t0% {\n\t\topacity: 1;\n\t}\n\t49% {\n\t\topacity: 1;\n\t}\n\t50% {\n\t\topacity: 0;\n\t}\n\t99% {\n\t\topacity: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t}\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-resizer-size:10px;--ck-resizer-border-width:1px;--ck-resizer-border-radius:2px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-tooltip-offset:10px;--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected .ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover .ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);color:var(--ck-color-resizer-tooltip-text);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);font-size:var(--ck-font-size-tiny);display:block;padding:var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{top:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{top:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-width:var(--ck-widget-outline-thickness);outline-style:solid;outline-color:transparent;transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;background-color:var(--ck-color-widget-editable-focus-background)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{padding:4px;box-sizing:border-box;background-color:transparent;opacity:0;transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;transform:translateY(-100%);left:calc(0px - var(--ck-widget-outline-thickness))}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{width:var(--ck-widget-handler-icon-size);height:var(--ck-widget-handler-icon-size);color:var(--ck-color-widget-drag-handler-icon-color)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover .ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected .ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover .ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-focus-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle .ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widget.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"],
            names: [],
            mappings: "AAKA,MACC,+CAAgD,CAChD,sBAAuB,CACvB,6BAA8B,CAC9B,8BAA+B,CAG/B,yDAAiE,CAEjE,gCAAiC,CACjC,6CAAsD,CACtD,uCACD,CAOA,8DAEC,iBAuBD,CArBC,4EACC,iBAOD,CALC,qFAGC,aACD,CAWD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CACtD,0CAA2C,CAC3C,qDAAsD,CACtD,6CAA8C,CAC9C,kCAAmC,CACnC,aAAc,CACd,+BA4BD,CA1BC,gLAIC,iBACD,CAEA,0CACC,oCAAuC,CACvC,qCACD,CAEA,2CACC,oCAAuC,CACvC,sCACD,CAEA,8CACC,uCAA0C,CAC1C,sCACD,CAEA,6CACC,uCAA0C,CAC1C,qCACD,CC7ED,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eACC,gDAAiD,CACjD,mBAAoB,CACpB,yBAA0B,CAC1B,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGC/BA,YAAa,CACb,2BAA2B,CCF3B,qCAA8B,CFqC7B,iEACD,CAIA,4EACC,WAAY,CACZ,qBAAsB,CAGtB,4BAA6B,CAC7B,SAAU,CAMV,6SAG6F,CAG7F,iEAAkE,CAGlE,2BAA4B,CAC5B,mDAqBD,CAnBC,qFAEC,wCAAyC,CACzC,yCAA0C,CAC1C,oDASD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFACC,SAAU,CACV,oDACD,CAKC,oMACC,SAAU,CACV,6CAMD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-resizer: var(--ck-color-focus-border);\n\t--ck-resizer-size: 10px;\n\t--ck-resizer-border-width: 1px;\n\t--ck-resizer-border-radius: 2px;\n\n\t/* Set the resizer with a 50% offset. */\n\t--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);\n\n\t--ck-resizer-tooltip-offset: 10px;\n\t--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);\n\t--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);\n}\n\n.ck .ck-widget {\n\t/* This is neccessary for type around UI to be positioned properly. */\n\tposition: relative;\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n\n\t& .ck-widget__selection-handle {\n\t\tposition: absolute;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the icon in not a subject to font-size or line-height to avoid\n\t\t\tunnecessary spacing around it. */\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t/* Show the selection handle on mouse hover over the widget. */\n\t&:hover {\n\t\t& .ck-widget__selection-handle {\n\t\t\tvisibility: visible;\n\t\t}\n\t}\n\n\t/* Show the selection handle when the widget is selected. */\n\t&.ck-widget_selected .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n}\n\n.ck .ck-size-view {\n\tbackground: var(--ck-color-resizer-tooltip-background);\n\tcolor: var(--ck-color-resizer-tooltip-text);\n\tborder: 1px solid var(--ck-color-resizer-tooltip-text);\n\tborder-radius: var(--ck-resizer-border-radius);\n\tfont-size: var(--ck-font-size-tiny);\n\tdisplay: block;\n\tpadding: var(--ck-spacing-small);\n\n\t&.ck-orientation-top-left,\n\t&.ck-orientation-top-right,\n\t&.ck-orientation-bottom-right,\n\t&.ck-orientation-bottom-left {\n\t\tposition: absolute;\n\t}\n\n\t&.ck-orientation-top-left {\n\t\ttop: var( --ck-resizer-tooltip-offset );\n\t\tleft: var( --ck-resizer-tooltip-offset );\n\t}\n\n\t&.ck-orientation-top-right {\n\t\ttop: var( --ck-resizer-tooltip-offset );\n\t\tright: var( --ck-resizer-tooltip-offset );\n\t}\n\n\t&.ck-orientation-bottom-right {\n\t\tbottom: var( --ck-resizer-tooltip-offset );\n\t\tright: var( --ck-resizer-tooltip-offset );\n\t}\n\n\t&.ck-orientation-bottom-left {\n\t\tbottom: var( --ck-resizer-tooltip-offset );\n\t\tleft: var( --ck-resizer-tooltip-offset );\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n\n:root {\n\t--ck-widget-outline-thickness: 3px;\n\t--ck-widget-handler-icon-size: 16px;\n\t--ck-widget-handler-animation-duration: 200ms;\n\t--ck-widget-handler-animation-curve: ease;\n\n\t--ck-color-widget-blurred-border: hsl(0, 0%, 87%);\n\t--ck-color-widget-hover-border: hsl(43, 100%, 62%);\n\t--ck-color-widget-editable-focus-background: var(--ck-color-base-background);\n\t--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);\n}\n\n.ck .ck-widget {\n\toutline-width: var(--ck-widget-outline-thickness);\n\toutline-style: solid;\n\toutline-color: transparent;\n\ttransition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);\n\t}\n\n\t&:hover {\n\t\toutline-color: var(--ck-color-widget-hover-border);\n\t}\n}\n\n.ck .ck-editor__nested-editable {\n\tborder: 1px solid transparent;\n\n\t/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.\n\tThese styles show a different border for a blink of an eye, so `:focus` need to have same styles applied. */\n\t&.ck-editor__nested-editable_focused,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\n\t\tbackground-color: var(--ck-color-widget-editable-focus-background);\n\t}\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t& .ck-widget__selection-handle {\n\t\tpadding: 4px;\n\t\tbox-sizing: border-box;\n\n\t\t/* Background and opacity will be animated as the handler shows up or the widget gets selected. */\n\t\tbackground-color: transparent;\n\t\topacity: 0;\n\n\t\t/* Transition:\n\t\t   * background-color for the .ck-widget_selected state change,\n\t\t   * visibility for hiding the handler,\n\t\t   * opacity for the proper look of the icon when the handler disappears. */\n\t\ttransition:\n\t\t\tbackground-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\tvisibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\topacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t/* Make only top corners round. */\n\t\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\n\t\t/* Place the drag handler outside the widget wrapper. */\n\t\ttransform: translateY(-100%);\n\t\tleft: calc(0px - var(--ck-widget-outline-thickness));\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the dimensions of the icon are independent of the fon-size of the content. */\n\t\t\twidth: var(--ck-widget-handler-icon-size);\n\t\t\theight: var(--ck-widget-handler-icon-size);\n\t\t\tcolor: var(--ck-color-widget-drag-handler-icon-color);\n\n\t\t\t/* The "selected" part of the icon is invisible by default */\n\t\t\t& .ck-icon__selected-indicator {\n\t\t\t\topacity: 0;\n\n\t\t\t\t/* Note: The animation is longer on purpose. Simply feels better. */\n\t\t\t\ttransition: opacity 300ms var(--ck-widget-handler-animation-curve);\n\t\t\t}\n\t\t}\n\n\t\t/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */\n\t\t&:hover .ck-icon .ck-icon__selected-indicator {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\n\t/* Show the selection handler on mouse hover over the widget. */\n\t&:hover .ck-widget__selection-handle {\n\t\topacity: 1;\n\t\tbackground-color: var(--ck-color-widget-hover-border);\n\t}\n\n\t/* Show the selection handler when the widget is selected. */\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\t& .ck-widget__selection-handle {\n\t\t\topacity: 1;\n\t\t\tbackground-color: var(--ck-color-focus-border);\n\n\t\t\t/* When the widget is selected, notify the user using the proper look of the icon. */\n\t\t\t& .ck-icon .ck-icon__selected-indicator {\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* In a RTL environment, align the selection handler to the right side of the widget */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {\n\tleft: auto;\n\tright: calc(0px - var(--ck-widget-outline-thickness));\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/6415 */\n.ck.ck-editor__editable.ck-read-only .ck-widget {\n\t/* Prevent the :hover outline from showing up because of the used outline-color transition. */\n\ttransition: none;\n\n\t&:not(.ck-widget_selected) {\n\t\t/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/1261\n\t\t *\n\t\t * Leave the unit because this custom property is used in calc() by other features.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/6775\n\t\t */\n\t\t--ck-widget-outline-thickness: 0px;\n\t}\n\n\t&.ck-widget_with-selection-handle {\n\t\t& .ck-widget__selection-handle,\n\t\t& .ck-widget__selection-handle:hover {\n\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t}\n\t}\n}\n\n/* Style the widget when it\'s selected but the editable it belongs to lost focus. */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck.ck-editor__editable.ck-blurred .ck-widget {\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline-color: var(--ck-color-widget-blurred-border);\n\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t& .ck-widget__selection-handle,\n\t\t\t& .ck-widget__selection-handle:hover {\n\t\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,\n.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {\n\t/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.\n\tIn fact, anything with overflow: hidden.\n\thttps://github.com/ckeditor/ckeditor5-block-quote/issues/28\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/44\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/66 */\n\tmargin-top: calc(1em + var(--ck-widget-handler-icon-size));\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{pointer-events:none;transform-origin:0 0;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);background:var(--ck-color-labeled-field-label-background);padding:0 calc(var(--ck-font-size-tiny)*0.5);line-height:normal;font-weight:400;text-overflow:ellipsis;overflow:hidden;max-width:100%;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-spacing-medium),calc(var(--ck-font-size-base)*0.6)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-spacing-medium)*-1),calc(var(--ck-font-size-base)*0.6)) scale(1)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));background:transparent;padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
            names: [],
            mappings: "AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,yEACD,CAEA,0BCHC,eD4GD,CAzGA,2FCCE,qCDwGF,CAtGC,mEACC,UAmCD,CAjCC,gFACC,KA+BD,CAhCA,0FAIE,MA4BF,CAhCA,0FAQE,OAwBF,CAhCA,gFAWC,mBAAoB,CACpB,oBAAqB,CAGrB,6DAA+D,CAE/D,yDAA0D,CAC1D,4CAA8C,CAC9C,kBAAoB,CACpB,eAAmB,CAGnB,sBAAuB,CACvB,eAAgB,CAEhB,cAAe,CAEf,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,wSAGE,yFAYF,CAfA,wSAOE,kGAQF,CAfA,oRAWC,iEAAkE,CAElE,sBAAuB,CACvB,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-labeled-field-view {\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\tdisplay: flex;\n\t\tposition: relative;\n\t}\n\n\t& .ck.ck-label {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);\n\t--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);\n\t--ck-color-labeled-field-label-background: var(--ck-color-base-background);\n}\n\n.ck.ck-labeled-field-view {\n\t@mixin ck-rounded-corners;\n\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\twidth: 100%;\n\n\t\t& > .ck.ck-label {\n\t\t\ttop: 0px;\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tleft: 0px;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tright: 0px;\n\t\t\t}\n\n\t\t\tpointer-events: none;\n\t\t\ttransform-origin: 0 0;\n\n\t\t\t/* By default, display the label scaled down above the field. */\n\t\t\ttransform: translate(var(--ck-spacing-medium), -6px) scale(.75);\n\n\t\t\tbackground: var(--ck-color-labeled-field-label-background);\n\t\t\tpadding: 0 calc(.5 * var(--ck-font-size-tiny));\n\t\t\tline-height: initial;\n\t\t\tfont-weight: normal;\n\n\t\t\t/* Prevent overflow when the label is longer than the input */\n\t\t\ttext-overflow: ellipsis;\n\t\t\toverflow: hidden;\n\n\t\t\tmax-width: 100%;\n\n\t\t\ttransition:\n\t\t\t\ttransform var(--ck-labeled-field-view-transition),\n\t\t\t\tpadding var(--ck-labeled-field-view-transition),\n\t\t\t\tbackground var(--ck-labeled-field-view-transition);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\t& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\n\t\t& .ck-input:not([readonly]) + .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t& .ck-labeled-field-view__status {\n\t\tfont-size: var(--ck-font-size-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\n\t\t/* Let the info wrap to the next line to avoid stretching the layout horizontally.\n\t\tThe status could be very long. */\n\t\twhite-space: normal;\n\n\t\t&.ck-labeled-field-view__status_error {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t/* Disabled fields and fields that have no focus should fade out. */\n\t&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\tcolor: var(--ck-color-input-disabled-text);\n\t}\n\n\t/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t@mixin ck-dir ltr {\n\t\t\ttransform: translate(var(--ck-spacing-medium), calc(0.6 * var(--ck-font-size-base))) scale(1);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttransform: translate(calc(-1 * var(--ck-spacing-medium)), calc(0.6 * var(--ck-font-size-base))) scale(1);\n\t\t}\n\n\t\t/* Compensate for the default translate position. */\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));\n\n\t\tbackground: transparent;\n\t\tpadding: 0;\n\t}\n\n\t/*------ DropdownView integration ----------------------------------------------------------------------------------- */\n\n\t/* Make sure dropdown\' background color in any of dropdown\'s state does not collide with labeled field. */\n\t& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {\n\t\tbackground: transparent;\n\t}\n\n\t/* When the dropdown is "empty", the labeled field label replaces its label. */\n\t&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {\n\t\topacity: 0;\n\t}\n\n\t/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ":root{--ck-input-text-width:18em}.ck.ck-input-text{border-radius:0}.ck-rounded-corners .ck.ck-input-text,.ck.ck-input-text.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-text{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);min-width:var(--ck-input-text-width);min-height:var(--ck-ui-component-min-height);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input-text:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-input-text[readonly]{border:1px solid var(--ck-color-input-disabled-border);background:var(--ck-color-input-disabled-background);color:var(--ck-color-input-disabled-text)}.ck.ck-input-text[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input-text.ck-error{border-color:var(--ck-color-input-error-border);animation:ck-text-input-shake .3s ease both}.ck.ck-input-text.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-text-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/inputtext/inputtext.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"],
            names: [],
            mappings: "AASA,MACC,0BACD,CAEA,kBCFC,eDwCD,CAtCA,2ECEE,qCDoCF,CAtCA,kBAGC,2CAA4C,CAC5C,6CAA8C,CAC9C,6DAA8D,CAC9D,oCAAqC,CAGrC,4CAA6C,CAG7C,4DA0BD,CAxBC,wBEjBA,YAAa,CACb,2BAA2B,CCF3B,2CHqBA,CAEA,4BACC,sDAAuD,CACvD,oDAAqD,CACrD,yCAMD,CAJC,kCG5BD,oDH+BC,CAGD,2BACC,+CAAgD,CAChD,2CAKD,CAHC,iCGtCD,iDHwCC,CAIF,+BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-input-text-width: 18em;\n}\n\n.ck.ck-input-text {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-input-background);\n\tborder: 1px solid var(--ck-color-input-border);\n\tpadding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);\n\tmin-width: var(--ck-input-text-width);\n\n\t/* This is important to stay of the same height as surrounding buttons */\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .1s ease-in-out, border .1s ease-in-out;\n\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t&[readonly] {\n\t\tborder: 1px solid var(--ck-color-input-disabled-border);\n\t\tbackground: var(--ck-color-input-disabled-background);\n\t\tcolor: var(--ck-color-input-disabled-text);\n\n\t\t&:focus {\n\t\t\t/* The read-only input should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\tborder-color: var(--ck-color-input-error-border);\n\t\tanimation: ck-text-input-shake .3s ease both;\n\n\t\t&:focus {\n\t\t\t@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);\n\t\t}\n\t}\n}\n\n@keyframes ck-text-input-shake {\n\t20% {\n\t\ttransform: translateX(-2px);\n\t}\n\n\t40% {\n\t\ttransform: translateX(2px);\n\t}\n\n\t60% {\n\t\ttransform: translateX(-1px);\n\t}\n\n\t80% {\n\t\ttransform: translateX(1px);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/textalternativeform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"],
            names: [],
            mappings: "AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-text-alternative-form {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, '.ck-vertical-form .ck-button:after{content:"";width:0;position:absolute;right:-1px;top:var(--ck-spacing-small);bottom:var(--ck-spacing-small);z-index:1}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{content:"";width:0;position:absolute;right:-1px;top:var(--ck-spacing-small);bottom:var(--ck-spacing-small);z-index:1}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-text-width)*0.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){padding:var(--ck-spacing-standard);margin-top:var(--ck-spacing-large);border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after,[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}', "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/responsive-form/responsiveform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css"],
            names: [],
            mappings: "AAOA,mCACC,UAAW,CACX,OAAQ,CACR,iBAAkB,CAClB,UAAW,CACX,2BAA4B,CAC5B,8BAA+B,CAC/B,SACD,CCTC,oCDaC,wCACC,UAAW,CACX,OAAQ,CACR,iBAAkB,CAClB,UAAW,CACX,2BAA4B,CAC5B,8BAA+B,CAC/B,SACD,CCnBD,CCAD,qDACC,kDACD,CAEA,uBACC,+BAkED,CAhEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,0CA6CF,CA3CE,8CACC,wDAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAID,iGAEC,kCAAmC,CACnC,kCAAmC,CAEnC,eAAgB,CAChB,QAAS,CACT,gDAaD,CApBA,0OAcE,aAMF,CAGC,yMACC,kDACD,CDpEF",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck-vertical-form .ck-button::after {\n\tcontent: "";\n\twidth: 0;\n\tposition: absolute;\n\tright: -1px;\n\ttop: var(--ck-spacing-small);\n\tbottom: var(--ck-spacing-small);\n\tz-index: 1;\n}\n\n.ck.ck-responsive-form {\n\t@mixin ck-media-phone {\n\t\t& .ck-button::after {\n\t\t\tcontent: "";\n\t\t\twidth: 0;\n\t\t\tposition: absolute;\n\t\t\tright: -1px;\n\t\t\ttop: var(--ck-spacing-small);\n\t\t\tbottom: var(--ck-spacing-small);\n\t\t\tz-index: 1;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck-vertical-form > .ck-button:nth-last-child(2)::after {\n\tborder-right: 1px solid var(--ck-color-base-border);\n}\n\n.ck.ck-responsive-form {\n\tpadding: var(--ck-spacing-large);\n\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& > :not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& > :not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tpadding: 0;\n\t\twidth: calc(.8 * var(--ck-input-text-width));\n\n\t\t& .ck-labeled-field-view {\n\t\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) 0;\n\n\t\t\t& .ck-input-text {\n\t\t\t\tmin-width: 0;\n\t\t\t\twidth: 100%;\n\t\t\t}\n\n\t\t\t/* Let the long error messages wrap in the narrow form. */\n\t\t\t& .ck-labeled-field-view__error {\n\t\t\t\twhite-space: normal;\n\t\t\t}\n\t\t}\n\n\t\t/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */\n\t\t& > .ck-button:nth-last-child(1),\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\tpadding: var(--ck-spacing-standard);\n\t\t\tmargin-top: var(--ck-spacing-large);\n\n\t\t\tborder-radius: 0;\n\t\t\tborder: 0;\n\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\n\t\t\t\t&:last-of-type {\n\t\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\t&::after {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\t}\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck .ck-balloon-rotator__navigation{display:flex;align-items:center;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-small)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonrotator.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css"],
            names: [],
            mappings: "AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCACC,oCAAqC,CACrC,kCAAmC,CACnC,qCACD,CAGA,iEACC,uCAAwC,CAGxC,mCACD,CAMA,2DACC,eACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n/* Buttons inside a toolbar should be centered when rotator bar is wider.\n * See: https://github.com/ckeditor/ckeditor5-ui/issues/495\n */\n.ck .ck-balloon-rotator__content .ck-toolbar {\n\tjustify-content: center;\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tbackground: var(--ck-color-toolbar-background);\n\tborder-bottom: 1px solid var(--ck-color-toolbar-border);\n\tpadding: 0 var(--ck-spacing-small);\n\n\t/* Let's keep similar appearance to `ck-toolbar`. */\n\t& > * {\n\t\tmargin-right: var(--ck-spacing-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t/* Gives counter more breath than buttons. */\n\t& .ck-balloon-rotator__counter {\n\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t/* We need to use smaller margin because of previous button's right margin. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n.ck .ck-balloon-rotator__content {\n\n\t/* Disable default annotation shadow inside rotator with fake panels. */\n\t& .ck.ck-annotation-wrapper {\n\t\tbox-shadow: none;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);width:100%;height:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/fakepanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"],
            names: [],
            mappings: "AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBCJC,oCAA8B,CDO9B,eAAgB,CAEhB,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CAEtC,UAAW,CACX,WACD,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-fake-panel {\n\tposition: absolute;\n\n\t/* Fake panels should be placed under main balloon content. */\n\tz-index: calc(var(--ck-z-modal) - 1);\n}\n\n.ck .ck-fake-panel div {\n\tposition: absolute;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tz-index: 2;\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tz-index: 1;\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-fake-panel-offset-horizontal: 6px;\n\t--ck-balloon-fake-panel-offset-vertical: 6px;\n}\n\n/* Let\'s use `.ck-balloon-panel` appearance. See: balloonpanel.css. */\n.ck .ck-fake-panel div {\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\tborder-radius: var(--ck-border-radius);\n\n\twidth: 100%;\n\theight: 100%;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tmargin-left: var(--ck-balloon-fake-panel-offset-horizontal);\n\tmargin-top: var(--ck-balloon-fake-panel-offset-vertical);\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);\n}\n.ck .ck-fake-panel div:nth-child( 3 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);\n}\n\n/* If balloon is positioned above element, we need to move fake panel to the top. */\n.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {\n\t--ck-balloon-fake-panel-offset-vertical: -6px;\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck-content .image{display:table;clear:both;text-align:center;margin:1em auto}.ck-content .image img{display:block;margin:0 auto;max-width:100%;min-width:50px}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/image.css"],
            names: [],
            mappings: "AAKA,mBACC,aAAc,CACd,UAAW,CACX,iBAAkB,CAGlB,eAeD,CAbC,uBAEC,aAAc,CAGd,aAAc,CAGd,cAAe,CAGf,cACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .image {\n\tdisplay: table;\n\tclear: both;\n\ttext-align: center;\n\n\t/* Make sure there is some space between the content and the image. Center image by default. */\n\tmargin: 1em auto;\n\n\t& img {\n\t\t/* Prevent unnecessary margins caused by line-height (see #44). */\n\t\tdisplay: block;\n\n\t\t/* Center the image if its width is smaller than the content's width. */\n\t\tmargin: 0 auto;\n\n\t\t/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */\n\t\tmax-width: 100%;\n\n\t\t/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */\n\t\tmin-width: 50px;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck.ck-editor__editable .image{position:relative}.ck.ck-editor__editable .image .ck-progress-bar{position:absolute;top:0;left:0}.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar{height:2px;width:0;background:var(--ck-color-upload-bar-background);transition:width .1s}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadprogress.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css"],
            names: [],
            mappings: "AAKA,+BACC,iBACD,CAGA,gDACC,iBAAkB,CAClB,KAAM,CACN,MACD,CCPC,yCACC,oBACD,CAID,gDACC,UAAW,CACX,OAAQ,CACR,gDAAiD,CACjD,oBACD,CAEA,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable .image {\n\tposition: relative;\n}\n\n/* Upload progress bar. */\n.ck.ck-editor__editable .image .ck-progress-bar {\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable .image {\n\t/* Showing animation. */\n\t&.ck-appear {\n\t\tanimation: fadeIn 700ms;\n\t}\n}\n\n/* Upload progress bar. */\n.ck.ck-editor__editable .image .ck-progress-bar {\n\theight: 2px;\n\twidth: 0;\n\tbackground: var(--ck-color-upload-bar-background);\n\ttransition: width 100ms;\n}\n\n@keyframes fadeIn {\n\tfrom { opacity: 0; }\n\tto   { opacity: 1; }\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, '.ck-image-upload-complete-icon{display:block;position:absolute;top:10px;right:10px;border-radius:50%}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20px;--ck-image-upload-icon-width:2px}.ck-image-upload-complete-icon{width:var(--ck-image-upload-icon-size);height:var(--ck-image-upload-icon-size);opacity:0;background:var(--ck-color-image-upload-icon-background);animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;animation-fill-mode:forwards,forwards;animation-duration:.5s,.5s;font-size:var(--ck-image-upload-icon-size);animation-delay:0ms,3s}.ck-image-upload-complete-icon:after{left:25%;top:50%;opacity:0;height:0;width:0;transform:scaleX(-1) rotate(135deg);transform-origin:left top;border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);animation-name:ck-upload-complete-icon-check;animation-duration:.5s;animation-delay:.5s;animation-fill-mode:forwards;box-sizing:border-box}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{opacity:1;width:0;height:0}33%{width:.3em;height:0}to{opacity:1;width:.3em;height:.45em}}', "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadicon.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css"],
            names: [],
            mappings: "AAKA,+BACC,aAAc,CACd,iBAAkB,CAClB,QAAS,CACT,UAAW,CACX,iBAMD,CAJC,qCACC,UAAW,CACX,iBACD,CCVD,MACC,iCAA8C,CAC9C,+CAA4D,CAE5D,gCAAiC,CACjC,gCACD,CAEA,+BACC,sCAAuC,CACvC,uCAAwC,CACxC,SAAU,CACV,uDAAwD,CACxD,wEAA0E,CAC1E,qCAAuC,CACvC,0BAAgC,CAGhC,0CAA2C,CAG3C,sBAyBD,CAtBC,qCAEC,QAAS,CAET,OAAQ,CACR,SAAU,CACV,QAAS,CACT,OAAQ,CAER,mCAAoC,CACpC,yBAA0B,CAC1B,oFAAqF,CACrF,sFAAuF,CAEvF,4CAA6C,CAC7C,sBAAyB,CACzB,mBAAsB,CACtB,4BAA6B,CAG7B,qBACD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GACC,SAAU,CACV,OAAQ,CACR,QACD,CACA,IACC,UAAY,CACZ,QACD,CACA,GACC,SAAU,CACV,UAAY,CACZ,YACD,CACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-image-upload-complete-icon {\n\tdisplay: block;\n\tposition: absolute;\n\ttop: 10px;\n\tright: 10px;\n\tborder-radius: 50%;\n\n\t&::after {\n\t\tcontent: "";\n\t\tposition: absolute;\n\t}\n}\n', '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-image-upload-icon: hsl(0, 0%, 100%);\n\t--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);\n\n\t--ck-image-upload-icon-size: 20px;\n\t--ck-image-upload-icon-width: 2px;\n}\n\n.ck-image-upload-complete-icon {\n\twidth: var(--ck-image-upload-icon-size);\n\theight: var(--ck-image-upload-icon-size);\n\topacity: 0;\n\tbackground: var(--ck-color-image-upload-icon-background);\n\tanimation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;\n\tanimation-fill-mode: forwards, forwards;\n\tanimation-duration: 500ms, 500ms;\n\n\t/* To make animation scalable. */\n\tfont-size: var(--ck-image-upload-icon-size);\n\n\t/* Hide completed upload icon after 3 seconds. */\n\tanimation-delay: 0ms, 3000ms;\n\n\t/* This is check icon element made from border-width mixed with animations. */\n\t&::after {\n\t\t/* Because of border transformation we need to "hard code" left position. */\n\t\tleft: 25%;\n\n\t\ttop: 50%;\n\t\topacity: 0;\n\t\theight: 0;\n\t\twidth: 0;\n\n\t\ttransform: scaleX(-1) rotate(135deg);\n\t\ttransform-origin: left top;\n\t\tborder-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\t\tborder-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\n\t\tanimation-name: ck-upload-complete-icon-check;\n\t\tanimation-duration: 500ms;\n\t\tanimation-delay: 500ms;\n\t\tanimation-fill-mode: forwards;\n\n\t\t/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */\n\t\tbox-sizing: border-box;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-show {\n\tfrom {\n\t\topacity: 0;\n\t}\n\n\tto {\n\t\topacity: 1;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-hide {\n\tfrom {\n\t\topacity: 1;\n\t}\n\n\tto {\n\t\topacity: 0;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-check {\n\t0% {\n\t\topacity: 1;\n\t\twidth: 0;\n\t\theight: 0;\n\t}\n\t33% {\n\t\twidth: 0.3em;\n\t\theight: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t\twidth: 0.3em;\n\t\theight: 0.45em;\n\t}\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, '.ck .ck-upload-placeholder-loader{position:absolute;display:flex;align-items:center;justify-content:center;top:0;left:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px}.ck .ck-image-upload-placeholder{width:100%;margin:0}.ck .ck-upload-placeholder-loader{width:100%;height:100%}.ck .ck-upload-placeholder-loader:before{width:var(--ck-upload-placeholder-loader-size);height:var(--ck-upload-placeholder-loader-size);border-radius:50%;border-top:3px solid var(--ck-color-upload-placeholder-loader);border-right:2px solid transparent;animation:ck-upload-placeholder-loader 1s linear infinite}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}', "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadloader.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css"],
            names: [],
            mappings: "AAKA,kCACC,iBAAkB,CAClB,YAAa,CACb,kBAAmB,CACnB,sBAAuB,CACvB,KAAM,CACN,MAMD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCACD,CAEA,iCAEC,UAAW,CACX,QACD,CAEA,kCACC,UAAW,CACX,WAUD,CARC,yCACC,8CAA+C,CAC/C,+CAAgD,CAChD,iBAAkB,CAClB,8DAA+D,CAC/D,kCAAmC,CACnC,yDACD,CAGD,wCACC,GACC,uBACD,CACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-upload-placeholder-loader {\n\tposition: absolute;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\ttop: 0;\n\tleft: 0;\n\n\t&::before {\n\t\tcontent: '';\n\t\tposition: relative;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);\n\t--ck-upload-placeholder-loader-size: 32px;\n}\n\n.ck .ck-image-upload-placeholder {\n\t/* We need to control the full width of the SVG gray background. */\n\twidth: 100%;\n\tmargin: 0;\n}\n\n.ck .ck-upload-placeholder-loader {\n\twidth: 100%;\n\theight: 100%;\n\n\t&::before {\n\t\twidth: var(--ck-upload-placeholder-loader-size);\n\t\theight: var(--ck-upload-placeholder-loader-size);\n\t\tborder-radius: 50%;\n\t\tborder-top: 3px solid var(--ck-color-upload-placeholder-loader);\n\t\tborder-right: 2px solid transparent;\n\t\tanimation: ck-upload-placeholder-loader 1s linear infinite;\n\t}\n}\n\n@keyframes ck-upload-placeholder-loader {\n\tto {\n\t\ttransform: rotate( 360deg );\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{height:100%;border-right:1px solid var(--ck-color-base-text);margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/link.css"],
            names: [],
            mappings: "AAMA,sBACC,mDACD,CAMA,4BACC,8CACD,CAGA,sCACC,WAAY,CACZ,gDAAiD,CACjD,iBAAkB,CAClB,oCACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Class added to span element surrounding currently selected link. */\n.ck .ck-link_selected {\n\tbackground: var(--ck-color-link-selected-background);\n}\n\n/*\n * Classes used by the "fake visual selection" displayed in the content when an input\n * in the link UI has focus (the browser does not render the native selection in this state).\n */\n.ck .ck-fake-link-selection {\n\tbackground: var(--ck-color-link-fake-selection);\n}\n\n/* A collapsed fake visual selection. */\n.ck .ck-fake-link-selection_collapsed {\n\theight: 100%;\n\tborder-right: 1px solid var(--ck-color-base-text);\n\tmargin-right: -1px;\n\toutline: solid 1px hsla(0, 0%, 100%, .5);\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{padding:0;min-width:var(--ck-input-text-width)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical .ck-button{padding:var(--ck-spacing-standard);margin:0;border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border);width:50%}[dir=ltr] .ck.ck-link-form_layout-vertical .ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical .ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical .ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{border:0;padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css"],
            names: [],
            mappings: "AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAYD,CALE,wHAEC,mCACD,CE/BF,iCACC,SAAU,CACV,oCA8CD,CA5CC,wDACC,8EAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CACC,kCAAmC,CACnC,QAAS,CACT,eAAgB,CAChB,QAAS,CACT,gDAAiD,CACjD,SAaD,CAnBA,4GAaE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,yDAWD,CATC,wEACC,QAAS,CACT,SAAU,CACV,UAKD,CAHC,8EACC,eACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-form {\n\tdisplay: flex;\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tdisplay: block;\n\n\t/*\n\t * Whether the form is in the responsive mode or not, if there are decorator buttons\n\t * keep the top margin of action buttons medium.\n\t */\n\t& .ck-button {\n\t\t&.ck-button-save,\n\t\t&.ck-button-cancel {\n\t\t\tmargin-top: var(--ck-spacing-medium);\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tpadding: 0;\n\tmin-width: var(--ck-input-text-width);\n\n\t& .ck-labeled-field-view {\n\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small);\n\n\t\t& .ck-input-text {\n\t\t\tmin-width: 0;\n\t\t\twidth: 100%;\n\t\t}\n\t}\n\n\t& .ck-button {\n\t\tpadding: var(--ck-spacing-standard);\n\t\tmargin: 0;\n\t\tborder-radius: 0;\n\t\tborder: 0;\n\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\twidth: 50%;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: 0;\n\n\t\t\t&:last-of-type {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Using additional `.ck` class for stronger CSS specificity than `.ck.ck-link-form > :not(:first-child)`. */\n\t& .ck.ck-list {\n\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-large);\n\n\t\t& .ck-button.ck-switchbutton {\n\t\t\tborder: 0;\n\t\t\tpadding: 0;\n\t\t\twidth: 100%;\n\n\t\t\t&:hover {\n\t\t\t\tbackground: none;\n\t\t\t}\n\t\t}\n\t}\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{padding:0 var(--ck-spacing-medium);color:var(--ck-color-link-default);text-overflow:ellipsis;cursor:pointer;max-width:var(--ck-input-text-width);min-width:3em;text-align:center}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{min-width:0;max-width:100%}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkactions.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css"],
            names: [],
            mappings: "AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCKA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EACC,kCAAmC,CACnC,kCAAmC,CACnC,sBAAuB,CACvB,cAAe,CAIf,oCAAqC,CACrC,aAAc,CACd,iBAKD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDvDD,oCC2DC,wDACC,8DAMD,CAJC,0EACC,WAAY,CACZ,cACD,CAGD,gJAME,aAEF,CD1ED",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-link-actions__preview {\n\t\tdisplay: inline-block;\n\n\t\t& .ck-button__label {\n\t\t\toverflow: hidden;\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-link-actions__preview {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\t& .ck-button.ck-link-actions__preview {\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\n\t\t& .ck-button__label {\n\t\t\tpadding: 0 var(--ck-spacing-medium);\n\t\t\tcolor: var(--ck-color-link-default);\n\t\t\ttext-overflow: ellipsis;\n\t\t\tcursor: pointer;\n\n\t\t\t/* Match the box model of the link editor form\'s input so the balloon\n\t\t\tdoes not change width when moving between actions and the form. */\n\t\t\tmax-width: var(--ck-input-text-width);\n\t\t\tmin-width: 3em;\n\t\t\ttext-align: center;\n\n\t\t\t&:hover {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\n\t\t&,\n\t\t&:hover,\n\t\t&:focus,\n\t\t&:active {\n\t\t\tbackground: none;\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&:focus {\n\t\t\t& .ck-button__label {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-button:not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-button:not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\t& .ck-button.ck-link-actions__preview {\n\t\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;\n\n\t\t\t& .ck-button__label {\n\t\t\t\tmin-width: 0;\n\t\t\t\tmax-width: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button .ck-tooltip{display:none}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__action{border-top-right-radius:unset;border-bottom-right-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__action{border-top-left-radius:unset;border-bottom-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-radius:0}.ck-rounded-corners [dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow,[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:unset;border-bottom-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-top-right-radius:unset;border-bottom-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled){border-left-color:var(--ck-color-split-button-hover-border)}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled){border-right-color:var(--ck-color-split-button-hover-border)}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/splitbutton.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
            names: [],
            mappings: "AAOA,mBAEC,iBAUD,CARC,iDACC,qCACD,CC0BA,8DACC,YACD,CClCD,MACC,gDAAyD,CACzD,4CACD,CAMC,qDAGE,6BAA8B,CAC9B,gCAQF,CAZA,qDASE,4BAA6B,CAC7B,+BAEF,CAEA,0CAGC,eAmBD,CAtBA,oDCnBA,eDyCA,CAtBA,+ICfC,qCAAsC,CDuBpC,4BAA6B,CAC7B,+BAaH,CAtBA,oDAeE,6BAA8B,CAC9B,gCAMF,CAHC,8CACC,mCACD,CASA,0KACC,wDACD,CAGC,sKACC,2DACD,CAIA,sKACC,4DACD,CAMF,uCCpEA,eD8EA,CAVA,qHChEC,qCD0ED,CARE,qKACC,2BACD,CAEA,mKACC,4BACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../tooltip/mixins/_tooltip.css";\n\n.ck.ck-splitbutton {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-splitbutton__action:focus {\n\t\tz-index: calc(var(--ck-z-default) + 1);\n\t}\n\n\t/* Disable tooltips for the buttons when the button is "open" */\n\t&.ck-splitbutton_open > .ck-button {\n\t\t@mixin ck-tooltip_disabled;\n\t}\n}\n\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Enables the tooltip, which is the tooltip is in DOM but\n * not yet displayed.\n */\n@define-mixin ck-tooltip_enabled {\n\t& .ck-tooltip {\n\t\tdisplay: block;\n\n\t\t/*\n\t\t * Don't display tooltips in devices which don't support :hover.\n\t\t * In fact, it's all about iOS, which forces user to click UI elements twice to execute\n\t\t * the primary action, when tooltips are enabled.\n\t\t *\n\t\t * Q: OK, but why not the following query?\n\t\t *\n\t\t *   @media (hover) {\n\t\t *       display: block;\n\t\t *   }\n\t\t *\n\t\t * A: Because FF does not support it and it would completely disable tooltips\n\t\t * in that browser.\n\t\t *\n\t\t * More in https://github.com/ckeditor/ckeditor5/issues/920.\n\t\t */\n\t\t@media (hover:none) {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/**\n * Disables the tooltip making it disappear from DOM.\n */\n@define-mixin ck-tooltip_disabled {\n\t& .ck-tooltip {\n\t\tdisplay: none;\n\t}\n}\n\n/**\n * Shows the tooltip, which is already in DOM.\n * Requires `ck-tooltip_enabled` first.\n */\n@define-mixin ck-tooltip_visible {\n\t& .ck-tooltip {\n\t\tvisibility: visible;\n\t\topacity: 1;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-split-button-hover-background: hsl(0, 0%, 92%);\n\t--ck-color-split-button-hover-border: hsl(0, 0%, 70%);\n}\n\n.ck.ck-splitbutton {\n\t/*\n\t * Note: ck-rounded and ck-dir mixins don\'t go together (because they both use @nest).\n\t */\n\t& > .ck-splitbutton__action {\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the action button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the action button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\t}\n\n\t& > .ck-splitbutton__arrow {\n\t\t/* It\'s a text-less button and since the icon is positioned absolutely in such situation,\n\t\tit must get some arbitrary min-width. */\n\t\tmin-width: unset;\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the arrow button on the left side */\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: unset;\n\t\t\t\tborder-bottom-left-radius: unset;\n\t\t\t}\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the arrow button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t& svg {\n\t\t\twidth: var(--ck-dropdown-arrow-size);\n\t\t}\n\t}\n\n\t/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling\n\tas a whole. The background of both buttons should stand out and there should be a visual\n\tseparation between both buttons. */\n\t&.ck-splitbutton_open,\n\t&:hover {\n\t\t/* When the split button hovered as a whole, not as individual buttons. */\n\t\t& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {\n\t\t\tbackground: var(--ck-color-split-button-hover-background);\n\t\t}\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled) {\n\t\t\t\tborder-left-color: var(--ck-color-split-button-hover-border);\n\t\t\t}\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled) {\n\t\t\t\tborder-right-color: var(--ck-color-split-button-hover-border);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Don\'t round the bottom left and right corners of the buttons when "open"\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-splitbutton_open {\n\t\t@mixin ck-rounded-corners {\n\t\t\t& > .ck-splitbutton__action {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t}\n\n\t\t\t& > .ck-splitbutton__arrow {\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck.ck-list-styles-dropdown>.ck-dropdown__panel>.ck-toolbar>.ck-toolbar__items{display:grid}:root{--ck-list-style-button-size:44px}.ck.ck-list-styles-dropdown>.ck-dropdown__panel>.ck-toolbar{background:none;padding:0}.ck.ck-list-styles-dropdown>.ck-dropdown__panel>.ck-toolbar>.ck-toolbar__items{grid-template-columns:repeat(3,auto);row-gap:var(--ck-spacing-medium);column-gap:var(--ck-spacing-medium);padding:var(--ck-spacing-medium)}.ck.ck-list-styles-dropdown>.ck-dropdown__panel>.ck-toolbar>.ck-toolbar__items .ck-button{width:var(--ck-list-style-button-size);height:var(--ck-list-style-button-size);padding:0;margin:0;box-sizing:content-box}.ck.ck-list-styles-dropdown>.ck-dropdown__panel>.ck-toolbar>.ck-toolbar__items .ck-button .ck-icon{width:var(--ck-list-style-button-size);height:var(--ck-list-style-button-size)}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-list/theme/liststyles.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-list/liststyles.css"],
            names: [],
            mappings: "AAKA,+EAKC,YACD,CCNA,MACC,gCACD,CAEA,4DACC,eAAgB,CAChB,SAiCD,CA/BC,+EACC,oCAAwC,CACxC,gCAAiC,CACjC,mCAAoC,CACpC,gCA0BD,CAxBC,0FAEC,sCAAuC,CACvC,uCAAwC,CACxC,SAAU,CAMV,QAAS,CAOT,sBAMD,CAJC,mGACC,sCAAuC,CACvC,uCACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-list-styles-dropdown > .ck-dropdown__panel > .ck-toolbar > .ck-toolbar__items {\n\t/*\n\t * Use the benefits of the toolbar (e.g. out-of-the-box keyboard navigation) but make it look\n\t * like a panel with thumbnails (previews).\n\t */\n\tdisplay: grid;\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-list-style-button-size: 44px;\n}\n\n.ck.ck-list-styles-dropdown > .ck-dropdown__panel > .ck-toolbar {\n\tbackground: none;\n\tpadding: 0;\n\n\t& > .ck-toolbar__items {\n\t\tgrid-template-columns: repeat( 3, auto );\n\t\trow-gap: var(--ck-spacing-medium);\n\t\tcolumn-gap: var(--ck-spacing-medium);\n\t\tpadding: var(--ck-spacing-medium);\n\n\t\t& .ck-button {\n\t\t\t/* Make the button look like a thumbnail (the icon "takes it all"). */\n\t\t\twidth: var(--ck-list-style-button-size);\n\t\t\theight: var(--ck-list-style-button-size);\n\t\t\tpadding: 0;\n\n\t\t\t/*\n\t\t\t * Buttons are aligned by the grid so disable default button margins to not collide with the\n\t\t\t * gaps in the grid.\n\t\t\t */\n\t\t\tmargin: 0;\n\n\t\t\t/*\n\t\t\t * Make sure the button border (which is displayed on focus, BTW) does not steal pixels\n\t\t\t * from the button dimensions and, as a result, decrease the size of the icon\n\t\t\t * (which becomes blurry as it scales down).\n\t\t\t */\n\t\t\tbox-sizing: content-box;\n\n\t\t\t& .ck-icon {\n\t\t\t\twidth: var(--ck-list-style-button-size);\n\t\t\t\theight: var(--ck-list-style-button-size);\n\t\t\t}\n\t\t}\n\t}\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, '.ck-media__wrapper .ck-media__placeholder{display:flex;flex-direction:column;align-items:center}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-tooltip{display:block}@media (hover:none){.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-tooltip{display:none}}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url{max-width:100%;position:relative}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url:hover .ck-tooltip{visibility:visible;opacity:1}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-media__placeholder__url__text{overflow:hidden;display:block}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck-media__placeholder__icon *{display:none}.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper>:not(.ck-media__placeholder),.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder{pointer-events:none}:root{--ck-media-embed-placeholder-icon-size:3em;--ck-color-media-embed-placeholder-url-text:#757575;--ck-color-media-embed-placeholder-url-text-hover:var(--ck-color-base-text)}.ck-media__wrapper{margin:0 auto}.ck-media__wrapper .ck-media__placeholder{padding:calc(var(--ck-spacing-standard)*3);background:var(--ck-color-base-foreground)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon{min-width:var(--ck-media-embed-placeholder-icon-size);height:var(--ck-media-embed-placeholder-icon-size);margin-bottom:var(--ck-spacing-large);background-position:50%;background-size:cover}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon .ck-icon{width:100%;height:100%}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text{color:var(--ck-color-media-embed-placeholder-url-text);white-space:nowrap;text-align:center;font-style:italic;text-overflow:ellipsis}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:var(--ck-color-media-embed-placeholder-url-text-hover);cursor:pointer;text-decoration:underline}.ck-media__wrapper[data-oembed-url*="open.spotify.com"]{max-width:300px;max-height:380px}.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0yMDYuNDc3IDI2MC45bC0yOC45ODcgMjguOTg3YTUuMjE4IDUuMjE4IDAgMDAzLjc4IDEuNjFoNDkuNjIxYzEuNjk0IDAgMy4xOS0uNzk4IDQuMTQ2LTIuMDM3eiIgZmlsbD0iIzVjODhjNSIvPjxwYXRoIGQ9Ik0yMjYuNzQyIDIyMi45ODhjLTkuMjY2IDAtMTYuNzc3IDcuMTctMTYuNzc3IDE2LjAxNC4wMDcgMi43NjIuNjYzIDUuNDc0IDIuMDkzIDcuODc1LjQzLjcwMy44MyAxLjQwOCAxLjE5IDIuMTA3LjMzMy41MDIuNjUgMS4wMDUuOTUgMS41MDguMzQzLjQ3Ny42NzMuOTU3Ljk4OCAxLjQ0IDEuMzEgMS43NjkgMi41IDMuNTAyIDMuNjM3IDUuMTY4Ljc5MyAxLjI3NSAxLjY4MyAyLjY0IDIuNDY2IDMuOTkgMi4zNjMgNC4wOTQgNC4wMDcgOC4wOTIgNC42IDEzLjkxNHYuMDEyYy4xODIuNDEyLjUxNi42NjYuODc5LjY2Ny40MDMtLjAwMS43NjgtLjMxNC45My0uNzk5LjYwMy01Ljc1NiAyLjIzOC05LjcyOSA0LjU4NS0xMy43OTQuNzgyLTEuMzUgMS42NzMtMi43MTUgMi40NjUtMy45OSAxLjEzNy0xLjY2NiAyLjMyOC0zLjQgMy42MzgtNS4xNjkuMzE1LS40ODIuNjQ1LS45NjIuOTg4LTEuNDM5LjMtLjUwMy42MTctMS4wMDYuOTUtMS41MDguMzU5LS43Ljc2LTEuNDA0IDEuMTktMi4xMDcgMS40MjYtMi40MDIgMi01LjExNCAyLjAwNC03Ljg3NSAwLTguODQ0LTcuNTExLTE2LjAxNC0xNi43NzYtMTYuMDE0eiIgZmlsbD0iI2RkNGIzZSIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48ZWxsaXBzZSByeT0iNS41NjQiIHJ4PSI1LjgyOCIgY3k9IjIzOS4wMDIiIGN4PSIyMjYuNzQyIiBmaWxsPSIjODAyZDI3IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0xOTAuMzAxIDIzNy4yODNjLTQuNjcgMC04LjQ1NyAzLjg1My04LjQ1NyA4LjYwNnMzLjc4NiA4LjYwNyA4LjQ1NyA4LjYwN2MzLjA0MyAwIDQuODA2LS45NTggNi4zMzctMi41MTYgMS41My0xLjU1NyAyLjA4Ny0zLjkxMyAyLjA4Ny02LjI5IDAtLjM2Mi0uMDIzLS43MjItLjA2NC0xLjA3OWgtOC4yNTd2My4wNDNoNC44NWMtLjE5Ny43NTktLjUzMSAxLjQ1LTEuMDU4IDEuOTg2LS45NDIuOTU4LTIuMDI4IDEuNTQ4LTMuOTAxIDEuNTQ4LTIuODc2IDAtNS4yMDgtMi4zNzItNS4yMDgtNS4yOTkgMC0yLjkyNiAyLjMzMi01LjI5OSA1LjIwOC01LjI5OSAxLjM5OSAwIDIuNjE4LjQwNyAzLjU4NCAxLjI5M2wyLjM4MS0yLjM4YzAtLjAwMi0uMDAzLS4wMDQtLjAwNC0uMDA1LTEuNTg4LTEuNTI0LTMuNjItMi4yMTUtNS45NTUtMi4yMTV6bTQuNDMgNS42NmwuMDAzLjAwNnYtLjAwM3oiIGZpbGw9IiNmZmYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTIxNS4xODQgMjUxLjkyOWwtNy45OCA3Ljk3OSAyOC40NzcgMjguNDc1YTUuMjMzIDUuMjMzIDAgMDAuNDQ5LTIuMTIzdi0zMS4xNjVjLS40NjkuNjc1LS45MzQgMS4zNDktMS4zODIgMi4wMDUtLjc5MiAxLjI3NS0xLjY4MiAyLjY0LTIuNDY1IDMuOTktMi4zNDcgNC4wNjUtMy45ODIgOC4wMzgtNC41ODUgMTMuNzk0LS4xNjIuNDg1LS41MjcuNzk4LS45My43OTktLjM2My0uMDAxLS42OTctLjI1NS0uODc5LS42Njd2LS4wMTJjLS41OTMtNS44MjItMi4yMzctOS44Mi00LjYtMTMuOTE0LS43ODMtMS4zNS0xLjY3My0yLjcxNS0yLjQ2Ni0zLjk5LTEuMTM3LTEuNjY2LTIuMzI3LTMuNC0zLjYzNy01LjE2OWwtLjAwMi0uMDAzeiIgZmlsbD0iI2MzYzNjMyIvPjxwYXRoIGQ9Ik0yMTIuOTgzIDI0OC40OTVsLTM2Ljk1MiAzNi45NTN2LjgxMmE1LjIyNyA1LjIyNyAwIDAwNS4yMzggNS4yMzhoMS4wMTVsMzUuNjY2LTM1LjY2NmExMzYuMjc1IDEzNi4yNzUgMCAwMC0yLjc2NC0zLjkgMzcuNTc1IDM3LjU3NSAwIDAwLS45ODktMS40NCAzNS4xMjcgMzUuMTI3IDAgMDAtLjk1LTEuNTA4Yy0uMDgzLS4xNjItLjE3Ni0uMzI2LS4yNjQtLjQ4OXoiIGZpbGw9IiNmZGRjNGYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTIxMS45OTggMjYxLjA4M2wtNi4xNTIgNi4xNTEgMjQuMjY0IDI0LjI2NGguNzgxYTUuMjI3IDUuMjI3IDAgMDA1LjIzOS01LjIzOHYtMS4wNDV6IiBmaWxsPSIjZmZmIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjwvZz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder{background:#4268b3}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik05NjcuNDg0IDBINTYuNTE3QzI1LjMwNCAwIDAgMjUuMzA0IDAgNTYuNTE3djkxMC45NjZDMCA5OTguNjk0IDI1LjI5NyAxMDI0IDU2LjUyMiAxMDI0SDU0N1Y2MjhINDE0VjQ3M2gxMzNWMzU5LjAyOWMwLTEzMi4yNjIgODAuNzczLTIwNC4yODIgMTk4Ljc1Ni0yMDQuMjgyIDU2LjUxMyAwIDEwNS4wODYgNC4yMDggMTE5LjI0NCA2LjA4OVYyOTlsLTgxLjYxNi4wMzdjLTYzLjk5MyAwLTc2LjM4NCAzMC40OTItNzYuMzg0IDc1LjIzNlY0NzNoMTUzLjQ4N2wtMTkuOTg2IDE1NUg3MDd2Mzk2aDI2MC40ODRjMzEuMjEzIDAgNTYuNTE2LTI1LjMwMyA1Ni41MTYtNTYuNTE2VjU2LjUxNUMxMDI0IDI1LjMwMyA5OTguNjk3IDAgOTY3LjQ4NCAwIiBmaWxsPSIjRkZGRkZFIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#cdf}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder{background:linear-gradient(-135deg,#1400c7,#b800b1,#f50000)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTA0IiBoZWlnaHQ9IjUwNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIC4xNTloNTAzLjg0MVY1MDMuOTRIMHoiLz48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48bWFzayBpZD0iYiIgZmlsbD0iI2ZmZiI+PHVzZSB4bGluazpocmVmPSIjYSIvPjwvbWFzaz48cGF0aCBkPSJNMjUxLjkyMS4xNTljLTY4LjQxOCAwLTc2Ljk5Ny4yOS0xMDMuODY3IDEuNTE2LTI2LjgxNCAxLjIyMy00NS4xMjcgNS40ODItNjEuMTUxIDExLjcxLTE2LjU2NiA2LjQzNy0zMC42MTUgMTUuMDUxLTQ0LjYyMSAyOS4wNTYtMTQuMDA1IDE0LjAwNi0yMi42MTkgMjguMDU1LTI5LjA1NiA0NC42MjEtNi4yMjggMTYuMDI0LTEwLjQ4NyAzNC4zMzctMTEuNzEgNjEuMTUxQy4yOSAxNzUuMDgzIDAgMTgzLjY2MiAwIDI1Mi4wOGMwIDY4LjQxNy4yOSA3Ni45OTYgMS41MTYgMTAzLjg2NiAxLjIyMyAyNi44MTQgNS40ODIgNDUuMTI3IDExLjcxIDYxLjE1MSA2LjQzNyAxNi41NjYgMTUuMDUxIDMwLjYxNSAyOS4wNTYgNDQuNjIxIDE0LjAwNiAxNC4wMDUgMjguMDU1IDIyLjYxOSA0NC42MjEgMjkuMDU3IDE2LjAyNCA2LjIyNyAzNC4zMzcgMTAuNDg2IDYxLjE1MSAxMS43MDkgMjYuODcgMS4yMjYgMzUuNDQ5IDEuNTE2IDEwMy44NjcgMS41MTYgNjguNDE3IDAgNzYuOTk2LS4yOSAxMDMuODY2LTEuNTE2IDI2LjgxNC0xLjIyMyA0NS4xMjctNS40ODIgNjEuMTUxLTExLjcwOSAxNi41NjYtNi40MzggMzAuNjE1LTE1LjA1MiA0NC42MjEtMjkuMDU3IDE0LjAwNS0xNC4wMDYgMjIuNjE5LTI4LjA1NSAyOS4wNTctNDQuNjIxIDYuMjI3LTE2LjAyNCAxMC40ODYtMzQuMzM3IDExLjcwOS02MS4xNTEgMS4yMjYtMjYuODcgMS41MTYtMzUuNDQ5IDEuNTE2LTEwMy44NjYgMC02OC40MTgtLjI5LTc2Ljk5Ny0xLjUxNi0xMDMuODY3LTEuMjIzLTI2LjgxNC01LjQ4Mi00NS4xMjctMTEuNzA5LTYxLjE1MS02LjQzOC0xNi41NjYtMTUuMDUyLTMwLjYxNS0yOS4wNTctNDQuNjIxLTE0LjAwNi0xNC4wMDUtMjguMDU1LTIyLjYxOS00NC42MjEtMjkuMDU2LTE2LjAyNC02LjIyOC0zNC4zMzctMTAuNDg3LTYxLjE1MS0xMS43MUMzMjguOTE3LjQ0OSAzMjAuMzM4LjE1OSAyNTEuOTIxLjE1OXptMCA0NS4zOTFjNjcuMjY1IDAgNzUuMjMzLjI1NyAxMDEuNzk3IDEuNDY5IDI0LjU2MiAxLjEyIDM3LjkwMSA1LjIyNCA0Ni43NzggOC42NzQgMTEuNzU5IDQuNTcgMjAuMTUxIDEwLjAyOSAyOC45NjYgMTguODQ1IDguODE2IDguODE1IDE0LjI3NSAxNy4yMDcgMTguODQ1IDI4Ljk2NiAzLjQ1IDguODc3IDcuNTU0IDIyLjIxNiA4LjY3NCA0Ni43NzggMS4yMTIgMjYuNTY0IDEuNDY5IDM0LjUzMiAxLjQ2OSAxMDEuNzk4IDAgNjcuMjY1LS4yNTcgNzUuMjMzLTEuNDY5IDEwMS43OTctMS4xMiAyNC41NjItNS4yMjQgMzcuOTAxLTguNjc0IDQ2Ljc3OC00LjU3IDExLjc1OS0xMC4wMjkgMjAuMTUxLTE4Ljg0NSAyOC45NjYtOC44MTUgOC44MTYtMTcuMjA3IDE0LjI3NS0yOC45NjYgMTguODQ1LTguODc3IDMuNDUtMjIuMjE2IDcuNTU0LTQ2Ljc3OCA4LjY3NC0yNi41NiAxLjIxMi0zNC41MjcgMS40NjktMTAxLjc5NyAxLjQ2OS02Ny4yNzEgMC03NS4yMzctLjI1Ny0xMDEuNzk4LTEuNDY5LTI0LjU2Mi0xLjEyLTM3LjkwMS01LjIyNC00Ni43NzgtOC42NzQtMTEuNzU5LTQuNTctMjAuMTUxLTEwLjAyOS0yOC45NjYtMTguODQ1LTguODE1LTguODE1LTE0LjI3NS0xNy4yMDctMTguODQ1LTI4Ljk2Ni0zLjQ1LTguODc3LTcuNTU0LTIyLjIxNi04LjY3NC00Ni43NzgtMS4yMTItMjYuNTY0LTEuNDY5LTM0LjUzMi0xLjQ2OS0xMDEuNzk3IDAtNjcuMjY2LjI1Ny03NS4yMzQgMS40NjktMTAxLjc5OCAxLjEyLTI0LjU2MiA1LjIyNC0zNy45MDEgOC42NzQtNDYuNzc4IDQuNTctMTEuNzU5IDEwLjAyOS0yMC4xNTEgMTguODQ1LTI4Ljk2NiA4LjgxNS04LjgxNiAxNy4yMDctMTQuMjc1IDI4Ljk2Ni0xOC44NDUgOC44NzctMy40NSAyMi4yMTYtNy41NTQgNDYuNzc4LTguNjc0IDI2LjU2NC0xLjIxMiAzNC41MzItMS40NjkgMTAxLjc5OC0xLjQ2OXoiIGZpbGw9IiNGRkYiIG1hc2s9InVybCgjYikiLz48cGF0aCBkPSJNMjUxLjkyMSAzMzYuMDUzYy00Ni4zNzggMC04My45NzQtMzcuNTk2LTgzLjk3NC04My45NzMgMC00Ni4zNzggMzcuNTk2LTgzLjk3NCA4My45NzQtODMuOTc0IDQ2LjM3NyAwIDgzLjk3MyAzNy41OTYgODMuOTczIDgzLjk3NCAwIDQ2LjM3Ny0zNy41OTYgODMuOTczLTgzLjk3MyA4My45NzN6bTAtMjEzLjMzOGMtNzEuNDQ3IDAtMTI5LjM2NSA1Ny45MTgtMTI5LjM2NSAxMjkuMzY1IDAgNzEuNDQ2IDU3LjkxOCAxMjkuMzY0IDEyOS4zNjUgMTI5LjM2NCA3MS40NDYgMCAxMjkuMzY0LTU3LjkxOCAxMjkuMzY0LTEyOS4zNjQgMC03MS40NDctNTcuOTE4LTEyOS4zNjUtMTI5LjM2NC0xMjkuMzY1ek00MTYuNjI3IDExNy42MDRjMCAxNi42OTYtMTMuNTM1IDMwLjIzLTMwLjIzMSAzMC4yMy0xNi42OTUgMC0zMC4yMy0xMy41MzQtMzAuMjMtMzAuMjMgMC0xNi42OTYgMTMuNTM1LTMwLjIzMSAzMC4yMy0zMC4yMzEgMTYuNjk2IDAgMzAuMjMxIDEzLjUzNSAzMC4yMzEgMzAuMjMxIiBmaWxsPSIjRkZGIi8+PC9nPjwvc3ZnPg==)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#ffe0fe}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder{background:linear-gradient(90deg,#71c6f4,#0d70a5)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MDAgNDAwIj48cGF0aCBkPSJNNDAwIDIwMGMwIDExMC41LTg5LjUgMjAwLTIwMCAyMDBTMCAzMTAuNSAwIDIwMCA4OS41IDAgMjAwIDBzMjAwIDg5LjUgMjAwIDIwMHpNMTYzLjQgMzA1LjVjODguNyAwIDEzNy4yLTczLjUgMTM3LjItMTM3LjIgMC0yLjEgMC00LjItLjEtNi4yIDkuNC02LjggMTcuNi0xNS4zIDI0LjEtMjUtOC42IDMuOC0xNy45IDYuNC0yNy43IDcuNiAxMC02IDE3LjYtMTUuNCAyMS4yLTI2LjctOS4zIDUuNS0xOS42IDkuNS0zMC42IDExLjctOC44LTkuNC0yMS4zLTE1LjItMzUuMi0xNS4yLTI2LjYgMC00OC4yIDIxLjYtNDguMiA0OC4yIDAgMy44LjQgNy41IDEuMyAxMS00MC4xLTItNzUuNi0yMS4yLTk5LjQtNTAuNC00LjEgNy4xLTYuNSAxNS40LTYuNSAyNC4yIDAgMTYuNyA4LjUgMzEuNSAyMS41IDQwLjEtNy45LS4yLTE1LjMtMi40LTIxLjgtNnYuNmMwIDIzLjQgMTYuNiA0Mi44IDM4LjcgNDcuMy00IDEuMS04LjMgMS43LTEyLjcgMS43LTMuMSAwLTYuMS0uMy05LjEtLjkgNi4xIDE5LjIgMjMuOSAzMy4xIDQ1IDMzLjUtMTYuNSAxMi45LTM3LjMgMjAuNi01OS45IDIwLjYtMy45IDAtNy43LS4yLTExLjUtLjcgMjEuMSAxMy44IDQ2LjUgMjEuOCA3My43IDIxLjgiIGZpbGw9IiNmZmYiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text{color:#b8e6ff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}', "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaembedediting.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-media-embed/mediaembedediting.css"],
            names: [],
            mappings: "AAQC,0CACC,YAAa,CACb,qBAAsB,CACtB,kBAmBD,CCpBA,kFACC,aAqBD,CAHC,oBAnBD,kFAoBE,YAEF,CADC,CDlBA,sEAIC,cAAe,CAEf,iBAUD,CCoBD,wFACC,kBAAmB,CACnB,SACD,CD3BE,wGACC,eAAgB,CAChB,aACD,CAQD,+UACC,YACD,CAYF,2LACC,mBACD,CE/CA,MACC,0CAA2C,CAE3C,mDAA4D,CAC5D,2EACD,CAEA,mBACC,aA4FD,CA1FC,0CACC,0CAA+C,CAC/C,0CA4BD,CA1BC,uEACC,qDAAsD,CACtD,kDAAmD,CACnD,qCAAsC,CACtC,uBAA2B,CAC3B,qBAMD,CAJC,gFACC,UAAW,CACX,WACD,CAGD,4EACC,sDAAuD,CACvD,kBAAmB,CACnB,iBAAkB,CAClB,iBAAkB,CAClB,sBAOD,CALC,kFACC,4DAA6D,CAC7D,cAAe,CACf,yBACD,CAIF,wDACC,eAAgB,CAChB,gBACD,CAEA,oFACC,gvGACD,CAEA,2EACC,kBAaD,CAXC,wGACC,orBACD,CAEA,6GACC,UAKD,CAHC,mHACC,UACD,CAIF,4EACC,2DAcD,CAZC,yGACC,4jHACD,CAGA,8GACC,aAKD,CAHC,oHACC,UACD,CAIF,6EAEC,iDAaD,CAXC,0GACC,48BACD,CAEA,+GACC,aAKD,CAHC,qHACC,UACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css";\n\n.ck-media__wrapper {\n\t& .ck-media__placeholder {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\talign-items: center;\n\n\t\t& .ck-media__placeholder__url {\n\t\t\t@mixin ck-tooltip_enabled;\n\n\t\t\t/* Otherwise the URL will overflow when the content is very narrow. */\n\t\t\tmax-width: 100%;\n\n\t\t\tposition: relative;\n\n\t\t\t&:hover {\n\t\t\t\t@mixin ck-tooltip_visible;\n\t\t\t}\n\n\t\t\t& .ck-media__placeholder__url__text {\n\t\t\t\toverflow: hidden;\n\t\t\t\tdisplay: block;\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="twitter.com"],\n\t&[data-oembed-url*="google.com/maps"],\n\t&[data-oembed-url*="facebook.com"],\n\t&[data-oembed-url*="instagram.com"] {\n\t\t& .ck-media__placeholder__icon * {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/* Disable all mouse interaction as long as the editor is not read–only.\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/58 */\n.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper > *:not(.ck-media__placeholder) {\n\tpointer-events: none;\n}\n\n/* Disable all mouse interaction when the widget is not selected (e.g. to avoid opening links by accident).\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/18 */\n.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder {\n\tpointer-events: none;\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Enables the tooltip, which is the tooltip is in DOM but\n * not yet displayed.\n */\n@define-mixin ck-tooltip_enabled {\n\t& .ck-tooltip {\n\t\tdisplay: block;\n\n\t\t/*\n\t\t * Don't display tooltips in devices which don't support :hover.\n\t\t * In fact, it's all about iOS, which forces user to click UI elements twice to execute\n\t\t * the primary action, when tooltips are enabled.\n\t\t *\n\t\t * Q: OK, but why not the following query?\n\t\t *\n\t\t *   @media (hover) {\n\t\t *       display: block;\n\t\t *   }\n\t\t *\n\t\t * A: Because FF does not support it and it would completely disable tooltips\n\t\t * in that browser.\n\t\t *\n\t\t * More in https://github.com/ckeditor/ckeditor5/issues/920.\n\t\t */\n\t\t@media (hover:none) {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/**\n * Disables the tooltip making it disappear from DOM.\n */\n@define-mixin ck-tooltip_disabled {\n\t& .ck-tooltip {\n\t\tdisplay: none;\n\t}\n}\n\n/**\n * Shows the tooltip, which is already in DOM.\n * Requires `ck-tooltip_enabled` first.\n */\n@define-mixin ck-tooltip_visible {\n\t& .ck-tooltip {\n\t\tvisibility: visible;\n\t\topacity: 1;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-media-embed-placeholder-icon-size: 3em;\n\n\t--ck-color-media-embed-placeholder-url-text: hsl(0, 0%, 46%);\n\t--ck-color-media-embed-placeholder-url-text-hover: var(--ck-color-base-text);\n}\n\n.ck-media__wrapper {\n\tmargin: 0 auto;\n\n\t& .ck-media__placeholder {\n\t\tpadding: calc( 3 * var(--ck-spacing-standard) );\n\t\tbackground: var(--ck-color-base-foreground);\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tmin-width: var(--ck-media-embed-placeholder-icon-size);\n\t\t\theight: var(--ck-media-embed-placeholder-icon-size);\n\t\t\tmargin-bottom: var(--ck-spacing-large);\n\t\t\tbackground-position: center;\n\t\t\tbackground-size: cover;\n\n\t\t\t& .ck-icon {\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: var(--ck-color-media-embed-placeholder-url-text);\n\t\t\twhite-space: nowrap;\n\t\t\ttext-align: center;\n\t\t\tfont-style: italic;\n\t\t\ttext-overflow: ellipsis;\n\n\t\t\t&:hover {\n\t\t\t\tcolor: var(--ck-color-media-embed-placeholder-url-text-hover);\n\t\t\t\tcursor: pointer;\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="open.spotify.com"] {\n\t\tmax-width: 300px;\n\t\tmax-height: 380px;\n\t}\n\n\t&[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon {\n\t\tbackground-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0yMDYuNDc3IDI2MC45bC0yOC45ODcgMjguOTg3YTUuMjE4IDUuMjE4IDAgMCAwIDMuNzggMS42MWg0OS42MjFjMS42OTQgMCAzLjE5LS43OTggNC4xNDYtMi4wMzd6IiBmaWxsPSIjNWM4OGM1Ii8+PHBhdGggZD0iTTIyNi43NDIgMjIyLjk4OGMtOS4yNjYgMC0xNi43NzcgNy4xNy0xNi43NzcgMTYuMDE0LjAwNyAyLjc2Mi42NjMgNS40NzQgMi4wOTMgNy44NzUuNDMuNzAzLjgzIDEuNDA4IDEuMTkgMi4xMDcuMzMzLjUwMi42NSAxLjAwNS45NSAxLjUwOC4zNDMuNDc3LjY3My45NTcuOTg4IDEuNDQgMS4zMSAxLjc2OSAyLjUgMy41MDIgMy42MzcgNS4xNjguNzkzIDEuMjc1IDEuNjgzIDIuNjQgMi40NjYgMy45OSAyLjM2MyA0LjA5NCA0LjAwNyA4LjA5MiA0LjYgMTMuOTE0di4wMTJjLjE4Mi40MTIuNTE2LjY2Ni44NzkuNjY3LjQwMy0uMDAxLjc2OC0uMzE0LjkzLS43OTkuNjAzLTUuNzU2IDIuMjM4LTkuNzI5IDQuNTg1LTEzLjc5NC43ODItMS4zNSAxLjY3My0yLjcxNSAyLjQ2NS0zLjk5IDEuMTM3LTEuNjY2IDIuMzI4LTMuNCAzLjYzOC01LjE2OS4zMTUtLjQ4Mi42NDUtLjk2Mi45ODgtMS40MzkuMy0uNTAzLjYxNy0xLjAwNi45NS0xLjUwOC4zNTktLjcuNzYtMS40MDQgMS4xOS0yLjEwNyAxLjQyNi0yLjQwMiAyLTUuMTE0IDIuMDA0LTcuODc1IDAtOC44NDQtNy41MTEtMTYuMDE0LTE2Ljc3Ni0xNi4wMTR6IiBmaWxsPSIjZGQ0YjNlIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxlbGxpcHNlIHJ5PSI1LjU2NCIgcng9IjUuODI4IiBjeT0iMjM5LjAwMiIgY3g9IjIyNi43NDIiIGZpbGw9IiM4MDJkMjciIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTE5MC4zMDEgMjM3LjI4M2MtNC42NyAwLTguNDU3IDMuODUzLTguNDU3IDguNjA2czMuNzg2IDguNjA3IDguNDU3IDguNjA3YzMuMDQzIDAgNC44MDYtLjk1OCA2LjMzNy0yLjUxNiAxLjUzLTEuNTU3IDIuMDg3LTMuOTEzIDIuMDg3LTYuMjkgMC0uMzYyLS4wMjMtLjcyMi0uMDY0LTEuMDc5aC04LjI1N3YzLjA0M2g0Ljg1Yy0uMTk3Ljc1OS0uNTMxIDEuNDUtMS4wNTggMS45ODYtLjk0Mi45NTgtMi4wMjggMS41NDgtMy45MDEgMS41NDgtMi44NzYgMC01LjIwOC0yLjM3Mi01LjIwOC01LjI5OSAwLTIuOTI2IDIuMzMyLTUuMjk5IDUuMjA4LTUuMjk5IDEuMzk5IDAgMi42MTguNDA3IDMuNTg0IDEuMjkzbDIuMzgxLTIuMzhjMC0uMDAyLS4wMDMtLjAwNC0uMDA0LS4wMDUtMS41ODgtMS41MjQtMy42Mi0yLjIxNS01Ljk1NS0yLjIxNXptNC40MyA1LjY2bC4wMDMuMDA2di0uMDAzeiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjE1LjE4NCAyNTEuOTI5bC03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVjLjI4Ny0uNjQ5LjQ0OS0xLjM2Ni40NDktMi4xMjN2LTMxLjE2NWMtLjQ2OS42NzUtLjkzNCAxLjM0OS0xLjM4MiAyLjAwNS0uNzkyIDEuMjc1LTEuNjgyIDIuNjQtMi40NjUgMy45OS0yLjM0NyA0LjA2NS0zLjk4MiA4LjAzOC00LjU4NSAxMy43OTQtLjE2Mi40ODUtLjUyNy43OTgtLjkzLjc5OS0uMzYzLS4wMDEtLjY5Ny0uMjU1LS44NzktLjY2N3YtLjAxMmMtLjU5My01LjgyMi0yLjIzNy05LjgyLTQuNi0xMy45MTQtLjc4My0xLjM1LTEuNjczLTIuNzE1LTIuNDY2LTMuOTktMS4xMzctMS42NjYtMi4zMjctMy40LTMuNjM3LTUuMTY5bC0uMDAyLS4wMDN6IiBmaWxsPSIjYzNjM2MzIi8+PHBhdGggZD0iTTIxMi45ODMgMjQ4LjQ5NWwtMzYuOTUyIDM2Ljk1M3YuODEyYTUuMjI3IDUuMjI3IDAgMCAwIDUuMjM4IDUuMjM4aDEuMDE1bDM1LjY2Ni0zNS42NjZhMTM2LjI3NSAxMzYuMjc1IDAgMCAwLTIuNzY0LTMuOSAzNy41NzUgMzcuNTc1IDAgMCAwLS45ODktMS40NGMtLjI5OS0uNTAzLS42MTYtMS4wMDYtLjk1LTEuNTA4LS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjExLjk5OCAyNjEuMDgzbC02LjE1MiA2LjE1MSAyNC4yNjQgMjQuMjY0aC43ODFhNS4yMjcgNS4yMjcgMCAwIDAgNS4yMzktNS4yMzh2LTEuMDQ1eiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48L2c+PC9zdmc+);\n\t}\n\n\t&[data-oembed-url*="facebook.com"] .ck-media__placeholder {\n\t\tbackground: hsl(220, 46%, 48%);\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSIxMDI0cHgiIGhlaWdodD0iMTAyNHB4IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPiAgICAgICAgPHRpdGxlPkZpbGwgMTwvdGl0bGU+ICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPiAgICA8ZGVmcz48L2RlZnM+ICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPiAgICAgICAgPGcgaWQ9ImZMb2dvX1doaXRlIiBmaWxsPSIjRkZGRkZFIj4gICAgICAgICAgICA8cGF0aCBkPSJNOTY3LjQ4NCwwIEw1Ni41MTcsMCBDMjUuMzA0LDAgMCwyNS4zMDQgMCw1Ni41MTcgTDAsOTY3LjQ4MyBDMCw5OTguNjk0IDI1LjI5NywxMDI0IDU2LjUyMiwxMDI0IEw1NDcsMTAyNCBMNTQ3LDYyOCBMNDE0LDYyOCBMNDE0LDQ3MyBMNTQ3LDQ3MyBMNTQ3LDM1OS4wMjkgQzU0NywyMjYuNzY3IDYyNy43NzMsMTU0Ljc0NyA3NDUuNzU2LDE1NC43NDcgQzgwMi4yNjksMTU0Ljc0NyA4NTAuODQyLDE1OC45NTUgODY1LDE2MC44MzYgTDg2NSwyOTkgTDc4My4zODQsMjk5LjAzNyBDNzE5LjM5MSwyOTkuMDM3IDcwNywzMjkuNTI5IDcwNywzNzQuMjczIEw3MDcsNDczIEw4NjAuNDg3LDQ3MyBMODQwLjUwMSw2MjggTDcwNyw2MjggTDcwNywxMDI0IEw5NjcuNDg0LDEwMjQgQzk5OC42OTcsMTAyNCAxMDI0LDk5OC42OTcgMTAyNCw5NjcuNDg0IEwxMDI0LDU2LjUxNSBDMTAyNCwyNS4zMDMgOTk4LjY5NywwIDk2Ny40ODQsMCIgaWQ9IkZpbGwtMSI+PC9wYXRoPiAgICAgICAgPC9nPiAgICA8L2c+PC9zdmc+);\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(220, 100%, 90%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="instagram.com"] .ck-media__placeholder {\n\t\tbackground: linear-gradient(-135deg,hsl(246, 100%, 39%),hsl(302, 100%, 36%),hsl(0, 100%, 48%));\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSI1MDRweCIgaGVpZ2h0PSI1MDRweCIgdmlld0JveD0iMCAwIDUwNCA1MDQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+ICAgICAgICA8dGl0bGU+Z2x5cGgtbG9nb19NYXkyMDE2PC90aXRsZT4gICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+ICAgIDxkZWZzPiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMSIgcG9pbnRzPSIwIDAuMTU5IDUwMy44NDEgMC4xNTkgNTAzLjg0MSA1MDMuOTQgMCA1MDMuOTQiPjwvcG9seWdvbj4gICAgPC9kZWZzPiAgICA8ZyBpZD0iZ2x5cGgtbG9nb19NYXkyMDE2IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4gICAgICAgIDxnIGlkPSJHcm91cC0zIj4gICAgICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBmaWxsPSJ3aGl0ZSI+ICAgICAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+ICAgICAgICAgICAgPC9tYXNrPiAgICAgICAgICAgIDxnIGlkPSJDbGlwLTIiPjwvZz4gICAgICAgICAgICA8cGF0aCBkPSJNMjUxLjkyMSwwLjE1OSBDMTgzLjUwMywwLjE1OSAxNzQuOTI0LDAuNDQ5IDE0OC4wNTQsMS42NzUgQzEyMS4yNCwyLjg5OCAxMDIuOTI3LDcuMTU3IDg2LjkwMywxMy4zODUgQzcwLjMzNywxOS44MjIgNTYuMjg4LDI4LjQzNiA0Mi4yODIsNDIuNDQxIEMyOC4yNzcsNTYuNDQ3IDE5LjY2Myw3MC40OTYgMTMuMjI2LDg3LjA2MiBDNi45OTgsMTAzLjA4NiAyLjczOSwxMjEuMzk5IDEuNTE2LDE0OC4yMTMgQzAuMjksMTc1LjA4MyAwLDE4My42NjIgMCwyNTIuMDggQzAsMzIwLjQ5NyAwLjI5LDMyOS4wNzYgMS41MTYsMzU1Ljk0NiBDMi43MzksMzgyLjc2IDYuOTk4LDQwMS4wNzMgMTMuMjI2LDQxNy4wOTcgQzE5LjY2Myw0MzMuNjYzIDI4LjI3Nyw0NDcuNzEyIDQyLjI4Miw0NjEuNzE4IEM1Ni4yODgsNDc1LjcyMyA3MC4zMzcsNDg0LjMzNyA4Ni45MDMsNDkwLjc3NSBDMTAyLjkyNyw0OTcuMDAyIDEyMS4yNCw1MDEuMjYxIDE0OC4wNTQsNTAyLjQ4NCBDMTc0LjkyNCw1MDMuNzEgMTgzLjUwMyw1MDQgMjUxLjkyMSw1MDQgQzMyMC4zMzgsNTA0IDMyOC45MTcsNTAzLjcxIDM1NS43ODcsNTAyLjQ4NCBDMzgyLjYwMSw1MDEuMjYxIDQwMC45MTQsNDk3LjAwMiA0MTYuOTM4LDQ5MC43NzUgQzQzMy41MDQsNDg0LjMzNyA0NDcuNTUzLDQ3NS43MjMgNDYxLjU1OSw0NjEuNzE4IEM0NzUuNTY0LDQ0Ny43MTIgNDg0LjE3OCw0MzMuNjYzIDQ5MC42MTYsNDE3LjA5NyBDNDk2Ljg0Myw0MDEuMDczIDUwMS4xMDIsMzgyLjc2IDUwMi4zMjUsMzU1Ljk0NiBDNTAzLjU1MSwzMjkuMDc2IDUwMy44NDEsMzIwLjQ5NyA1MDMuODQxLDI1Mi4wOCBDNTAzLjg0MSwxODMuNjYyIDUwMy41NTEsMTc1LjA4MyA1MDIuMzI1LDE0OC4yMTMgQzUwMS4xMDIsMTIxLjM5OSA0OTYuODQzLDEwMy4wODYgNDkwLjYxNiw4Ny4wNjIgQzQ4NC4xNzgsNzAuNDk2IDQ3NS41NjQsNTYuNDQ3IDQ2MS41NTksNDIuNDQxIEM0NDcuNTUzLDI4LjQzNiA0MzMuNTA0LDE5LjgyMiA0MTYuOTM4LDEzLjM4NSBDNDAwLjkxNCw3LjE1NyAzODIuNjAxLDIuODk4IDM1NS43ODcsMS42NzUgQzMyOC45MTcsMC40NDkgMzIwLjMzOCwwLjE1OSAyNTEuOTIxLDAuMTU5IFogTTI1MS45MjEsNDUuNTUgQzMxOS4xODYsNDUuNTUgMzI3LjE1NCw0NS44MDcgMzUzLjcxOCw0Ny4wMTkgQzM3OC4yOCw0OC4xMzkgMzkxLjYxOSw1Mi4yNDMgNDAwLjQ5Niw1NS42OTMgQzQxMi4yNTUsNjAuMjYzIDQyMC42NDcsNjUuNzIyIDQyOS40NjIsNzQuNTM4IEM0MzguMjc4LDgzLjM1MyA0NDMuNzM3LDkxLjc0NSA0NDguMzA3LDEwMy41MDQgQzQ1MS43NTcsMTEyLjM4MSA0NTUuODYxLDEyNS43MiA0NTYuOTgxLDE1MC4yODIgQzQ1OC4xOTMsMTc2Ljg0NiA0NTguNDUsMTg0LjgxNCA0NTguNDUsMjUyLjA4IEM0NTguNDUsMzE5LjM0NSA0NTguMTkzLDMyNy4zMTMgNDU2Ljk4MSwzNTMuODc3IEM0NTUuODYxLDM3OC40MzkgNDUxLjc1NywzOTEuNzc4IDQ0OC4zMDcsNDAwLjY1NSBDNDQzLjczNyw0MTIuNDE0IDQzOC4yNzgsNDIwLjgwNiA0MjkuNDYyLDQyOS42MjEgQzQyMC42NDcsNDM4LjQzNyA0MTIuMjU1LDQ0My44OTYgNDAwLjQ5Niw0NDguNDY2IEMzOTEuNjE5LDQ1MS45MTYgMzc4LjI4LDQ1Ni4wMiAzNTMuNzE4LDQ1Ny4xNCBDMzI3LjE1OCw0NTguMzUyIDMxOS4xOTEsNDU4LjYwOSAyNTEuOTIxLDQ1OC42MDkgQzE4NC42NSw0NTguNjA5IDE3Ni42ODQsNDU4LjM1MiAxNTAuMTIzLDQ1Ny4xNCBDMTI1LjU2MSw0NTYuMDIgMTEyLjIyMiw0NTEuOTE2IDEwMy4zNDUsNDQ4LjQ2NiBDOTEuNTg2LDQ0My44OTYgODMuMTk0LDQzOC40MzcgNzQuMzc5LDQyOS42MjEgQzY1LjU2NCw0MjAuODA2IDYwLjEwNCw0MTIuNDE0IDU1LjUzNCw0MDAuNjU1IEM1Mi4wODQsMzkxLjc3OCA0Ny45OCwzNzguNDM5IDQ2Ljg2LDM1My44NzcgQzQ1LjY0OCwzMjcuMzEzIDQ1LjM5MSwzMTkuMzQ1IDQ1LjM5MSwyNTIuMDggQzQ1LjM5MSwxODQuODE0IDQ1LjY0OCwxNzYuODQ2IDQ2Ljg2LDE1MC4yODIgQzQ3Ljk4LDEyNS43MiA1Mi4wODQsMTEyLjM4MSA1NS41MzQsMTAzLjUwNCBDNjAuMTA0LDkxLjc0NSA2NS41NjMsODMuMzUzIDc0LjM3OSw3NC41MzggQzgzLjE5NCw2NS43MjIgOTEuNTg2LDYwLjI2MyAxMDMuMzQ1LDU1LjY5MyBDMTEyLjIyMiw1Mi4yNDMgMTI1LjU2MSw0OC4xMzkgMTUwLjEyMyw0Ny4wMTkgQzE3Ni42ODcsNDUuODA3IDE4NC42NTUsNDUuNTUgMjUxLjkyMSw0NS41NSBaIiBpZD0iRmlsbC0xIiBmaWxsPSIjRkZGRkZGIiBtYXNrPSJ1cmwoI21hc2stMikiPjwvcGF0aD4gICAgICAgIDwvZz4gICAgICAgIDxwYXRoIGQ9Ik0yNTEuOTIxLDMzNi4wNTMgQzIwNS41NDMsMzM2LjA1MyAxNjcuOTQ3LDI5OC40NTcgMTY3Ljk0NywyNTIuMDggQzE2Ny45NDcsMjA1LjcwMiAyMDUuNTQzLDE2OC4xMDYgMjUxLjkyMSwxNjguMTA2IEMyOTguMjk4LDE2OC4xMDYgMzM1Ljg5NCwyMDUuNzAyIDMzNS44OTQsMjUyLjA4IEMzMzUuODk0LDI5OC40NTcgMjk4LjI5OCwzMzYuMDUzIDI1MS45MjEsMzM2LjA1MyBaIE0yNTEuOTIxLDEyMi43MTUgQzE4MC40NzQsMTIyLjcxNSAxMjIuNTU2LDE4MC42MzMgMTIyLjU1NiwyNTIuMDggQzEyMi41NTYsMzIzLjUyNiAxODAuNDc0LDM4MS40NDQgMjUxLjkyMSwzODEuNDQ0IEMzMjMuMzY3LDM4MS40NDQgMzgxLjI4NSwzMjMuNTI2IDM4MS4yODUsMjUyLjA4IEMzODEuMjg1LDE4MC42MzMgMzIzLjM2NywxMjIuNzE1IDI1MS45MjEsMTIyLjcxNSBaIiBpZD0iRmlsbC00IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgICAgICA8cGF0aCBkPSJNNDE2LjYyNywxMTcuNjA0IEM0MTYuNjI3LDEzNC4zIDQwMy4wOTIsMTQ3LjgzNCAzODYuMzk2LDE0Ny44MzQgQzM2OS43MDEsMTQ3LjgzNCAzNTYuMTY2LDEzNC4zIDM1Ni4xNjYsMTE3LjYwNCBDMzU2LjE2NiwxMDAuOTA4IDM2OS43MDEsODcuMzczIDM4Ni4zOTYsODcuMzczIEM0MDMuMDkyLDg3LjM3MyA0MTYuNjI3LDEwMC45MDggNDE2LjYyNywxMTcuNjA0IiBpZD0iRmlsbC01IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgIDwvZz48L3N2Zz4=);\n\t\t}\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(302, 100%, 94%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder {\n\t\t/* Use gradient to contrast with focused widget (ckeditor/ckeditor5-media-embed#22). */\n\t\tbackground: linear-gradient( to right, hsl(201, 85%, 70%), hsl(201, 85%, 35%) );\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IldoaXRlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDQwMCA0MDA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj48c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7ZmlsbDojRkZGRkZGO308L3N0eWxlPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MDAsMjAwYzAsMTEwLjUtODkuNSwyMDAtMjAwLDIwMFMwLDMxMC41LDAsMjAwUzg5LjUsMCwyMDAsMFM0MDAsODkuNSw0MDAsMjAweiBNMTYzLjQsMzA1LjVjODguNywwLDEzNy4yLTczLjUsMTM3LjItMTM3LjJjMC0yLjEsMC00LjItMC4xLTYuMmM5LjQtNi44LDE3LjYtMTUuMywyNC4xLTI1Yy04LjYsMy44LTE3LjksNi40LTI3LjcsNy42YzEwLTYsMTcuNi0xNS40LDIxLjItMjYuN2MtOS4zLDUuNS0xOS42LDkuNS0zMC42LDExLjdjLTguOC05LjQtMjEuMy0xNS4yLTM1LjItMTUuMmMtMjYuNiwwLTQ4LjIsMjEuNi00OC4yLDQ4LjJjMCwzLjgsMC40LDcuNSwxLjMsMTFjLTQwLjEtMi03NS42LTIxLjItOTkuNC01MC40Yy00LjEsNy4xLTYuNSwxNS40LTYuNSwyNC4yYzAsMTYuNyw4LjUsMzEuNSwyMS41LDQwLjFjLTcuOS0wLjItMTUuMy0yLjQtMjEuOC02YzAsMC4yLDAsMC40LDAsMC42YzAsMjMuNCwxNi42LDQyLjgsMzguNyw0Ny4zYy00LDEuMS04LjMsMS43LTEyLjcsMS43Yy0zLjEsMC02LjEtMC4zLTkuMS0wLjljNi4xLDE5LjIsMjMuOSwzMy4xLDQ1LDMzLjVjLTE2LjUsMTIuOS0zNy4zLDIwLjYtNTkuOSwyMC42Yy0zLjksMC03LjctMC4yLTExLjUtMC43QzExMC44LDI5Ny41LDEzNi4yLDMwNS41LDE2My40LDMwNS41Ii8+PC9zdmc+);\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(201, 100%, 86%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck.ck-media-form{display:flex;align-items:flex-start;flex-direction:row;flex-wrap:nowrap}.ck.ck-media-form .ck-labeled-field-view{display:inline-block}.ck.ck-media-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-media-form{flex-wrap:wrap}.ck.ck-media-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-media-form .ck-button{flex-basis:50%}}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"],
            names: [],
            mappings: "AAOA,kBACC,YAAa,CACb,sBAAuB,CACvB,kBAAmB,CACnB,gBAqBD,CAnBC,yCACC,oBACD,CAEA,4BACC,YACD,CCbA,oCDCD,kBAeE,cAUF,CARE,yCACC,eACD,CAEA,6BACC,cACD,CCtBD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-media-form {\n\tdisplay: flex;\n\talign-items: flex-start;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e, n) {
        "use strict";
        var o = n(2);
        var i = n.n(o);
        var r = n(3);
        var s = n.n(r);
        var a = s()(i.a);
        a.push([t.i, ".ck-content .media{clear:both;margin:1em 0;display:block;min-width:15em}", "", {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaembed.css"],
            names: [],
            mappings: "AAKA,mBAGC,UAAW,CAGX,YAAa,CAIb,aAAc,CAId,cACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .media {\n\t/* Don\'t allow floated content overlap the media.\n\thttps://github.com/ckeditor/ckeditor5-media-embed/issues/53 */\n\tclear: both;\n\n\t/* Make sure there is some space between the content and the media. */\n\tmargin: 1em 0;\n\n\t/* Make sure media is not overriden with Bootstrap default `flex` value.\n\tSee: https://github.com/ckeditor/ckeditor5/issues/1373. */\n\tdisplay: block;\n\n\t/* Give the media some minimal width in the content to prevent them\n\tfrom being "squashed" in tight spaces, e.g. in table cells (#44) */\n\tmin-width: 15em;\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function(t, e) {
        var n;
        n = function() {
            return this
        }();
        try {
            n = n || new Function("return this")()
        } catch (t) {
            if (typeof window === "object") n = window
        }
        t.exports = n
    }, function(t, e, n) {
        "use strict";

        function o() {
            return false
        }
        e["a"] = o
    }, function(t, e, n) {
        "use strict";
        n.r(e);
        var o = n(5);
        var i = o["a"].Symbol;
        var r = i;
        var s = Object.prototype;
        var a = s.hasOwnProperty;
        var c = s.toString;
        var l = r ? r.toStringTag : undefined;

        function d(t) {
            var e = a.call(t, l),
                n = t[l];
            try {
                t[l] = undefined;
                var o = true
            } catch (t) {}
            var i = c.call(t);
            if (o) {
                if (e) {
                    t[l] = n
                } else {
                    delete t[l]
                }
            }
            return i
        }
        var u = d;
        var h = Object.prototype;
        var f = h.toString;

        function p(t) {
            return f.call(t)
        }
        var m = p;
        var g = "[object Null]",
            k = "[object Undefined]";
        var b = r ? r.toStringTag : undefined;

        function w(t) {
            if (t == null) {
                return t === undefined ? k : g
            }
            return b && b in Object(t) ? u(t) : m(t)
        }
        var A = w;

        function C(t, e) {
            return function(n) {
                return t(e(n))
            }
        }
        var _ = C;
        var v = _(Object.getPrototypeOf, Object);
        var y = v;

        function x(t) {
            return t != null && typeof t == "object"
        }
        var D = x;
        var M = "[object Object]";
        var E = Function.prototype,
            S = Object.prototype;
        var T = E.toString;
        var I = S.hasOwnProperty;
        var N = T.call(Object);

        function P(t) {
            if (!D(t) || A(t) != M) {
                return false
            }
            var e = y(t);
            if (e === null) {
                return true
            }
            var n = I.call(e, "constructor") && e.constructor;
            return typeof n == "function" && n instanceof n && T.call(n) == N
        }
        var B = P;

        function L() {
            this.__data__ = [];
            this.size = 0
        }
        var O = L;

        function z(t, e) {
            return t === e || t !== t && e !== e
        }
        var j = z;

        function F(t, e) {
            var n = t.length;
            while (n--) {
                if (j(t[n][0], e)) {
                    return n
                }
            }
            return -1
        }
        var R = F;
        var V = Array.prototype;
        var U = V.splice;

        function G(t) {
            var e = this.__data__,
                n = R(e, t);
            if (n < 0) {
                return false
            }
            var o = e.length - 1;
            if (n == o) {
                e.pop()
            } else {
                U.call(e, n, 1)
            }--this.size;
            return true
        }
        var K = G;

        function Y(t) {
            var e = this.__data__,
                n = R(e, t);
            return n < 0 ? undefined : e[n][1]
        }
        var H = Y;

        function q(t) {
            return R(this.__data__, t) > -1
        }
        var W = q;

        function Q(t, e) {
            var n = this.__data__,
                o = R(n, t);
            if (o < 0) {
                ++this.size;
                n.push([t, e])
            } else {
                n[o][1] = e
            }
            return this
        }
        var $ = Q;

        function Z(t) {
            var e = -1,
                n = t == null ? 0 : t.length;
            this.clear();
            while (++e < n) {
                var o = t[e];
                this.set(o[0], o[1])
            }
        }
        Z.prototype.clear = O;
        Z.prototype["delete"] = K;
        Z.prototype.get = H;
        Z.prototype.has = W;
        Z.prototype.set = $;
        var J = Z;

        function X() {
            this.__data__ = new J;
            this.size = 0
        }
        var tt = X;

        function et(t) {
            var e = this.__data__,
                n = e["delete"](t);
            this.size = e.size;
            return n
        }
        var nt = et;

        function ot(t) {
            return this.__data__.get(t)
        }
        var it = ot;

        function rt(t) {
            return this.__data__.has(t)
        }
        var st = rt;

        function at(t) {
            var e = typeof t;
            return t != null && (e == "object" || e == "function")
        }
        var ct = at;
        var lt = "[object AsyncFunction]",
            dt = "[object Function]",
            ut = "[object GeneratorFunction]",
            ht = "[object Proxy]";

        function ft(t) {
            if (!ct(t)) {
                return false
            }
            var e = A(t);
            return e == dt || e == ut || e == lt || e == ht
        }
        var pt = ft;
        var mt = o["a"]["__core-js_shared__"];
        var gt = mt;
        var kt = function() {
            var t = /[^.]+$/.exec(gt && gt.keys && gt.keys.IE_PROTO || "");
            return t ? "Symbol(src)_1." + t : ""
        }();

        function bt(t) {
            return !!kt && kt in t
        }
        var wt = bt;
        var At = Function.prototype;
        var Ct = At.toString;

        function _t(t) {
            if (t != null) {
                try {
                    return Ct.call(t)
                } catch (t) {}
                try {
                    return t + ""
                } catch (t) {}
            }
            return ""
        }
        var vt = _t;
        var yt = /[\\^$.*+?()[\]{}|]/g;
        var xt = /^\[object .+?Constructor\]$/;
        var Dt = Function.prototype,
            Mt = Object.prototype;
        var Et = Dt.toString;
        var St = Mt.hasOwnProperty;
        var Tt = RegExp("^" + Et.call(St).replace(yt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");

        function It(t) {
            if (!ct(t) || wt(t)) {
                return false
            }
            var e = pt(t) ? Tt : xt;
            return e.test(vt(t))
        }
        var Nt = It;

        function Pt(t, e) {
            return t == null ? undefined : t[e]
        }
        var Bt = Pt;

        function Lt(t, e) {
            var n = Bt(t, e);
            return Nt(n) ? n : undefined
        }
        var Ot = Lt;
        var zt = Ot(o["a"], "Map");
        var jt = zt;
        var Ft = Ot(Object, "create");
        var Rt = Ft;

        function Vt() {
            this.__data__ = Rt ? Rt(null) : {};
            this.size = 0
        }
        var Ut = Vt;

        function Gt(t) {
            var e = this.has(t) && delete this.__data__[t];
            this.size -= e ? 1 : 0;
            return e
        }
        var Kt = Gt;
        var Yt = "__lodash_hash_undefined__";
        var Ht = Object.prototype;
        var qt = Ht.hasOwnProperty;

        function Wt(t) {
            var e = this.__data__;
            if (Rt) {
                var n = e[t];
                return n === Yt ? undefined : n
            }
            return qt.call(e, t) ? e[t] : undefined
        }
        var Qt = Wt;
        var $t = Object.prototype;
        var Zt = $t.hasOwnProperty;

        function Jt(t) {
            var e = this.__data__;
            return Rt ? e[t] !== undefined : Zt.call(e, t)
        }
        var Xt = Jt;
        var te = "__lodash_hash_undefined__";

        function ee(t, e) {
            var n = this.__data__;
            this.size += this.has(t) ? 0 : 1;
            n[t] = Rt && e === undefined ? te : e;
            return this
        }
        var ne = ee;

        function oe(t) {
            var e = -1,
                n = t == null ? 0 : t.length;
            this.clear();
            while (++e < n) {
                var o = t[e];
                this.set(o[0], o[1])
            }
        }
        oe.prototype.clear = Ut;
        oe.prototype["delete"] = Kt;
        oe.prototype.get = Qt;
        oe.prototype.has = Xt;
        oe.prototype.set = ne;
        var ie = oe;

        function re() {
            this.size = 0;
            this.__data__ = {
                hash: new ie,
                map: new(jt || J),
                string: new ie
            }
        }
        var se = re;

        function ae(t) {
            var e = typeof t;
            return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null
        }
        var ce = ae;

        function le(t, e) {
            var n = t.__data__;
            return ce(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map
        }
        var de = le;

        function ue(t) {
            var e = de(this, t)["delete"](t);
            this.size -= e ? 1 : 0;
            return e
        }
        var he = ue;

        function fe(t) {
            return de(this, t).get(t)
        }
        var pe = fe;

        function me(t) {
            return de(this, t).has(t)
        }
        var ge = me;

        function ke(t, e) {
            var n = de(this, t),
                o = n.size;
            n.set(t, e);
            this.size += n.size == o ? 0 : 1;
            return this
        }
        var be = ke;

        function we(t) {
            var e = -1,
                n = t == null ? 0 : t.length;
            this.clear();
            while (++e < n) {
                var o = t[e];
                this.set(o[0], o[1])
            }
        }
        we.prototype.clear = se;
        we.prototype["delete"] = he;
        we.prototype.get = pe;
        we.prototype.has = ge;
        we.prototype.set = be;
        var Ae = we;
        var Ce = 200;

        function _e(t, e) {
            var n = this.__data__;
            if (n instanceof J) {
                var o = n.__data__;
                if (!jt || o.length < Ce - 1) {
                    o.push([t, e]);
                    this.size = ++n.size;
                    return this
                }
                n = this.__data__ = new Ae(o)
            }
            n.set(t, e);
            this.size = n.size;
            return this
        }
        var ve = _e;

        function ye(t) {
            var e = this.__data__ = new J(t);
            this.size = e.size
        }
        ye.prototype.clear = tt;
        ye.prototype["delete"] = nt;
        ye.prototype.get = it;
        ye.prototype.has = st;
        ye.prototype.set = ve;
        var xe = ye;

        function De(t, e) {
            var n = -1,
                o = t == null ? 0 : t.length;
            while (++n < o) {
                if (e(t[n], n, t) === false) {
                    break
                }
            }
            return t
        }
        var Me = De;
        var Ee = function() {
            try {
                var t = Ot(Object, "defineProperty");
                t({}, "", {});
                return t
            } catch (t) {}
        }();
        var Se = Ee;

        function Te(t, e, n) {
            if (e == "__proto__" && Se) {
                Se(t, e, {
                    configurable: true,
                    enumerable: true,
                    value: n,
                    writable: true
                })
            } else {
                t[e] = n
            }
        }
        var Ie = Te;
        var Ne = Object.prototype;
        var Pe = Ne.hasOwnProperty;

        function Be(t, e, n) {
            var o = t[e];
            if (!(Pe.call(t, e) && j(o, n)) || n === undefined && !(e in t)) {
                Ie(t, e, n)
            }
        }
        var Le = Be;

        function Oe(t, e, n, o) {
            var i = !n;
            n || (n = {});
            var r = -1,
                s = e.length;
            while (++r < s) {
                var a = e[r];
                var c = o ? o(n[a], t[a], a, n, t) : undefined;
                if (c === undefined) {
                    c = t[a]
                }
                if (i) {
                    Ie(n, a, c)
                } else {
                    Le(n, a, c)
                }
            }
            return n
        }
        var ze = Oe;

        function je(t, e) {
            var n = -1,
                o = Array(t);
            while (++n < t) {
                o[n] = e(n)
            }
            return o
        }
        var Fe = je;
        var Re = "[object Arguments]";

        function Ve(t) {
            return D(t) && A(t) == Re
        }
        var Ue = Ve;
        var Ge = Object.prototype;
        var Ke = Ge.hasOwnProperty;
        var Ye = Ge.propertyIsEnumerable;
        var He = Ue(function() {
            return arguments
        }()) ? Ue : function(t) {
            return D(t) && Ke.call(t, "callee") && !Ye.call(t, "callee")
        };
        var qe = He;
        var We = Array.isArray;
        var Qe = We;
        var $e = n(6);
        var Ze = 9007199254740991;
        var Je = /^(?:0|[1-9]\d*)$/;

        function Xe(t, e) {
            var n = typeof t;
            e = e == null ? Ze : e;
            return !!e && (n == "number" || n != "symbol" && Je.test(t)) && (t > -1 && t % 1 == 0 && t < e)
        }
        var tn = Xe;
        var en = 9007199254740991;

        function nn(t) {
            return typeof t == "number" && t > -1 && t % 1 == 0 && t <= en
        }
        var on = nn;
        var rn = "[object Arguments]",
            sn = "[object Array]",
            an = "[object Boolean]",
            cn = "[object Date]",
            ln = "[object Error]",
            dn = "[object Function]",
            un = "[object Map]",
            hn = "[object Number]",
            fn = "[object Object]",
            pn = "[object RegExp]",
            mn = "[object Set]",
            gn = "[object String]",
            kn = "[object WeakMap]";
        var bn = "[object ArrayBuffer]",
            wn = "[object DataView]",
            An = "[object Float32Array]",
            Cn = "[object Float64Array]",
            _n = "[object Int8Array]",
            vn = "[object Int16Array]",
            yn = "[object Int32Array]",
            xn = "[object Uint8Array]",
            Dn = "[object Uint8ClampedArray]",
            Mn = "[object Uint16Array]",
            En = "[object Uint32Array]";
        var Sn = {};
        Sn[An] = Sn[Cn] = Sn[_n] = Sn[vn] = Sn[yn] = Sn[xn] = Sn[Dn] = Sn[Mn] = Sn[En] = true;
        Sn[rn] = Sn[sn] = Sn[bn] = Sn[an] = Sn[wn] = Sn[cn] = Sn[ln] = Sn[dn] = Sn[un] = Sn[hn] = Sn[fn] = Sn[pn] = Sn[mn] = Sn[gn] = Sn[kn] = false;

        function Tn(t) {
            return D(t) && on(t.length) && !!Sn[A(t)]
        }
        var In = Tn;

        function Nn(t) {
            return function(e) {
                return t(e)
            }
        }
        var Pn = Nn;
        var Bn = n(7);
        var Ln = Bn["a"] && Bn["a"].isTypedArray;
        var On = Ln ? Pn(Ln) : In;
        var zn = On;
        var jn = Object.prototype;
        var Fn = jn.hasOwnProperty;

        function Rn(t, e) {
            var n = Qe(t),
                o = !n && qe(t),
                i = !n && !o && Object($e["a"])(t),
                r = !n && !o && !i && zn(t),
                s = n || o || i || r,
                a = s ? Fe(t.length, String) : [],
                c = a.length;
            for (var l in t) {
                if ((e || Fn.call(t, l)) && !(s && (l == "length" || i && (l == "offset" || l == "parent") || r && (l == "buffer" || l == "byteLength" || l == "byteOffset") || tn(l, c)))) {
                    a.push(l)
                }
            }
            return a
        }
        var Vn = Rn;
        var Un = Object.prototype;

        function Gn(t) {
            var e = t && t.constructor,
                n = typeof e == "function" && e.prototype || Un;
            return t === n
        }
        var Kn = Gn;
        var Yn = _(Object.keys, Object);
        var Hn = Yn;
        var qn = Object.prototype;
        var Wn = qn.hasOwnProperty;

        function Qn(t) {
            if (!Kn(t)) {
                return Hn(t)
            }
            var e = [];
            for (var n in Object(t)) {
                if (Wn.call(t, n) && n != "constructor") {
                    e.push(n)
                }
            }
            return e
        }
        var $n = Qn;

        function Zn(t) {
            return t != null && on(t.length) && !pt(t)
        }
        var Jn = Zn;

        function Xn(t) {
            return Jn(t) ? Vn(t) : $n(t)
        }
        var to = Xn;

        function eo(t, e) {
            return t && ze(e, to(e), t)
        }
        var no = eo;

        function oo(t) {
            var e = [];
            if (t != null) {
                for (var n in Object(t)) {
                    e.push(n)
                }
            }
            return e
        }
        var io = oo;
        var ro = Object.prototype;
        var so = ro.hasOwnProperty;

        function ao(t) {
            if (!ct(t)) {
                return io(t)
            }
            var e = Kn(t),
                n = [];
            for (var o in t) {
                if (!(o == "constructor" && (e || !so.call(t, o)))) {
                    n.push(o)
                }
            }
            return n
        }
        var co = ao;

        function lo(t) {
            return Jn(t) ? Vn(t, true) : co(t)
        }
        var uo = lo;

        function ho(t, e) {
            return t && ze(e, uo(e), t)
        }
        var fo = ho;
        var po = n(10);

        function mo(t, e) {
            var n = -1,
                o = t.length;
            e || (e = Array(o));
            while (++n < o) {
                e[n] = t[n]
            }
            return e
        }
        var go = mo;

        function ko(t, e) {
            var n = -1,
                o = t == null ? 0 : t.length,
                i = 0,
                r = [];
            while (++n < o) {
                var s = t[n];
                if (e(s, n, t)) {
                    r[i++] = s
                }
            }
            return r
        }
        var bo = ko;

        function wo() {
            return []
        }
        var Ao = wo;
        var Co = Object.prototype;
        var _o = Co.propertyIsEnumerable;
        var vo = Object.getOwnPropertySymbols;
        var yo = !vo ? Ao : function(t) {
            if (t == null) {
                return []
            }
            t = Object(t);
            return bo(vo(t), (function(e) {
                return _o.call(t, e)
            }))
        };
        var xo = yo;

        function Do(t, e) {
            return ze(t, xo(t), e)
        }
        var Mo = Do;

        function Eo(t, e) {
            var n = -1,
                o = e.length,
                i = t.length;
            while (++n < o) {
                t[i + n] = e[n]
            }
            return t
        }
        var So = Eo;
        var To = Object.getOwnPropertySymbols;
        var Io = !To ? Ao : function(t) {
            var e = [];
            while (t) {
                So(e, xo(t));
                t = y(t)
            }
            return e
        };
        var No = Io;

        function Po(t, e) {
            return ze(t, No(t), e)
        }
        var Bo = Po;

        function Lo(t, e, n) {
            var o = e(t);
            return Qe(t) ? o : So(o, n(t))
        }
        var Oo = Lo;

        function zo(t) {
            return Oo(t, to, xo)
        }
        var jo = zo;

        function Fo(t) {
            return Oo(t, uo, No)
        }
        var Ro = Fo;
        var Vo = Ot(o["a"], "DataView");
        var Uo = Vo;
        var Go = Ot(o["a"], "Promise");
        var Ko = Go;
        var Yo = Ot(o["a"], "Set");
        var Ho = Yo;
        var qo = Ot(o["a"], "WeakMap");
        var Wo = qo;
        var Qo = "[object Map]",
            $o = "[object Object]",
            Zo = "[object Promise]",
            Jo = "[object Set]",
            Xo = "[object WeakMap]";
        var ti = "[object DataView]";
        var ei = vt(Uo),
            ni = vt(jt),
            oi = vt(Ko),
            ii = vt(Ho),
            ri = vt(Wo);
        var si = A;
        if (Uo && si(new Uo(new ArrayBuffer(1))) != ti || jt && si(new jt) != Qo || Ko && si(Ko.resolve()) != Zo || Ho && si(new Ho) != Jo || Wo && si(new Wo) != Xo) {
            si = function(t) {
                var e = A(t),
                    n = e == $o ? t.constructor : undefined,
                    o = n ? vt(n) : "";
                if (o) {
                    switch (o) {
                        case ei:
                            return ti;
                        case ni:
                            return Qo;
                        case oi:
                            return Zo;
                        case ii:
                            return Jo;
                        case ri:
                            return Xo
                    }
                }
                return e
            }
        }
        var ai = si;
        var ci = Object.prototype;
        var li = ci.hasOwnProperty;

        function di(t) {
            var e = t.length,
                n = new t.constructor(e);
            if (e && typeof t[0] == "string" && li.call(t, "index")) {
                n.index = t.index;
                n.input = t.input
            }
            return n
        }
        var ui = di;
        var hi = o["a"].Uint8Array;
        var fi = hi;

        function pi(t) {
            var e = new t.constructor(t.byteLength);
            new fi(e).set(new fi(t));
            return e
        }
        var mi = pi;

        function gi(t, e) {
            var n = e ? mi(t.buffer) : t.buffer;
            return new t.constructor(n, t.byteOffset, t.byteLength)
        }
        var ki = gi;
        var bi = /\w*$/;

        function wi(t) {
            var e = new t.constructor(t.source, bi.exec(t));
            e.lastIndex = t.lastIndex;
            return e
        }
        var Ai = wi;
        var Ci = r ? r.prototype : undefined,
            _i = Ci ? Ci.valueOf : undefined;

        function vi(t) {
            return _i ? Object(_i.call(t)) : {}
        }
        var yi = vi;

        function xi(t, e) {
            var n = e ? mi(t.buffer) : t.buffer;
            return new t.constructor(n, t.byteOffset, t.length)
        }
        var Di = xi;
        var Mi = "[object Boolean]",
            Ei = "[object Date]",
            Si = "[object Map]",
            Ti = "[object Number]",
            Ii = "[object RegExp]",
            Ni = "[object Set]",
            Pi = "[object String]",
            Bi = "[object Symbol]";
        var Li = "[object ArrayBuffer]",
            Oi = "[object DataView]",
            zi = "[object Float32Array]",
            ji = "[object Float64Array]",
            Fi = "[object Int8Array]",
            Ri = "[object Int16Array]",
            Vi = "[object Int32Array]",
            Ui = "[object Uint8Array]",
            Gi = "[object Uint8ClampedArray]",
            Ki = "[object Uint16Array]",
            Yi = "[object Uint32Array]";

        function Hi(t, e, n) {
            var o = t.constructor;
            switch (e) {
                case Li:
                    return mi(t);
                case Mi:
                case Ei:
                    return new o(+t);
                case Oi:
                    return ki(t, n);
                case zi:
                case ji:
                case Fi:
                case Ri:
                case Vi:
                case Ui:
                case Gi:
                case Ki:
                case Yi:
                    return Di(t, n);
                case Si:
                    return new o;
                case Ti:
                case Pi:
                    return new o(t);
                case Ii:
                    return Ai(t);
                case Ni:
                    return new o;
                case Bi:
                    return yi(t)
            }
        }
        var qi = Hi;
        var Wi = Object.create;
        var Qi = function() {
            function t() {}
            return function(e) {
                if (!ct(e)) {
                    return {}
                }
                if (Wi) {
                    return Wi(e)
                }
                t.prototype = e;
                var n = new t;
                t.prototype = undefined;
                return n
            }
        }();
        var $i = Qi;

        function Zi(t) {
            return typeof t.constructor == "function" && !Kn(t) ? $i(y(t)) : {}
        }
        var Ji = Zi;
        var Xi = "[object Map]";

        function tr(t) {
            return D(t) && ai(t) == Xi
        }
        var er = tr;
        var nr = Bn["a"] && Bn["a"].isMap;
        var or = nr ? Pn(nr) : er;
        var ir = or;
        var rr = "[object Set]";

        function sr(t) {
            return D(t) && ai(t) == rr
        }
        var ar = sr;
        var cr = Bn["a"] && Bn["a"].isSet;
        var lr = cr ? Pn(cr) : ar;
        var dr = lr;
        var ur = 1,
            hr = 2,
            fr = 4;
        var pr = "[object Arguments]",
            mr = "[object Array]",
            gr = "[object Boolean]",
            kr = "[object Date]",
            br = "[object Error]",
            wr = "[object Function]",
            Ar = "[object GeneratorFunction]",
            Cr = "[object Map]",
            _r = "[object Number]",
            vr = "[object Object]",
            yr = "[object RegExp]",
            xr = "[object Set]",
            Dr = "[object String]",
            Mr = "[object Symbol]",
            Er = "[object WeakMap]";
        var Sr = "[object ArrayBuffer]",
            Tr = "[object DataView]",
            Ir = "[object Float32Array]",
            Nr = "[object Float64Array]",
            Pr = "[object Int8Array]",
            Br = "[object Int16Array]",
            Lr = "[object Int32Array]",
            Or = "[object Uint8Array]",
            zr = "[object Uint8ClampedArray]",
            jr = "[object Uint16Array]",
            Fr = "[object Uint32Array]";
        var Rr = {};
        Rr[pr] = Rr[mr] = Rr[Sr] = Rr[Tr] = Rr[gr] = Rr[kr] = Rr[Ir] = Rr[Nr] = Rr[Pr] = Rr[Br] = Rr[Lr] = Rr[Cr] = Rr[_r] = Rr[vr] = Rr[yr] = Rr[xr] = Rr[Dr] = Rr[Mr] = Rr[Or] = Rr[zr] = Rr[jr] = Rr[Fr] = true;
        Rr[br] = Rr[wr] = Rr[Er] = false;

        function Vr(t, e, n, o, i, r) {
            var s, a = e & ur,
                c = e & hr,
                l = e & fr;
            if (n) {
                s = i ? n(t, o, i, r) : n(t)
            }
            if (s !== undefined) {
                return s
            }
            if (!ct(t)) {
                return t
            }
            var d = Qe(t);
            if (d) {
                s = ui(t);
                if (!a) {
                    return go(t, s)
                }
            } else {
                var u = ai(t),
                    h = u == wr || u == Ar;
                if (Object($e["a"])(t)) {
                    return Object(po["a"])(t, a)
                }
                if (u == vr || u == pr || h && !i) {
                    s = c || h ? {} : Ji(t);
                    if (!a) {
                        return c ? Bo(t, fo(s, t)) : Mo(t, no(s, t))
                    }
                } else {
                    if (!Rr[u]) {
                        return i ? t : {}
                    }
                    s = qi(t, u, a)
                }
            }
            r || (r = new xe);
            var f = r.get(t);
            if (f) {
                return f
            }
            r.set(t, s);
            if (dr(t)) {
                t.forEach((function(o) {
                    s.add(Vr(o, e, n, o, t, r))
                }))
            } else if (ir(t)) {
                t.forEach((function(o, i) {
                    s.set(i, Vr(o, e, n, i, t, r))
                }))
            }
            var p = l ? c ? Ro : jo : c ? keysIn : to;
            var m = d ? undefined : p(t);
            Me(m || t, (function(o, i) {
                if (m) {
                    i = o;
                    o = t[i]
                }
                Le(s, i, Vr(o, e, n, i, t, r))
            }));
            return s
        }
        var Ur = Vr;
        var Gr = 1,
            Kr = 4;

        function Yr(t, e) {
            e = typeof e == "function" ? e : undefined;
            return Ur(t, Gr | Kr, e)
        }
        var Hr = Yr;

        function qr(t) {
            return D(t) && t.nodeType === 1 && !B(t)
        }
        var Wr = qr;
        class Qr {
            constructor(t, e) {
                this._config = {};
                if (e) {
                    this.define($r(e))
                }
                if (t) {
                    this._setObjectToTarget(this._config, t)
                }
            }
            set(t, e) {
                this._setToTarget(this._config, t, e)
            }
            define(t, e) {
                const n = true;
                this._setToTarget(this._config, t, e, n)
            }
            get(t) {
                return this._getFromSource(this._config, t)
            }* names() {
                for (const t of Object.keys(this._config)) {
                    yield t
                }
            }
            _setToTarget(t, e, n, o = false) {
                if (B(e)) {
                    this._setObjectToTarget(t, e, o);
                    return
                }
                const i = e.split(".");
                e = i.pop();
                for (const e of i) {
                    if (!B(t[e])) {
                        t[e] = {}
                    }
                    t = t[e]
                }
                if (B(n)) {
                    if (!B(t[e])) {
                        t[e] = {}
                    }
                    t = t[e];
                    this._setObjectToTarget(t, n, o);
                    return
                }
                if (o && typeof t[e] != "undefined") {
                    return
                }
                t[e] = n
            }
            _getFromSource(t, e) {
                const n = e.split(".");
                e = n.pop();
                for (const e of n) {
                    if (!B(t[e])) {
                        t = null;
                        break
                    }
                    t = t[e]
                }
                return t ? $r(t[e]) : undefined
            }
            _setObjectToTarget(t, e, n) {
                Object.keys(e).forEach((o => {
                    this._setToTarget(t, o, e[o], n)
                }))
            }
        }

        function $r(t) {
            return Hr(t, Zr)
        }

        function Zr(t) {
            return Wr(t) ? t : undefined
        }

        function Jr() {
            return function t() {
                t.called = true
            }
        }
        var Xr = Jr;
        class ts {
            constructor(t, e) {
                this.source = t;
                this.name = e;
                this.path = [];
                this.stop = Xr();
                this.off = Xr()
            }
        }
        const es = new Array(256).fill().map(((t, e) => ("0" + e.toString(16)).slice(-2)));

        function ns() {
            const t = Math.random() * 4294967296 >>> 0;
            const e = Math.random() * 4294967296 >>> 0;
            const n = Math.random() * 4294967296 >>> 0;
            const o = Math.random() * 4294967296 >>> 0;
            return "e" + es[t >> 0 & 255] + es[t >> 8 & 255] + es[t >> 16 & 255] + es[t >> 24 & 255] + es[e >> 0 & 255] + es[e >> 8 & 255] + es[e >> 16 & 255] + es[e >> 24 & 255] + es[n >> 0 & 255] + es[n >> 8 & 255] + es[n >> 16 & 255] + es[n >> 24 & 255] + es[o >> 0 & 255] + es[o >> 8 & 255] + es[o >> 16 & 255] + es[o >> 24 & 255]
        }
        const os = {
            get(t) {
                if (typeof t != "number") {
                    return this[t] || this.normal
                } else {
                    return t
                }
            },
            highest: 1e5,
            high: 1e3,
            normal: 0,
            low: -1e3,
            lowest: -1e5
        };
        var is = os;
        var rs = n(8);
        var ss = n(0);
        const as = Symbol("listeningTo");
        const cs = Symbol("emitterId");
        const ls = {
            on(t, e, n = {}) {
                this.listenTo(this, t, e, n)
            },
            once(t, e, n) {
                let o = false;
                const i = function(t, ...n) {
                    if (!o) {
                        o = true;
                        t.off();
                        e.call(this, t, ...n)
                    }
                };
                this.listenTo(this, t, i, n)
            },
            off(t, e) {
                this.stopListening(this, t, e)
            },
            listenTo(t, e, n, o = {}) {
                let i, r;
                if (!this[as]) {
                    this[as] = {}
                }
                const s = this[as];
                if (!fs(t)) {
                    hs(t)
                }
                const a = fs(t);
                if (!(i = s[a])) {
                    i = s[a] = {
                        emitter: t,
                        callbacks: {}
                    }
                }
                if (!(r = i.callbacks[e])) {
                    r = i.callbacks[e] = []
                }
                r.push(n);
                gs(t, e);
                const c = ks(t, e);
                const l = is.get(o.priority);
                const d = {
                    callback: n,
                    priority: l
                };
                for (const t of c) {
                    let e = false;
                    for (let n = 0; n < t.length; n++) {
                        if (t[n].priority < l) {
                            t.splice(n, 0, d);
                            e = true;
                            break
                        }
                    }
                    if (!e) {
                        t.push(d)
                    }
                }
            },
            stopListening(t, e, n) {
                const o = this[as];
                let i = t && fs(t);
                const r = o && i && o[i];
                const s = r && e && r.callbacks[e];
                if (!o || t && !r || e && !s) {
                    return
                }
                if (n) {
                    As(t, e, n);
                    const o = s.indexOf(n);
                    if (o !== -1) {
                        if (s.length === 1) {
                            delete r.callbacks[e]
                        } else {
                            As(t, e, n)
                        }
                    }
                } else if (s) {
                    while (n = s.pop()) {
                        As(t, e, n)
                    }
                    delete r.callbacks[e]
                } else if (r) {
                    for (e in r.callbacks) {
                        this.stopListening(t, e)
                    }
                    delete o[i]
                } else {
                    for (i in o) {
                        this.stopListening(o[i].emitter)
                    }
                    delete this[as]
                }
            },
            fire(t, ...e) {
                try {
                    const n = t instanceof ts ? t : new ts(this, t);
                    const o = n.name;
                    let i = bs(this, o);
                    n.path.push(this);
                    if (i) {
                        const t = [n, ...e];
                        i = Array.from(i);
                        for (let e = 0; e < i.length; e++) {
                            i[e].callback.apply(this, t);
                            if (n.off.called) {
                                delete n.off.called;
                                As(this, o, i[e].callback)
                            }
                            if (n.stop.called) {
                                break
                            }
                        }
                    }
                    if (this._delegations) {
                        const t = this._delegations.get(o);
                        const i = this._delegations.get("*");
                        if (t) {
                            ws(t, n, e)
                        }
                        if (i) {
                            ws(i, n, e)
                        }
                    }
                    return n.return
                } catch (t) {
                    ss["a"].rethrowUnexpectedError(t, this)
                }
            },
            delegate(...t) {
                return {
                    to: (e, n) => {
                        if (!this._delegations) {
                            this._delegations = new Map
                        }
                        t.forEach((t => {
                            const o = this._delegations.get(t);
                            if (!o) {
                                this._delegations.set(t, new Map([
                                    [e, n]
                                ]))
                            } else {
                                o.set(e, n)
                            }
                        }))
                    }
                }
            },
            stopDelegating(t, e) {
                if (!this._delegations) {
                    return
                }
                if (!t) {
                    this._delegations.clear()
                } else if (!e) {
                    this._delegations.delete(t)
                } else {
                    const n = this._delegations.get(t);
                    if (n) {
                        n.delete(e)
                    }
                }
            }
        };
        var ds = ls;

        function us(t, e) {
            if (t[as] && t[as][e]) {
                return t[as][e].emitter
            }
            return null
        }

        function hs(t, e) {
            if (!t[cs]) {
                t[cs] = e || ns()
            }
        }

        function fs(t) {
            return t[cs]
        }

        function ps(t) {
            if (!t._events) {
                Object.defineProperty(t, "_events", {
                    value: {}
                })
            }
            return t._events
        }

        function ms() {
            return {
                callbacks: [],
                childEvents: []
            }
        }

        function gs(t, e) {
            const n = ps(t);
            if (n[e]) {
                return
            }
            let o = e;
            let i = null;
            const r = [];
            while (o !== "") {
                if (n[o]) {
                    break
                }
                n[o] = ms();
                r.push(n[o]);
                if (i) {
                    n[o].childEvents.push(i)
                }
                i = o;
                o = o.substr(0, o.lastIndexOf(":"))
            }
            if (o !== "") {
                for (const t of r) {
                    t.callbacks = n[o].callbacks.slice()
                }
                n[o].childEvents.push(i)
            }
        }

        function ks(t, e) {
            const n = ps(t)[e];
            if (!n) {
                return []
            }
            let o = [n.callbacks];
            for (let e = 0; e < n.childEvents.length; e++) {
                const i = ks(t, n.childEvents[e]);
                o = o.concat(i)
            }
            return o
        }

        function bs(t, e) {
            let n;
            if (!t._events || !(n = t._events[e]) || !n.callbacks.length) {
                if (e.indexOf(":") > -1) {
                    return bs(t, e.substr(0, e.lastIndexOf(":")))
                } else {
                    return null
                }
            }
            return n.callbacks
        }

        function ws(t, e, n) {
            for (let [o, i] of t) {
                if (!i) {
                    i = e.name
                } else if (typeof i == "function") {
                    i = i(e.name)
                }
                const t = new ts(e.source, i);
                t.path = [...e.path];
                o.fire(t, ...n)
            }
        }

        function As(t, e, n) {
            const o = ks(t, e);
            for (const t of o) {
                for (let e = 0; e < t.length; e++) {
                    if (t[e].callback == n) {
                        t.splice(e, 1);
                        e--
                    }
                }
            }
        }

        function Cs(t) {
            return !!(t && t[Symbol.iterator])
        }

        function _s(t, ...e) {
            e.forEach((e => {
                Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e)).forEach((n => {
                    if (n in t.prototype) {
                        return
                    }
                    const o = Object.getOwnPropertyDescriptor(e, n);
                    o.enumerable = false;
                    Object.defineProperty(t.prototype, n, o)
                }))
            }))
        }
        class vs {
            constructor(t = {}, e = {}) {
                const n = Cs(t);
                if (!n) {
                    e = t
                }
                this._items = [];
                this._itemMap = new Map;
                this._idProperty = e.idProperty || "id";
                this._bindToExternalToInternalMap = new WeakMap;
                this._bindToInternalToExternalMap = new WeakMap;
                this._skippedIndexesFromExternal = [];
                if (n) {
                    for (const e of t) {
                        this._items.push(e);
                        this._itemMap.set(this._getItemIdBeforeAdding(e), e)
                    }
                }
            }
            get length() {
                return this._items.length
            }
            get first() {
                return this._items[0] || null
            }
            get last() {
                return this._items[this.length - 1] || null
            }
            add(t, e) {
                return this.addMany([t], e)
            }
            addMany(t, e) {
                if (e === undefined) {
                    e = this._items.length
                } else if (e > this._items.length || e < 0) {
                    throw new ss["a"]("collection-add-item-invalid-index", this)
                }
                for (let n = 0; n < t.length; n++) {
                    const o = t[n];
                    const i = this._getItemIdBeforeAdding(o);
                    const r = e + n;
                    this._items.splice(r, 0, o);
                    this._itemMap.set(i, o);
                    this.fire("add", o, r)
                }
                this.fire("change", {
                    added: t,
                    removed: [],
                    index: e
                });
                return this
            }
            get(t) {
                let e;
                if (typeof t == "string") {
                    e = this._itemMap.get(t)
                } else if (typeof t == "number") {
                    e = this._items[t]
                } else {
                    throw new ss["a"]("collection-get-invalid-arg", this)
                }
                return e || null
            }
            has(t) {
                if (typeof t == "string") {
                    return this._itemMap.has(t)
                } else {
                    const e = this._idProperty;
                    const n = t[e];
                    return this._itemMap.has(n)
                }
            }
            getIndex(t) {
                let e;
                if (typeof t == "string") {
                    e = this._itemMap.get(t)
                } else {
                    e = t
                }
                return this._items.indexOf(e)
            }
            remove(t) {
                const [e, n] = this._remove(t);
                this.fire("change", {
                    added: [],
                    removed: [e],
                    index: n
                });
                return e
            }
            map(t, e) {
                return this._items.map(t, e)
            }
            find(t, e) {
                return this._items.find(t, e)
            }
            filter(t, e) {
                return this._items.filter(t, e)
            }
            clear() {
                if (this._bindToCollection) {
                    this.stopListening(this._bindToCollection);
                    this._bindToCollection = null
                }
                const t = Array.from(this._items);
                while (this.length) {
                    this._remove(0)
                }
                this.fire("change", {
                    added: [],
                    removed: t,
                    index: 0
                })
            }
            bindTo(t) {
                if (this._bindToCollection) {
                    throw new ss["a"]("collection-bind-to-rebind", this)
                }
                this._bindToCollection = t;
                return {
                    as: t => {
                        this._setUpBindToBinding((e => new t(e)))
                    },
                    using: t => {
                        if (typeof t == "function") {
                            this._setUpBindToBinding((e => t(e)))
                        } else {
                            this._setUpBindToBinding((e => e[t]))
                        }
                    }
                }
            }
            _setUpBindToBinding(t) {
                const e = this._bindToCollection;
                const n = (n, o, i) => {
                    const r = e._bindToCollection == this;
                    const s = e._bindToInternalToExternalMap.get(o);
                    if (r && s) {
                        this._bindToExternalToInternalMap.set(o, s);
                        this._bindToInternalToExternalMap.set(s, o)
                    } else {
                        const n = t(o);
                        if (!n) {
                            this._skippedIndexesFromExternal.push(i);
                            return
                        }
                        let r = i;
                        for (const t of this._skippedIndexesFromExternal) {
                            if (i > t) {
                                r--
                            }
                        }
                        for (const t of e._skippedIndexesFromExternal) {
                            if (r >= t) {
                                r++
                            }
                        }
                        this._bindToExternalToInternalMap.set(o, n);
                        this._bindToInternalToExternalMap.set(n, o);
                        this.add(n, r);
                        for (let t = 0; t < e._skippedIndexesFromExternal.length; t++) {
                            if (r <= e._skippedIndexesFromExternal[t]) {
                                e._skippedIndexesFromExternal[t]++
                            }
                        }
                    }
                };
                for (const t of e) {
                    n(null, t, e.getIndex(t))
                }
                this.listenTo(e, "add", n);
                this.listenTo(e, "remove", ((t, e, n) => {
                    const o = this._bindToExternalToInternalMap.get(e);
                    if (o) {
                        this.remove(o)
                    }
                    this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce(((t, e) => {
                        if (n < e) {
                            t.push(e - 1)
                        }
                        if (n > e) {
                            t.push(e)
                        }
                        return t
                    }), [])
                }))
            }
            _getItemIdBeforeAdding(t) {
                const e = this._idProperty;
                let n;
                if (e in t) {
                    n = t[e];
                    if (typeof n != "string") {
                        throw new ss["a"]("collection-add-invalid-id", this)
                    }
                    if (this.get(n)) {
                        throw new ss["a"]("collection-add-item-already-exists", this)
                    }
                } else {
                    t[e] = n = ns()
                }
                return n
            }
            _remove(t) {
                let e, n, o;
                let i = false;
                const r = this._idProperty;
                if (typeof t == "string") {
                    n = t;
                    o = this._itemMap.get(n);
                    i = !o;
                    if (o) {
                        e = this._items.indexOf(o)
                    }
                } else if (typeof t == "number") {
                    e = t;
                    o = this._items[e];
                    i = !o;
                    if (o) {
                        n = o[r]
                    }
                } else {
                    o = t;
                    n = o[r];
                    e = this._items.indexOf(o);
                    i = e == -1 || !this._itemMap.get(n)
                }
                if (i) {
                    throw new ss["a"]("collection-remove-404", this)
                }
                this._items.splice(e, 1);
                this._itemMap.delete(n);
                const s = this._bindToInternalToExternalMap.get(o);
                this._bindToInternalToExternalMap.delete(o);
                this._bindToExternalToInternalMap.delete(s);
                this.fire("remove", o, e);
                return [o, e]
            } [Symbol.iterator]() {
                return this._items[Symbol.iterator]()
            }
        }
        _s(vs, ds);
        class ys {
            constructor(t, e = [], n = []) {
                this._context = t;
                this._plugins = new Map;
                this._availablePlugins = new Map;
                for (const t of e) {
                    if (t.pluginName) {
                        this._availablePlugins.set(t.pluginName, t)
                    }
                }
                this._contextPlugins = new Map;
                for (const [t, e] of n) {
                    this._contextPlugins.set(t, e);
                    this._contextPlugins.set(e, t);
                    if (t.pluginName) {
                        this._availablePlugins.set(t.pluginName, t)
                    }
                }
            }*[Symbol.iterator]() {
                for (const t of this._plugins) {
                    if (typeof t[0] == "function") {
                        yield t
                    }
                }
            }
            get(t) {
                const e = this._plugins.get(t);
                if (!e) {
                    let e = t;
                    if (typeof t == "function") {
                        e = t.pluginName || t.name
                    }
                    throw new ss["a"]("plugincollection-plugin-not-loaded", this._context, {
                        plugin: e
                    })
                }
                return e
            }
            has(t) {
                return this._plugins.has(t)
            }
            init(t, e = []) {
                const n = this;
                const o = this._context;
                const i = new Set;
                const r = [];
                const s = p(t);
                const a = p(e);
                const c = f(t);
                if (c) {
                    const t = "plugincollection-plugin-not-found";
                    Object(ss["b"])(t, {
                        plugins: c
                    });
                    return Promise.reject(new ss["a"](t, o, {
                        plugins: c
                    }))
                }
                return Promise.all(s.map(l)).then((() => d(r, "init"))).then((() => d(r, "afterInit"))).then((() => r));

                function l(t) {
                    if (a.includes(t)) {
                        return
                    }
                    if (n._plugins.has(t) || i.has(t)) {
                        return
                    }
                    return u(t).catch((e => {
                        Object(ss["b"])("plugincollection-load", {
                            plugin: t
                        });
                        throw e
                    }))
                }

                function d(t, e) {
                    return t.reduce(((t, o) => {
                        if (!o[e]) {
                            return t
                        }
                        if (n._contextPlugins.has(o)) {
                            return t
                        }
                        return t.then(o[e].bind(o))
                    }), Promise.resolve())
                }

                function u(t) {
                    return new Promise((s => {
                        i.add(t);
                        if (t.requires) {
                            t.requires.forEach((n => {
                                const i = h(n);
                                if (t.isContextPlugin && !i.isContextPlugin) {
                                    throw new ss["a"]("plugincollection-context-required", null, {
                                        plugin: i.name,
                                        requiredBy: t.name
                                    })
                                }
                                if (e.includes(i)) {
                                    throw new ss["a"]("plugincollection-required", o, {
                                        plugin: i.name,
                                        requiredBy: t.name
                                    })
                                }
                                l(i)
                            }))
                        }
                        const a = n._contextPlugins.get(t) || new t(o);
                        n._add(t, a);
                        r.push(a);
                        s()
                    }))
                }

                function h(t) {
                    if (typeof t == "function") {
                        return t
                    }
                    return n._availablePlugins.get(t)
                }

                function f(t) {
                    const e = [];
                    for (const n of t) {
                        if (!h(n)) {
                            e.push(n)
                        }
                    }
                    return e.length ? e : null
                }

                function p(t) {
                    return t.map((t => h(t))).filter((t => !!t))
                }
            }
            destroy() {
                const t = [];
                for (const [, e] of this) {
                    if (typeof e.destroy == "function" && !this._contextPlugins.has(e)) {
                        t.push(e.destroy())
                    }
                }
                return Promise.all(t)
            }
            _add(t, e) {
                this._plugins.set(t, e);
                const n = t.pluginName;
                if (!n) {
                    return
                }
                if (this._plugins.has(n)) {
                    throw new ss["a"]("plugincollection-plugin-name-conflict", null, {
                        pluginName: n,
                        plugin1: this._plugins.get(n).constructor,
                        plugin2: t
                    })
                }
                this._plugins.set(n, e)
            }
        }
        _s(ys, ds);

        function xs(t) {
            return Array.isArray(t) ? t : [t]
        }
        if (!window.CKEDITOR_TRANSLATIONS) {
            window.CKEDITOR_TRANSLATIONS = {}
        }

        function Ds(t, e, n) {
            if (!window.CKEDITOR_TRANSLATIONS[t]) {
                window.CKEDITOR_TRANSLATIONS[t] = {}
            }
            const o = window.CKEDITOR_TRANSLATIONS[t];
            o.dictionary = o.dictionary || {};
            o.getPluralForm = n || o.getPluralForm;
            Object.assign(o.dictionary, e)
        }

        function Ms(t, e, n = 1) {
            if (typeof n !== "number") {
                throw new ss["a"]("translation-service-quantity-not-a-number", null, {
                    quantity: n
                })
            }
            const o = Ts();
            if (o === 1) {
                t = Object.keys(window.CKEDITOR_TRANSLATIONS)[0]
            }
            const i = e.id || e.string;
            if (o === 0 || !Ss(t, i)) {
                if (n !== 1) {
                    return e.plural
                }
                return e.string
            }
            const r = window.CKEDITOR_TRANSLATIONS[t].dictionary;
            const s = window.CKEDITOR_TRANSLATIONS[t].getPluralForm || (t => t === 1 ? 0 : 1);
            if (typeof r[i] === "string") {
                return r[i]
            }
            const a = Number(s(n));
            return r[i][a]
        }

        function Es() {
            window.CKEDITOR_TRANSLATIONS = {}
        }

        function Ss(t, e) {
            return !!window.CKEDITOR_TRANSLATIONS[t] && !!window.CKEDITOR_TRANSLATIONS[t].dictionary[e]
        }

        function Ts() {
            return Object.keys(window.CKEDITOR_TRANSLATIONS).length
        }
        const Is = ["ar", "fa", "he", "ku", "ug"];
        class Ns {
            constructor(t = {}) {
                this.uiLanguage = t.uiLanguage || "en";
                this.contentLanguage = t.contentLanguage || this.uiLanguage;
                this.uiLanguageDirection = Bs(this.uiLanguage);
                this.contentLanguageDirection = Bs(this.contentLanguage);
                this.t = (t, e) => this._t(t, e)
            }
            get language() {
                console.warn("locale-deprecated-language-property: " + "The Locale#language property has been deprecated and will be removed in the near future. " + "Please use #uiLanguage and #contentLanguage properties instead.");
                return this.uiLanguage
            }
            _t(t, e = []) {
                e = xs(e);
                if (typeof t === "string") {
                    t = {
                        string: t
                    }
                }
                const n = !!t.plural;
                const o = n ? e[0] : 1;
                const i = Ms(this.uiLanguage, t, o);
                return Ps(i, e)
            }
        }

        function Ps(t, e) {
            return t.replace(/%(\d+)/g, ((t, n) => n < e.length ? e[n] : t))
        }

        function Bs(t) {
            return Is.includes(t) ? "rtl" : "ltr"
        }
        class Ls {
            constructor(t) {
                this.config = new Qr(t, this.constructor.defaultConfig);
                const e = this.constructor.builtinPlugins;
                this.config.define("plugins", e);
                this.plugins = new ys(this, e);
                const n = this.config.get("language") || {};
                this.locale = new Ns({
                    uiLanguage: typeof n === "string" ? n : n.ui,
                    contentLanguage: this.config.get("language.content")
                });
                this.t = this.locale.t;
                this.editors = new vs;
                this._contextOwner = null
            }
            initPlugins() {
                const t = this.config.get("plugins") || [];
                for (const e of t) {
                    if (typeof e != "function") {
                        throw new ss["a"]("context-initplugins-constructor-only", null, {
                            Plugin: e
                        })
                    }
                    if (e.isContextPlugin !== true) {
                        throw new ss["a"]("context-initplugins-invalid-plugin", null, {
                            Plugin: e
                        })
                    }
                }
                return this.plugins.init(t)
            }
            destroy() {
                return Promise.all(Array.from(this.editors, (t => t.destroy()))).then((() => this.plugins.destroy()))
            }
            _addEditor(t, e) {
                if (this._contextOwner) {
                    throw new ss["a"]("context-addeditor-private-context")
                }
                this.editors.add(t);
                if (e) {
                    this._contextOwner = t
                }
            }
            _removeEditor(t) {
                if (this.editors.has(t)) {
                    this.editors.remove(t)
                }
                if (this._contextOwner === t) {
                    return this.destroy()
                }
                return Promise.resolve()
            }
            _getEditorConfig() {
                const t = {};
                for (const e of this.config.names()) {
                    if (!["plugins", "removePlugins", "extraPlugins"].includes(e)) {
                        t[e] = this.config.get(e)
                    }
                }
                return t
            }
            static create(t) {
                return new Promise((e => {
                    const n = new this(t);
                    e(n.initPlugins().then((() => n)))
                }))
            }
        }

        function Os(t, e) {
            const n = Math.min(t.length, e.length);
            for (let o = 0; o < n; o++) {
                if (t[o] != e[o]) {
                    return o
                }
            }
            if (t.length == e.length) {
                return "same"
            } else if (t.length < e.length) {
                return "prefix"
            } else {
                return "extension"
            }
        }
        var zs = 4;

        function js(t) {
            return Ur(t, zs)
        }
        var Fs = js;
        class Rs {
            constructor(t) {
                this.document = t;
                this.parent = null
            }
            get index() {
                let t;
                if (!this.parent) {
                    return null
                }
                if ((t = this.parent.getChildIndex(this)) == -1) {
                    throw new ss["a"]("view-node-not-found-in-parent", this)
                }
                return t
            }
            get nextSibling() {
                const t = this.index;
                return t !== null && this.parent.getChild(t + 1) || null
            }
            get previousSibling() {
                const t = this.index;
                return t !== null && this.parent.getChild(t - 1) || null
            }
            get root() {
                let t = this;
                while (t.parent) {
                    t = t.parent
                }
                return t
            }
            isAttached() {
                return this.root.is("rootElement")
            }
            getPath() {
                const t = [];
                let e = this;
                while (e.parent) {
                    t.unshift(e.index);
                    e = e.parent
                }
                return t
            }
            getAncestors(t = {
                includeSelf: false,
                parentFirst: false
            }) {
                const e = [];
                let n = t.includeSelf ? this : this.parent;
                while (n) {
                    e[t.parentFirst ? "push" : "unshift"](n);
                    n = n.parent
                }
                return e
            }
            getCommonAncestor(t, e = {}) {
                const n = this.getAncestors(e);
                const o = t.getAncestors(e);
                let i = 0;
                while (n[i] == o[i] && n[i]) {
                    i++
                }
                return i === 0 ? null : n[i - 1]
            }
            isBefore(t) {
                if (this == t) {
                    return false
                }
                if (this.root !== t.root) {
                    return false
                }
                const e = this.getPath();
                const n = t.getPath();
                const o = Os(e, n);
                switch (o) {
                    case "prefix":
                        return true;
                    case "extension":
                        return false;
                    default:
                        return e[o] < n[o]
                }
            }
            isAfter(t) {
                if (this == t) {
                    return false
                }
                if (this.root !== t.root) {
                    return false
                }
                return !this.isBefore(t)
            }
            _remove() {
                this.parent._removeChildren(this.index)
            }
            _fireChange(t, e) {
                this.fire("change:" + t, e);
                if (this.parent) {
                    this.parent._fireChange(t, e)
                }
            }
            toJSON() {
                const t = Fs(this);
                delete t.parent;
                return t
            }
            is(t) {
                return t === "node" || t === "view:node"
            }
        }
        _s(Rs, ds);
        class Vs extends Rs {
            constructor(t, e) {
                super(t);
                this._textData = e
            }
            is(t) {
                return t === "$text" || t === "view:$text" || t === "text" || t === "view:text" || t === "node" || t === "view:node"
            }
            get data() {
                return this._textData
            }
            get _data() {
                return this.data
            }
            set _data(t) {
                this._fireChange("text", this);
                this._textData = t
            }
            isSimilar(t) {
                if (!(t instanceof Vs)) {
                    return false
                }
                return this === t || this.data === t.data
            }
            _clone() {
                return new Vs(this.document, this.data)
            }
        }
        class Us {
            constructor(t, e, n) {
                this.textNode = t;
                if (e < 0 || e > t.data.length) {
                    throw new ss["a"]("view-textproxy-wrong-offsetintext", this)
                }
                if (n < 0 || e + n > t.data.length) {
                    throw new ss["a"]("view-textproxy-wrong-length", this)
                }
                this.data = t.data.substring(e, e + n);
                this.offsetInText = e
            }
            get offsetSize() {
                return this.data.length
            }
            get isPartial() {
                return this.data.length !== this.textNode.data.length
            }
            get parent() {
                return this.textNode.parent
            }
            get root() {
                return this.textNode.root
            }
            get document() {
                return this.textNode.document
            }
            is(t) {
                return t === "$textProxy" || t === "view:$textProxy" || t === "textProxy" || t === "view:textProxy"
            }
            getAncestors(t = {
                includeSelf: false,
                parentFirst: false
            }) {
                const e = [];
                let n = t.includeSelf ? this.textNode : this.parent;
                while (n !== null) {
                    e[t.parentFirst ? "push" : "unshift"](n);
                    n = n.parent
                }
                return e
            }
        }

        function Gs(t) {
            const e = new Map;
            for (const n in t) {
                e.set(n, t[n])
            }
            return e
        }

        function Ks(t) {
            if (Cs(t)) {
                return new Map(t)
            } else {
                return Gs(t)
            }
        }
        class Ys {
            constructor(...t) {
                this._patterns = [];
                this.add(...t)
            }
            add(...t) {
                for (let e of t) {
                    if (typeof e == "string" || e instanceof RegExp) {
                        e = {
                            name: e
                        }
                    }
                    if (e.classes && (typeof e.classes == "string" || e.classes instanceof RegExp)) {
                        e.classes = [e.classes]
                    }
                    this._patterns.push(e)
                }
            }
            match(...t) {
                for (const e of t) {
                    for (const t of this._patterns) {
                        const n = Hs(e, t);
                        if (n) {
                            return {
                                element: e,
                                pattern: t,
                                match: n
                            }
                        }
                    }
                }
                return null
            }
            matchAll(...t) {
                const e = [];
                for (const n of t) {
                    for (const t of this._patterns) {
                        const o = Hs(n, t);
                        if (o) {
                            e.push({
                                element: n,
                                pattern: t,
                                match: o
                            })
                        }
                    }
                }
                return e.length > 0 ? e : null
            }
            getElementName() {
                if (this._patterns.length !== 1) {
                    return null
                }
                const t = this._patterns[0];
                const e = t.name;
                return typeof t != "function" && e && !(e instanceof RegExp) ? e : null
            }
        }

        function Hs(t, e) {
            if (typeof e == "function") {
                return e(t)
            }
            const n = {};
            if (e.name) {
                n.name = qs(e.name, t.name);
                if (!n.name) {
                    return null
                }
            }
            if (e.attributes) {
                n.attributes = Ws(e.attributes, t);
                if (!n.attributes) {
                    return null
                }
            }
            if (e.classes) {
                n.classes = Qs(e.classes, t);
                if (!n.classes) {
                    return false
                }
            }
            if (e.styles) {
                n.styles = $s(e.styles, t);
                if (!n.styles) {
                    return false
                }
            }
            return n
        }

        function qs(t, e) {
            if (t instanceof RegExp) {
                return t.test(e)
            }
            return t === e
        }

        function Ws(t, e) {
            const n = [];
            for (const o in t) {
                const i = t[o];
                if (e.hasAttribute(o)) {
                    const t = e.getAttribute(o);
                    if (i === true) {
                        n.push(o)
                    } else if (i instanceof RegExp) {
                        if (i.test(t)) {
                            n.push(o)
                        } else {
                            return null
                        }
                    } else if (t === i) {
                        n.push(o)
                    } else {
                        return null
                    }
                } else {
                    return null
                }
            }
            return n
        }

        function Qs(t, e) {
            const n = [];
            for (const o of t) {
                if (o instanceof RegExp) {
                    const t = e.getClassNames();
                    for (const e of t) {
                        if (o.test(e)) {
                            n.push(e)
                        }
                    }
                    if (n.length === 0) {
                        return null
                    }
                } else if (e.hasClass(o)) {
                    n.push(o)
                } else {
                    return null
                }
            }
            return n
        }

        function $s(t, e) {
            const n = [];
            for (const o in t) {
                const i = t[o];
                if (e.hasStyle(o)) {
                    const t = e.getStyle(o);
                    if (i instanceof RegExp) {
                        if (i.test(t)) {
                            n.push(o)
                        } else {
                            return null
                        }
                    } else if (t === i) {
                        n.push(o)
                    } else {
                        return null
                    }
                } else {
                    return null
                }
            }
            return n
        }
        var Zs = "[object Symbol]";

        function Js(t) {
            return typeof t == "symbol" || D(t) && A(t) == Zs
        }
        var Xs = Js;
        var ta = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
            ea = /^\w*$/;

        function na(t, e) {
            if (Qe(t)) {
                return false
            }
            var n = typeof t;
            if (n == "number" || n == "symbol" || n == "boolean" || t == null || Xs(t)) {
                return true
            }
            return ea.test(t) || !ta.test(t) || e != null && t in Object(e)
        }
        var oa = na;
        var ia = "Expected a function";

        function ra(t, e) {
            if (typeof t != "function" || e != null && typeof e != "function") {
                throw new TypeError(ia)
            }
            var n = function() {
                var o = arguments,
                    i = e ? e.apply(this, o) : o[0],
                    r = n.cache;
                if (r.has(i)) {
                    return r.get(i)
                }
                var s = t.apply(this, o);
                n.cache = r.set(i, s) || r;
                return s
            };
            n.cache = new(ra.Cache || Ae);
            return n
        }
        ra.Cache = Ae;
        var sa = ra;
        var aa = 500;

        function ca(t) {
            var e = sa(t, (function(t) {
                if (n.size === aa) {
                    n.clear()
                }
                return t
            }));
            var n = e.cache;
            return e
        }
        var la = ca;
        var da = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var ua = /\\(\\)?/g;
        var ha = la((function(t) {
            var e = [];
            if (t.charCodeAt(0) === 46) {
                e.push("")
            }
            t.replace(da, (function(t, n, o, i) {
                e.push(o ? i.replace(ua, "$1") : n || t)
            }));
            return e
        }));
        var fa = ha;

        function pa(t, e) {
            var n = -1,
                o = t == null ? 0 : t.length,
                i = Array(o);
            while (++n < o) {
                i[n] = e(t[n], n, t)
            }
            return i
        }
        var ma = pa;
        var ga = 1 / 0;
        var ka = r ? r.prototype : undefined,
            ba = ka ? ka.toString : undefined;

        function wa(t) {
            if (typeof t == "string") {
                return t
            }
            if (Qe(t)) {
                return ma(t, wa) + ""
            }
            if (Xs(t)) {
                return ba ? ba.call(t) : ""
            }
            var e = t + "";
            return e == "0" && 1 / t == -ga ? "-0" : e
        }
        var Aa = wa;

        function Ca(t) {
            return t == null ? "" : Aa(t)
        }
        var _a = Ca;

        function va(t, e) {
            if (Qe(t)) {
                return t
            }
            return oa(t, e) ? [t] : fa(_a(t))
        }
        var ya = va;

        function xa(t) {
            var e = t == null ? 0 : t.length;
            return e ? t[e - 1] : undefined
        }
        var Da = xa;
        var Ma = 1 / 0;

        function Ea(t) {
            if (typeof t == "string" || Xs(t)) {
                return t
            }
            var e = t + "";
            return e == "0" && 1 / t == -Ma ? "-0" : e
        }
        var Sa = Ea;

        function Ta(t, e) {
            e = ya(e, t);
            var n = 0,
                o = e.length;
            while (t != null && n < o) {
                t = t[Sa(e[n++])]
            }
            return n && n == o ? t : undefined
        }
        var Ia = Ta;

        function Na(t, e, n) {
            var o = -1,
                i = t.length;
            if (e < 0) {
                e = -e > i ? 0 : i + e
            }
            n = n > i ? i : n;
            if (n < 0) {
                n += i
            }
            i = e > n ? 0 : n - e >>> 0;
            e >>>= 0;
            var r = Array(i);
            while (++o < i) {
                r[o] = t[o + e]
            }
            return r
        }
        var Pa = Na;

        function Ba(t, e) {
            return e.length < 2 ? t : Ia(t, Pa(e, 0, -1))
        }
        var La = Ba;

        function Oa(t, e) {
            e = ya(e, t);
            t = La(t, e);
            return t == null || delete t[Sa(Da(e))]
        }
        var za = Oa;

        function ja(t, e) {
            return t == null ? true : za(t, e)
        }
        var Fa = ja;

        function Ra(t, e, n) {
            var o = t == null ? undefined : Ia(t, e);
            return o === undefined ? n : o
        }
        var Va = Ra;

        function Ua(t, e, n) {
            if (n !== undefined && !j(t[e], n) || n === undefined && !(e in t)) {
                Ie(t, e, n)
            }
        }
        var Ga = Ua;

        function Ka(t) {
            return function(e, n, o) {
                var i = -1,
                    r = Object(e),
                    s = o(e),
                    a = s.length;
                while (a--) {
                    var c = s[t ? a : ++i];
                    if (n(r[c], c, r) === false) {
                        break
                    }
                }
                return e
            }
        }
        var Ya = Ka;
        var Ha = Ya();
        var qa = Ha;

        function Wa(t) {
            return D(t) && Jn(t)
        }
        var Qa = Wa;

        function $a(t, e) {
            if (e === "constructor" && typeof t[e] === "function") {
                return
            }
            if (e == "__proto__") {
                return
            }
            return t[e]
        }
        var Za = $a;

        function Ja(t) {
            return ze(t, uo(t))
        }
        var Xa = Ja;

        function tc(t, e, n, o, i, r, s) {
            var a = Za(t, n),
                c = Za(e, n),
                l = s.get(c);
            if (l) {
                Ga(t, n, l);
                return
            }
            var d = r ? r(a, c, n + "", t, e, s) : undefined;
            var u = d === undefined;
            if (u) {
                var h = Qe(c),
                    f = !h && Object($e["a"])(c),
                    p = !h && !f && zn(c);
                d = c;
                if (h || f || p) {
                    if (Qe(a)) {
                        d = a
                    } else if (Qa(a)) {
                        d = go(a)
                    } else if (f) {
                        u = false;
                        d = Object(po["a"])(c, true)
                    } else if (p) {
                        u = false;
                        d = Di(c, true)
                    } else {
                        d = []
                    }
                } else if (B(c) || qe(c)) {
                    d = a;
                    if (qe(a)) {
                        d = Xa(a)
                    } else if (!ct(a) || pt(a)) {
                        d = Ji(c)
                    }
                } else {
                    u = false
                }
            }
            if (u) {
                s.set(c, d);
                i(d, c, o, r, s);
                s["delete"](c)
            }
            Ga(t, n, d)
        }
        var ec = tc;

        function nc(t, e, n, o, i) {
            if (t === e) {
                return
            }
            qa(e, (function(r, s) {
                i || (i = new xe);
                if (ct(r)) {
                    ec(t, e, s, n, nc, o, i)
                } else {
                    var a = o ? o(Za(t, s), r, s + "", t, e, i) : undefined;
                    if (a === undefined) {
                        a = r
                    }
                    Ga(t, s, a)
                }
            }), uo)
        }
        var oc = nc;

        function ic(t) {
            return t
        }
        var rc = ic;

        function sc(t, e, n) {
            switch (n.length) {
                case 0:
                    return t.call(e);
                case 1:
                    return t.call(e, n[0]);
                case 2:
                    return t.call(e, n[0], n[1]);
                case 3:
                    return t.call(e, n[0], n[1], n[2])
            }
            return t.apply(e, n)
        }
        var ac = sc;
        var cc = Math.max;

        function lc(t, e, n) {
            e = cc(e === undefined ? t.length - 1 : e, 0);
            return function() {
                var o = arguments,
                    i = -1,
                    r = cc(o.length - e, 0),
                    s = Array(r);
                while (++i < r) {
                    s[i] = o[e + i]
                }
                i = -1;
                var a = Array(e + 1);
                while (++i < e) {
                    a[i] = o[i]
                }
                a[e] = n(s);
                return ac(t, this, a)
            }
        }
        var dc = lc;

        function uc(t) {
            return function() {
                return t
            }
        }
        var hc = uc;
        var fc = !Se ? rc : function(t, e) {
            return Se(t, "toString", {
                configurable: true,
                enumerable: false,
                value: hc(e),
                writable: true
            })
        };
        var pc = fc;
        var mc = 800,
            gc = 16;
        var kc = Date.now;

        function bc(t) {
            var e = 0,
                n = 0;
            return function() {
                var o = kc(),
                    i = gc - (o - n);
                n = o;
                if (i > 0) {
                    if (++e >= mc) {
                        return arguments[0]
                    }
                } else {
                    e = 0
                }
                return t.apply(undefined, arguments)
            }
        }
        var wc = bc;
        var Ac = wc(pc);
        var Cc = Ac;

        function _c(t, e) {
            return Cc(dc(t, e, rc), t + "")
        }
        var vc = _c;

        function yc(t, e, n) {
            if (!ct(n)) {
                return false
            }
            var o = typeof e;
            if (o == "number" ? Jn(n) && tn(e, n.length) : o == "string" && e in n) {
                return j(n[e], t)
            }
            return false
        }
        var xc = yc;

        function Dc(t) {
            return vc((function(e, n) {
                var o = -1,
                    i = n.length,
                    r = i > 1 ? n[i - 1] : undefined,
                    s = i > 2 ? n[2] : undefined;
                r = t.length > 3 && typeof r == "function" ? (i--, r) : undefined;
                if (s && xc(n[0], n[1], s)) {
                    r = i < 3 ? undefined : r;
                    i = 1
                }
                e = Object(e);
                while (++o < i) {
                    var a = n[o];
                    if (a) {
                        t(e, a, o, r)
                    }
                }
                return e
            }))
        }
        var Mc = Dc;
        var Ec = Mc((function(t, e, n) {
            oc(t, e, n)
        }));
        var Sc = Ec;

        function Tc(t, e, n, o) {
            if (!ct(t)) {
                return t
            }
            e = ya(e, t);
            var i = -1,
                r = e.length,
                s = r - 1,
                a = t;
            while (a != null && ++i < r) {
                var c = Sa(e[i]),
                    l = n;
                if (i != s) {
                    var d = a[c];
                    l = o ? o(d, c, a) : undefined;
                    if (l === undefined) {
                        l = ct(d) ? d : tn(e[i + 1]) ? [] : {}
                    }
                }
                Le(a, c, l);
                a = a[c]
            }
            return t
        }
        var Ic = Tc;

        function Nc(t, e, n) {
            return t == null ? t : Ic(t, e, n)
        }
        var Pc = Nc;
        class Bc {
            constructor(t) {
                this._styles = {};
                this._styleProcessor = t
            }
            get isEmpty() {
                const t = Object.entries(this._styles);
                const e = Array.from(t);
                return !e.length
            }
            get size() {
                if (this.isEmpty) {
                    return 0
                }
                return this.getStyleNames().length
            }
            setTo(t) {
                this.clear();
                const e = Array.from(Oc(t).entries());
                for (const [t, n] of e) {
                    this._styleProcessor.toNormalizedForm(t, n, this._styles)
                }
            }
            has(t) {
                if (this.isEmpty) {
                    return false
                }
                const e = this._styleProcessor.getReducedForm(t, this._styles);
                const n = e.find((([e]) => e === t));
                return Array.isArray(n)
            }
            set(t, e) {
                if (ct(t)) {
                    for (const [e, n] of Object.entries(t)) {
                        this._styleProcessor.toNormalizedForm(e, n, this._styles)
                    }
                } else {
                    this._styleProcessor.toNormalizedForm(t, e, this._styles)
                }
            }
            remove(t) {
                const e = zc(t);
                Fa(this._styles, e);
                delete this._styles[t];
                this._cleanEmptyObjectsOnPath(e)
            }
            getNormalized(t) {
                return this._styleProcessor.getNormalized(t, this._styles)
            }
            toString() {
                if (this.isEmpty) {
                    return ""
                }
                return this._getStylesEntries().map((t => t.join(":"))).sort().join(";") + ";"
            }
            getAsString(t) {
                if (this.isEmpty) {
                    return
                }
                if (this._styles[t] && !ct(this._styles[t])) {
                    return this._styles[t]
                }
                const e = this._styleProcessor.getReducedForm(t, this._styles);
                const n = e.find((([e]) => e === t));
                if (Array.isArray(n)) {
                    return n[1]
                }
            }
            getStyleNames() {
                if (this.isEmpty) {
                    return []
                }
                const t = this._getStylesEntries();
                return t.map((([t]) => t))
            }
            clear() {
                this._styles = {}
            }
            _getStylesEntries() {
                const t = [];
                const e = Object.keys(this._styles);
                for (const n of e) {
                    t.push(...this._styleProcessor.getReducedForm(n, this._styles))
                }
                return t
            }
            _cleanEmptyObjectsOnPath(t) {
                const e = t.split(".");
                const n = e.length > 1;
                if (!n) {
                    return
                }
                const o = e.splice(0, e.length - 1).join(".");
                const i = Va(this._styles, o);
                if (!i) {
                    return
                }
                const r = !Array.from(Object.keys(i)).length;
                if (r) {
                    this.remove(o)
                }
            }
        }
        class Lc {
            constructor() {
                this._normalizers = new Map;
                this._extractors = new Map;
                this._reducers = new Map;
                this._consumables = new Map
            }
            toNormalizedForm(t, e, n) {
                if (ct(e)) {
                    jc(n, zc(t), e);
                    return
                }
                if (this._normalizers.has(t)) {
                    const o = this._normalizers.get(t);
                    const {
                        path: i,
                        value: r
                    } = o(e);
                    jc(n, i, r)
                } else {
                    jc(n, t, e)
                }
            }
            getNormalized(t, e) {
                if (!t) {
                    return Sc({}, e)
                }
                if (e[t] !== undefined) {
                    return e[t]
                }
                if (this._extractors.has(t)) {
                    const n = this._extractors.get(t);
                    if (typeof n === "string") {
                        return Va(e, n)
                    }
                    const o = n(t, e);
                    if (o) {
                        return o
                    }
                }
                return Va(e, zc(t))
            }
            getReducedForm(t, e) {
                const n = this.getNormalized(t, e);
                if (n === undefined) {
                    return []
                }
                if (this._reducers.has(t)) {
                    const e = this._reducers.get(t);
                    return e(n)
                }
                return [
                    [t, n]
                ]
            }
            getRelatedStyles(t) {
                return this._consumables.get(t) || []
            }
            setNormalizer(t, e) {
                this._normalizers.set(t, e)
            }
            setExtractor(t, e) {
                this._extractors.set(t, e)
            }
            setReducer(t, e) {
                this._reducers.set(t, e)
            }
            setStyleRelation(t, e) {
                this._mapStyleNames(t, e);
                for (const n of e) {
                    this._mapStyleNames(n, [t])
                }
            }
            _mapStyleNames(t, e) {
                if (!this._consumables.has(t)) {
                    this._consumables.set(t, [])
                }
                this._consumables.get(t).push(...e)
            }
        }

        function Oc(t) {
            let e = null;
            let n = 0;
            let o = 0;
            let i = null;
            const r = new Map;
            if (t === "") {
                return r
            }
            if (t.charAt(t.length - 1) != ";") {
                t = t + ";"
            }
            for (let s = 0; s < t.length; s++) {
                const a = t.charAt(s);
                if (e === null) {
                    switch (a) {
                        case ":":
                            if (!i) {
                                i = t.substr(n, s - n);
                                o = s + 1
                            }
                            break;
                        case '"':
                        case "'":
                            e = a;
                            break;
                        case ";": {
                            const e = t.substr(o, s - o);
                            if (i) {
                                r.set(i.trim(), e.trim())
                            }
                            i = null;
                            n = s + 1;
                            break
                        }
                    }
                } else if (a === e) {
                    e = null
                }
            }
            return r
        }

        function zc(t) {
            return t.replace("-", ".")
        }

        function jc(t, e, n) {
            let o = n;
            if (ct(n)) {
                o = Sc({}, Va(t, e), n)
            }
            Pc(t, e, o)
        }
        class Fc extends Rs {
            constructor(t, e, n, o) {
                super(t);
                this.name = e;
                this._attrs = Rc(n);
                this._children = [];
                if (o) {
                    this._insertChild(0, o)
                }
                this._classes = new Set;
                if (this._attrs.has("class")) {
                    const t = this._attrs.get("class");
                    Vc(this._classes, t);
                    this._attrs.delete("class")
                }
                this._styles = new Bc(this.document.stylesProcessor);
                if (this._attrs.has("style")) {
                    this._styles.setTo(this._attrs.get("style"));
                    this._attrs.delete("style")
                }
                this._customProperties = new Map
            }
            get childCount() {
                return this._children.length
            }
            get isEmpty() {
                return this._children.length === 0
            }
            is(t, e = null) {
                if (!e) {
                    return t === "element" || t === "view:element" || t === "node" || t === "view:node"
                } else {
                    return e === this.name && (t === "element" || t === "view:element")
                }
            }
            getChild(t) {
                return this._children[t]
            }
            getChildIndex(t) {
                return this._children.indexOf(t)
            }
            getChildren() {
                return this._children[Symbol.iterator]()
            }* getAttributeKeys() {
                if (this._classes.size > 0) {
                    yield "class"
                }
                if (!this._styles.isEmpty) {
                    yield "style"
                }
                yield* this._attrs.keys()
            }* getAttributes() {
                yield* this._attrs.entries();
                if (this._classes.size > 0) {
                    yield ["class", this.getAttribute("class")]
                }
                if (!this._styles.isEmpty) {
                    yield ["style", this.getAttribute("style")]
                }
            }
            getAttribute(t) {
                if (t == "class") {
                    if (this._classes.size > 0) {
                        return [...this._classes].join(" ")
                    }
                    return undefined
                }
                if (t == "style") {
                    const t = this._styles.toString();
                    return t == "" ? undefined : t
                }
                return this._attrs.get(t)
            }
            hasAttribute(t) {
                if (t == "class") {
                    return this._classes.size > 0
                }
                if (t == "style") {
                    return !this._styles.isEmpty
                }
                return this._attrs.has(t)
            }
            isSimilar(t) {
                if (!(t instanceof Fc)) {
                    return false
                }
                if (this === t) {
                    return true
                }
                if (this.name != t.name) {
                    return false
                }
                if (this._attrs.size !== t._attrs.size || this._classes.size !== t._classes.size || this._styles.size !== t._styles.size) {
                    return false
                }
                for (const [e, n] of this._attrs) {
                    if (!t._attrs.has(e) || t._attrs.get(e) !== n) {
                        return false
                    }
                }
                for (const e of this._classes) {
                    if (!t._classes.has(e)) {
                        return false
                    }
                }
                for (const e of this._styles.getStyleNames()) {
                    if (!t._styles.has(e) || t._styles.getAsString(e) !== this._styles.getAsString(e)) {
                        return false
                    }
                }
                return true
            }
            hasClass(...t) {
                for (const e of t) {
                    if (!this._classes.has(e)) {
                        return false
                    }
                }
                return true
            }
            getClassNames() {
                return this._classes.keys()
            }
            getStyle(t) {
                return this._styles.getAsString(t)
            }
            getNormalizedStyle(t) {
                return this._styles.getNormalized(t)
            }
            getStyleNames() {
                return this._styles.getStyleNames()
            }
            hasStyle(...t) {
                for (const e of t) {
                    if (!this._styles.has(e)) {
                        return false
                    }
                }
                return true
            }
            findAncestor(...t) {
                const e = new Ys(...t);
                let n = this.parent;
                while (n) {
                    if (e.match(n)) {
                        return n
                    }
                    n = n.parent
                }
                return null
            }
            getCustomProperty(t) {
                return this._customProperties.get(t)
            }* getCustomProperties() {
                yield* this._customProperties.entries()
            }
            getIdentity() {
                const t = Array.from(this._classes).sort().join(",");
                const e = this._styles.toString();
                const n = Array.from(this._attrs).map((t => `${t[0]}="${t[1]}"`)).sort().join(" ");
                return this.name + (t == "" ? "" : ` class="${t}"`) + (!e ? "" : ` style="${e}"`) + (n == "" ? "" : ` ${n}`)
            }
            _clone(t = false) {
                const e = [];
                if (t) {
                    for (const n of this.getChildren()) {
                        e.push(n._clone(t))
                    }
                }
                const n = new this.constructor(this.document, this.name, this._attrs, e);
                n._classes = new Set(this._classes);
                n._styles.set(this._styles.getNormalized());
                n._customProperties = new Map(this._customProperties);
                n.getFillerOffset = this.getFillerOffset;
                return n
            }
            _appendChild(t) {
                return this._insertChild(this.childCount, t)
            }
            _insertChild(t, e) {
                this._fireChange("children", this);
                let n = 0;
                const o = Uc(this.document, e);
                for (const e of o) {
                    if (e.parent !== null) {
                        e._remove()
                    }
                    e.parent = this;
                    e.document = this.document;
                    this._children.splice(t, 0, e);
                    t++;
                    n++
                }
                return n
            }
            _removeChildren(t, e = 1) {
                this._fireChange("children", this);
                for (let n = t; n < t + e; n++) {
                    this._children[n].parent = null
                }
                return this._children.splice(t, e)
            }
            _setAttribute(t, e) {
                e = String(e);
                this._fireChange("attributes", this);
                if (t == "class") {
                    Vc(this._classes, e)
                } else if (t == "style") {
                    this._styles.setTo(e)
                } else {
                    this._attrs.set(t, e)
                }
            }
            _removeAttribute(t) {
                this._fireChange("attributes", this);
                if (t == "class") {
                    if (this._classes.size > 0) {
                        this._classes.clear();
                        return true
                    }
                    return false
                }
                if (t == "style") {
                    if (!this._styles.isEmpty) {
                        this._styles.clear();
                        return true
                    }
                    return false
                }
                return this._attrs.delete(t)
            }
            _addClass(t) {
                this._fireChange("attributes", this);
                for (const e of xs(t)) {
                    this._classes.add(e)
                }
            }
            _removeClass(t) {
                this._fireChange("attributes", this);
                for (const e of xs(t)) {
                    this._classes.delete(e)
                }
            }
            _setStyle(t, e) {
                this._fireChange("attributes", this);
                this._styles.set(t, e)
            }
            _removeStyle(t) {
                this._fireChange("attributes", this);
                for (const e of xs(t)) {
                    this._styles.remove(e)
                }
            }
            _setCustomProperty(t, e) {
                this._customProperties.set(t, e)
            }
            _removeCustomProperty(t) {
                return this._customProperties.delete(t)
            }
        }

        function Rc(t) {
            t = Ks(t);
            for (const [e, n] of t) {
                if (n === null) {
                    t.delete(e)
                } else if (typeof n != "string") {
                    t.set(e, String(n))
                }
            }
            return t
        }

        function Vc(t, e) {
            const n = e.split(/\s+/);
            t.clear();
            n.forEach((e => t.add(e)))
        }

        function Uc(t, e) {
            if (typeof e == "string") {
                return [new Vs(t, e)]
            }
            if (!Cs(e)) {
                e = [e]
            }
            return Array.from(e).map((e => {
                if (typeof e == "string") {
                    return new Vs(t, e)
                }
                if (e instanceof Us) {
                    return new Vs(t, e.data)
                }
                return e
            }))
        }
        class Gc extends Fc {
            constructor(t, e, n, o) {
                super(t, e, n, o);
                this.getFillerOffset = Kc
            }
            is(t, e = null) {
                if (!e) {
                    return t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node"
                } else {
                    return e === this.name && (t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element")
                }
            }
        }

        function Kc() {
            const t = [...this.getChildren()];
            const e = t[this.childCount - 1];
            if (e && e.is("element", "br")) {
                return this.childCount
            }
            for (const e of t) {
                if (!e.is("uiElement")) {
                    return null
                }
            }
            return this.childCount
        }
        var Yc = Mc((function(t, e) {
            ze(e, uo(e), t)
        }));
        var Hc = Yc;
        const qc = Symbol("observableProperties");
        const Wc = Symbol("boundObservables");
        const Qc = Symbol("boundProperties");
        const $c = {
            set(t, e) {
                if (ct(t)) {
                    Object.keys(t).forEach((e => {
                        this.set(e, t[e])
                    }), this);
                    return
                }
                Jc(this);
                const n = this[qc];
                if (t in this && !n.has(t)) {
                    throw new ss["a"]("observable-set-cannot-override", this)
                }
                Object.defineProperty(this, t, {
                    enumerable: true,
                    configurable: true,
                    get() {
                        return n.get(t)
                    },
                    set(e) {
                        const o = n.get(t);
                        let i = this.fire("set:" + t, t, e, o);
                        if (i === undefined) {
                            i = e
                        }
                        if (o !== i || !n.has(t)) {
                            n.set(t, i);
                            this.fire("change:" + t, t, i, o)
                        }
                    }
                });
                this[t] = e
            },
            bind(...t) {
                if (!t.length || !nl(t)) {
                    throw new ss["a"]("observable-bind-wrong-properties", this)
                }
                if (new Set(t).size !== t.length) {
                    throw new ss["a"]("observable-bind-duplicate-properties", this)
                }
                Jc(this);
                const e = this[Qc];
                t.forEach((t => {
                    if (e.has(t)) {
                        throw new ss["a"]("observable-bind-rebind", this)
                    }
                }));
                const n = new Map;
                t.forEach((t => {
                    const o = {
                        property: t,
                        to: []
                    };
                    e.set(t, o);
                    n.set(t, o)
                }));
                return {
                    to: Xc,
                    toMany: tl,
                    _observable: this,
                    _bindProperties: t,
                    _to: [],
                    _bindings: n
                }
            },
            unbind(...t) {
                if (!this[qc]) {
                    return
                }
                const e = this[Qc];
                const n = this[Wc];
                if (t.length) {
                    if (!nl(t)) {
                        throw new ss["a"]("observable-unbind-wrong-properties", this)
                    }
                    t.forEach((t => {
                        const o = e.get(t);
                        if (!o) {
                            return
                        }
                        let i, r, s, a;
                        o.to.forEach((t => {
                            i = t[0];
                            r = t[1];
                            s = n.get(i);
                            a = s[r];
                            a.delete(o);
                            if (!a.size) {
                                delete s[r]
                            }
                            if (!Object.keys(s).length) {
                                n.delete(i);
                                this.stopListening(i, "change")
                            }
                        }));
                        e.delete(t)
                    }))
                } else {
                    n.forEach(((t, e) => {
                        this.stopListening(e, "change")
                    }));
                    n.clear();
                    e.clear()
                }
            },
            decorate(t) {
                const e = this[t];
                if (!e) {
                    throw new ss["a"]("observablemixin-cannot-decorate-undefined", this, {
                        object: this,
                        methodName: t
                    })
                }
                this.on(t, ((t, n) => {
                    t.return = e.apply(this, n)
                }));
                this[t] = function(...e) {
                    return this.fire(t, e)
                }
            }
        };
        Hc($c, ds);
        var Zc = $c;

        function Jc(t) {
            if (t[qc]) {
                return
            }
            Object.defineProperty(t, qc, {
                value: new Map
            });
            Object.defineProperty(t, Wc, {
                value: new Map
            });
            Object.defineProperty(t, Qc, {
                value: new Map
            })
        }

        function Xc(...t) {
            const e = ol(...t);
            const n = Array.from(this._bindings.keys());
            const o = n.length;
            if (!e.callback && e.to.length > 1) {
                throw new ss["a"]("observable-bind-to-no-callback", this)
            }
            if (o > 1 && e.callback) {
                throw new ss["a"]("observable-bind-to-extra-callback", this)
            }
            e.to.forEach((t => {
                if (t.properties.length && t.properties.length !== o) {
                    throw new ss["a"]("observable-bind-to-properties-length", this)
                }
                if (!t.properties.length) {
                    t.properties = this._bindProperties
                }
            }));
            this._to = e.to;
            if (e.callback) {
                this._bindings.get(n[0]).callback = e.callback
            }
            al(this._observable, this._to);
            rl(this);
            this._bindProperties.forEach((t => {
                sl(this._observable, t)
            }))
        }

        function tl(t, e, n) {
            if (this._bindings.size > 1) {
                throw new ss["a"]("observable-bind-to-many-not-one-binding", this)
            }
            this.to(...el(t, e), n)
        }

        function el(t, e) {
            const n = t.map((t => [t, e]));
            return Array.prototype.concat.apply([], n)
        }

        function nl(t) {
            return t.every((t => typeof t == "string"))
        }

        function ol(...t) {
            if (!t.length) {
                throw new ss["a"]("observable-bind-to-parse-error", null)
            }
            const e = {
                to: []
            };
            let n;
            if (typeof t[t.length - 1] == "function") {
                e.callback = t.pop()
            }
            t.forEach((t => {
                if (typeof t == "string") {
                    n.properties.push(t)
                } else if (typeof t == "object") {
                    n = {
                        observable: t,
                        properties: []
                    };
                    e.to.push(n)
                } else {
                    throw new ss["a"]("observable-bind-to-parse-error", null)
                }
            }));
            return e
        }

        function il(t, e, n, o) {
            const i = t[Wc];
            const r = i.get(n);
            const s = r || {};
            if (!s[o]) {
                s[o] = new Set
            }
            s[o].add(e);
            if (!r) {
                i.set(n, s)
            }
        }

        function rl(t) {
            let e;
            t._bindings.forEach(((n, o) => {
                t._to.forEach((i => {
                    e = i.properties[n.callback ? 0 : t._bindProperties.indexOf(o)];
                    n.to.push([i.observable, e]);
                    il(t._observable, n, i.observable, e)
                }))
            }))
        }

        function sl(t, e) {
            const n = t[Qc];
            const o = n.get(e);
            let i;
            if (o.callback) {
                i = o.callback.apply(t, o.to.map((t => t[0][t[1]])))
            } else {
                i = o.to[0];
                i = i[0][i[1]]
            }
            if (Object.prototype.hasOwnProperty.call(t, e)) {
                t[e] = i
            } else {
                t.set(e, i)
            }
        }

        function al(t, e) {
            e.forEach((e => {
                const n = t[Wc];
                let o;
                if (!n.get(e.observable)) {
                    t.listenTo(e.observable, "change", ((i, r) => {
                        o = n.get(e.observable)[r];
                        if (o) {
                            o.forEach((e => {
                                sl(t, e.property)
                            }))
                        }
                    }))
                }
            }))
        }
        class cl extends Gc {
            constructor(t, e, n, o) {
                super(t, e, n, o);
                this.set("isReadOnly", false);
                this.set("isFocused", false);
                this.bind("isReadOnly").to(t);
                this.bind("isFocused").to(t, "isFocused", (e => e && t.selection.editableElement == this));
                this.listenTo(t.selection, "change", (() => {
                    this.isFocused = t.isFocused && t.selection.editableElement == this
                }))
            }
            is(t, e = null) {
                if (!e) {
                    return t === "editableElement" || t === "view:editableElement" || t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node"
                } else {
                    return e === this.name && (t === "editableElement" || t === "view:editableElement" || t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element")
                }
            }
            destroy() {
                this.stopListening()
            }
        }
        _s(cl, Zc);
        const ll = Symbol("rootName");
        class dl extends cl {
            constructor(t, e) {
                super(t, e);
                this.rootName = "main"
            }
            is(t, e = null) {
                if (!e) {
                    return t === "rootElement" || t === "view:rootElement" || t === "editableElement" || t === "view:editableElement" || t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node"
                } else {
                    return e === this.name && (t === "rootElement" || t === "view:rootElement" || t === "editableElement" || t === "view:editableElement" || t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element")
                }
            }
            get rootName() {
                return this.getCustomProperty(ll)
            }
            set rootName(t) {
                this._setCustomProperty(ll, t)
            }
            set _name(t) {
                this.name = t
            }
        }
        class ul {
            constructor(t = {}) {
                if (!t.boundaries && !t.startPosition) {
                    throw new ss["a"]("view-tree-walker-no-start-position", null)
                }
                if (t.direction && t.direction != "forward" && t.direction != "backward") {
                    throw new ss["a"]("view-tree-walker-unknown-direction", t.startPosition, {
                        direction: t.direction
                    })
                }
                this.boundaries = t.boundaries || null;
                if (t.startPosition) {
                    this.position = hl._createAt(t.startPosition)
                } else {
                    this.position = hl._createAt(t.boundaries[t.direction == "backward" ? "end" : "start"])
                }
                this.direction = t.direction || "forward";
                this.singleCharacters = !!t.singleCharacters;
                this.shallow = !!t.shallow;
                this.ignoreElementEnd = !!t.ignoreElementEnd;
                this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
                this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null
            } [Symbol.iterator]() {
                return this
            }
            skip(t) {
                let e, n, o;
                do {
                    o = this.position;
                    ({
                        done: e,
                        value: n
                    } = this.next())
                } while (!e && t(n));
                if (!e) {
                    this.position = o
                }
            }
            next() {
                if (this.direction == "forward") {
                    return this._next()
                } else {
                    return this._previous()
                }
            }
            _next() {
                let t = this.position.clone();
                const e = this.position;
                const n = t.parent;
                if (n.parent === null && t.offset === n.childCount) {
                    return {
                        done: true
                    }
                }
                if (n === this._boundaryEndParent && t.offset == this.boundaries.end.offset) {
                    return {
                        done: true
                    }
                }
                let o;
                if (n instanceof Vs) {
                    if (t.isAtEnd) {
                        this.position = hl._createAfter(n);
                        return this._next()
                    }
                    o = n.data[t.offset]
                } else {
                    o = n.getChild(t.offset)
                }
                if (o instanceof Fc) {
                    if (!this.shallow) {
                        t = new hl(o, 0)
                    } else {
                        t.offset++
                    }
                    this.position = t;
                    return this._formatReturnValue("elementStart", o, e, t, 1)
                } else if (o instanceof Vs) {
                    if (this.singleCharacters) {
                        t = new hl(o, 0);
                        this.position = t;
                        return this._next()
                    } else {
                        let n = o.data.length;
                        let i;
                        if (o == this._boundaryEndParent) {
                            n = this.boundaries.end.offset;
                            i = new Us(o, 0, n);
                            t = hl._createAfter(i)
                        } else {
                            i = new Us(o, 0, o.data.length);
                            t.offset++
                        }
                        this.position = t;
                        return this._formatReturnValue("text", i, e, t, n)
                    }
                } else if (typeof o == "string") {
                    let o;
                    if (this.singleCharacters) {
                        o = 1
                    } else {
                        const e = n === this._boundaryEndParent ? this.boundaries.end.offset : n.data.length;
                        o = e - t.offset
                    }
                    const i = new Us(n, t.offset, o);
                    t.offset += o;
                    this.position = t;
                    return this._formatReturnValue("text", i, e, t, o)
                } else {
                    t = hl._createAfter(n);
                    this.position = t;
                    if (this.ignoreElementEnd) {
                        return this._next()
                    } else {
                        return this._formatReturnValue("elementEnd", n, e, t)
                    }
                }
            }
            _previous() {
                let t = this.position.clone();
                const e = this.position;
                const n = t.parent;
                if (n.parent === null && t.offset === 0) {
                    return {
                        done: true
                    }
                }
                if (n == this._boundaryStartParent && t.offset == this.boundaries.start.offset) {
                    return {
                        done: true
                    }
                }
                let o;
                if (n instanceof Vs) {
                    if (t.isAtStart) {
                        this.position = hl._createBefore(n);
                        return this._previous()
                    }
                    o = n.data[t.offset - 1]
                } else {
                    o = n.getChild(t.offset - 1)
                }
                if (o instanceof Fc) {
                    if (!this.shallow) {
                        t = new hl(o, o.childCount);
                        this.position = t;
                        if (this.ignoreElementEnd) {
                            return this._previous()
                        } else {
                            return this._formatReturnValue("elementEnd", o, e, t)
                        }
                    } else {
                        t.offset--;
                        this.position = t;
                        return this._formatReturnValue("elementStart", o, e, t, 1)
                    }
                } else if (o instanceof Vs) {
                    if (this.singleCharacters) {
                        t = new hl(o, o.data.length);
                        this.position = t;
                        return this._previous()
                    } else {
                        let n = o.data.length;
                        let i;
                        if (o == this._boundaryStartParent) {
                            const e = this.boundaries.start.offset;
                            i = new Us(o, e, o.data.length - e);
                            n = i.data.length;
                            t = hl._createBefore(i)
                        } else {
                            i = new Us(o, 0, o.data.length);
                            t.offset--
                        }
                        this.position = t;
                        return this._formatReturnValue("text", i, e, t, n)
                    }
                } else if (typeof o == "string") {
                    let o;
                    if (!this.singleCharacters) {
                        const e = n === this._boundaryStartParent ? this.boundaries.start.offset : 0;
                        o = t.offset - e
                    } else {
                        o = 1
                    }
                    t.offset -= o;
                    const i = new Us(n, t.offset, o);
                    this.position = t;
                    return this._formatReturnValue("text", i, e, t, o)
                } else {
                    t = hl._createBefore(n);
                    this.position = t;
                    return this._formatReturnValue("elementStart", n, e, t, 1)
                }
            }
            _formatReturnValue(t, e, n, o, i) {
                if (e instanceof Us) {
                    if (e.offsetInText + e.data.length == e.textNode.data.length) {
                        if (this.direction == "forward" && !(this.boundaries && this.boundaries.end.isEqual(this.position))) {
                            o = hl._createAfter(e.textNode);
                            this.position = o
                        } else {
                            n = hl._createAfter(e.textNode)
                        }
                    }
                    if (e.offsetInText === 0) {
                        if (this.direction == "backward" && !(this.boundaries && this.boundaries.start.isEqual(this.position))) {
                            o = hl._createBefore(e.textNode);
                            this.position = o
                        } else {
                            n = hl._createBefore(e.textNode)
                        }
                    }
                }
                return {
                    done: false,
                    value: {
                        type: t,
                        item: e,
                        previousPosition: n,
                        nextPosition: o,
                        length: i
                    }
                }
            }
        }
        class hl {
            constructor(t, e) {
                this.parent = t;
                this.offset = e
            }
            get nodeAfter() {
                if (this.parent.is("$text")) {
                    return null
                }
                return this.parent.getChild(this.offset) || null
            }
            get nodeBefore() {
                if (this.parent.is("$text")) {
                    return null
                }
                return this.parent.getChild(this.offset - 1) || null
            }
            get isAtStart() {
                return this.offset === 0
            }
            get isAtEnd() {
                const t = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
                return this.offset === t
            }
            get root() {
                return this.parent.root
            }
            get editableElement() {
                let t = this.parent;
                while (!(t instanceof cl)) {
                    if (t.parent) {
                        t = t.parent
                    } else {
                        return null
                    }
                }
                return t
            }
            getShiftedBy(t) {
                const e = hl._createAt(this);
                const n = e.offset + t;
                e.offset = n < 0 ? 0 : n;
                return e
            }
            getLastMatchingPosition(t, e = {}) {
                e.startPosition = this;
                const n = new ul(e);
                n.skip(t);
                return n.position
            }
            getAncestors() {
                if (this.parent.is("documentFragment")) {
                    return [this.parent]
                } else {
                    return this.parent.getAncestors({
                        includeSelf: true
                    })
                }
            }
            getCommonAncestor(t) {
                const e = this.getAncestors();
                const n = t.getAncestors();
                let o = 0;
                while (e[o] == n[o] && e[o]) {
                    o++
                }
                return o === 0 ? null : e[o - 1]
            }
            is(t) {
                return t === "position" || t === "view:position"
            }
            isEqual(t) {
                return this.parent == t.parent && this.offset == t.offset
            }
            isBefore(t) {
                return this.compareWith(t) == "before"
            }
            isAfter(t) {
                return this.compareWith(t) == "after"
            }
            compareWith(t) {
                if (this.root !== t.root) {
                    return "different"
                }
                if (this.isEqual(t)) {
                    return "same"
                }
                const e = this.parent.is("node") ? this.parent.getPath() : [];
                const n = t.parent.is("node") ? t.parent.getPath() : [];
                e.push(this.offset);
                n.push(t.offset);
                const o = Os(e, n);
                switch (o) {
                    case "prefix":
                        return "before";
                    case "extension":
                        return "after";
                    default:
                        return e[o] < n[o] ? "before" : "after"
                }
            }
            getWalker(t = {}) {
                t.startPosition = this;
                return new ul(t)
            }
            clone() {
                return new hl(this.parent, this.offset)
            }
            static _createAt(t, e) {
                if (t instanceof hl) {
                    return new this(t.parent, t.offset)
                } else {
                    const n = t;
                    if (e == "end") {
                        e = n.is("$text") ? n.data.length : n.childCount
                    } else if (e == "before") {
                        return this._createBefore(n)
                    } else if (e == "after") {
                        return this._createAfter(n)
                    } else if (e !== 0 && !e) {
                        throw new ss["a"]("view-createpositionat-offset-required", n)
                    }
                    return new hl(n, e)
                }
            }
            static _createAfter(t) {
                if (t.is("$textProxy")) {
                    return new hl(t.textNode, t.offsetInText + t.data.length)
                }
                if (!t.parent) {
                    throw new ss["a"]("view-position-after-root", t, {
                        root: t
                    })
                }
                return new hl(t.parent, t.index + 1)
            }
            static _createBefore(t) {
                if (t.is("$textProxy")) {
                    return new hl(t.textNode, t.offsetInText)
                }
                if (!t.parent) {
                    throw new ss["a"]("view-position-before-root", t, {
                        root: t
                    })
                }
                return new hl(t.parent, t.index)
            }
        }
        class fl {
            constructor(t, e = null) {
                this.start = t.clone();
                this.end = e ? e.clone() : t.clone()
            }*[Symbol.iterator]() {
                yield* new ul({
                    boundaries: this,
                    ignoreElementEnd: true
                })
            }
            get isCollapsed() {
                return this.start.isEqual(this.end)
            }
            get isFlat() {
                return this.start.parent === this.end.parent
            }
            get root() {
                return this.start.root
            }
            getEnlarged() {
                let t = this.start.getLastMatchingPosition(pl, {
                    direction: "backward"
                });
                let e = this.end.getLastMatchingPosition(pl);
                if (t.parent.is("$text") && t.isAtStart) {
                    t = hl._createBefore(t.parent)
                }
                if (e.parent.is("$text") && e.isAtEnd) {
                    e = hl._createAfter(e.parent)
                }
                return new fl(t, e)
            }
            getTrimmed() {
                let t = this.start.getLastMatchingPosition(pl);
                if (t.isAfter(this.end) || t.isEqual(this.end)) {
                    return new fl(t, t)
                }
                let e = this.end.getLastMatchingPosition(pl, {
                    direction: "backward"
                });
                const n = t.nodeAfter;
                const o = e.nodeBefore;
                if (n && n.is("$text")) {
                    t = new hl(n, 0)
                }
                if (o && o.is("$text")) {
                    e = new hl(o, o.data.length)
                }
                return new fl(t, e)
            }
            isEqual(t) {
                return this == t || this.start.isEqual(t.start) && this.end.isEqual(t.end)
            }
            containsPosition(t) {
                return t.isAfter(this.start) && t.isBefore(this.end)
            }
            containsRange(t, e = false) {
                if (t.isCollapsed) {
                    e = false
                }
                const n = this.containsPosition(t.start) || e && this.start.isEqual(t.start);
                const o = this.containsPosition(t.end) || e && this.end.isEqual(t.end);
                return n && o
            }
            getDifference(t) {
                const e = [];
                if (this.isIntersecting(t)) {
                    if (this.containsPosition(t.start)) {
                        e.push(new fl(this.start, t.start))
                    }
                    if (this.containsPosition(t.end)) {
                        e.push(new fl(t.end, this.end))
                    }
                } else {
                    e.push(this.clone())
                }
                return e
            }
            getIntersection(t) {
                if (this.isIntersecting(t)) {
                    let e = this.start;
                    let n = this.end;
                    if (this.containsPosition(t.start)) {
                        e = t.start
                    }
                    if (this.containsPosition(t.end)) {
                        n = t.end
                    }
                    return new fl(e, n)
                }
                return null
            }
            getWalker(t = {}) {
                t.boundaries = this;
                return new ul(t)
            }
            getCommonAncestor() {
                return this.start.getCommonAncestor(this.end)
            }
            getContainedElement() {
                if (this.isCollapsed) {
                    return null
                }
                let t = this.start.nodeAfter;
                let e = this.end.nodeBefore;
                if (this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling) {
                    t = this.start.parent.nextSibling
                }
                if (this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling) {
                    e = this.end.parent.previousSibling
                }
                if (t && t.is("element") && t === e) {
                    return t
                }
                return null
            }
            clone() {
                return new fl(this.start, this.end)
            }* getItems(t = {}) {
                t.boundaries = this;
                t.ignoreElementEnd = true;
                const e = new ul(t);
                for (const t of e) {
                    yield t.item
                }
            }* getPositions(t = {}) {
                t.boundaries = this;
                const e = new ul(t);
                yield e.position;
                for (const t of e) {
                    yield t.nextPosition
                }
            }
            is(t) {
                return t === "range" || t === "view:range"
            }
            isIntersecting(t) {
                return this.start.isBefore(t.end) && this.end.isAfter(t.start)
            }
            static _createFromParentsAndOffsets(t, e, n, o) {
                return new this(new hl(t, e), new hl(n, o))
            }
            static _createFromPositionAndShift(t, e) {
                const n = t;
                const o = t.getShiftedBy(e);
                return e > 0 ? new this(n, o) : new this(o, n)
            }
            static _createIn(t) {
                return this._createFromParentsAndOffsets(t, 0, t, t.childCount)
            }
            static _createOn(t) {
                const e = t.is("$textProxy") ? t.offsetSize : 1;
                return this._createFromPositionAndShift(hl._createBefore(t), e)
            }
        }

        function pl(t) {
            if (t.item.is("attributeElement") || t.item.is("uiElement")) {
                return true
            }
            return false
        }

        function ml(t) {
            let e = 0;
            for (const n of t) {
                e++
            }
            return e
        }
        class gl {
            constructor(t = null, e, n) {
                this._ranges = [];
                this._lastRangeBackward = false;
                this._isFake = false;
                this._fakeSelectionLabel = "";
                this.setTo(t, e, n)
            }
            get isFake() {
                return this._isFake
            }
            get fakeSelectionLabel() {
                return this._fakeSelectionLabel
            }
            get anchor() {
                if (!this._ranges.length) {
                    return null
                }
                const t = this._ranges[this._ranges.length - 1];
                const e = this._lastRangeBackward ? t.end : t.start;
                return e.clone()
            }
            get focus() {
                if (!this._ranges.length) {
                    return null
                }
                const t = this._ranges[this._ranges.length - 1];
                const e = this._lastRangeBackward ? t.start : t.end;
                return e.clone()
            }
            get isCollapsed() {
                return this.rangeCount === 1 && this._ranges[0].isCollapsed
            }
            get rangeCount() {
                return this._ranges.length
            }
            get isBackward() {
                return !this.isCollapsed && this._lastRangeBackward
            }
            get editableElement() {
                if (this.anchor) {
                    return this.anchor.editableElement
                }
                return null
            }* getRanges() {
                for (const t of this._ranges) {
                    yield t.clone()
                }
            }
            getFirstRange() {
                let t = null;
                for (const e of this._ranges) {
                    if (!t || e.start.isBefore(t.start)) {
                        t = e
                    }
                }
                return t ? t.clone() : null
            }
            getLastRange() {
                let t = null;
                for (const e of this._ranges) {
                    if (!t || e.end.isAfter(t.end)) {
                        t = e
                    }
                }
                return t ? t.clone() : null
            }
            getFirstPosition() {
                const t = this.getFirstRange();
                return t ? t.start.clone() : null
            }
            getLastPosition() {
                const t = this.getLastRange();
                return t ? t.end.clone() : null
            }
            isEqual(t) {
                if (this.isFake != t.isFake) {
                    return false
                }
                if (this.isFake && this.fakeSelectionLabel != t.fakeSelectionLabel) {
                    return false
                }
                if (this.rangeCount != t.rangeCount) {
                    return false
                } else if (this.rangeCount === 0) {
                    return true
                }
                if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) {
                    return false
                }
                for (const e of this._ranges) {
                    let n = false;
                    for (const o of t._ranges) {
                        if (e.isEqual(o)) {
                            n = true;
                            break
                        }
                    }
                    if (!n) {
                        return false
                    }
                }
                return true
            }
            isSimilar(t) {
                if (this.isBackward != t.isBackward) {
                    return false
                }
                const e = ml(this.getRanges());
                const n = ml(t.getRanges());
                if (e != n) {
                    return false
                }
                if (e == 0) {
                    return true
                }
                for (let e of this.getRanges()) {
                    e = e.getTrimmed();
                    let n = false;
                    for (let o of t.getRanges()) {
                        o = o.getTrimmed();
                        if (e.start.isEqual(o.start) && e.end.isEqual(o.end)) {
                            n = true;
                            break
                        }
                    }
                    if (!n) {
                        return false
                    }
                }
                return true
            }
            getSelectedElement() {
                if (this.rangeCount !== 1) {
                    return null
                }
                return this.getFirstRange().getContainedElement()
            }
            setTo(t, e, n) {
                if (t === null) {
                    this._setRanges([]);
                    this._setFakeOptions(e)
                } else if (t instanceof gl || t instanceof kl) {
                    this._setRanges(t.getRanges(), t.isBackward);
                    this._setFakeOptions({
                        fake: t.isFake,
                        label: t.fakeSelectionLabel
                    })
                } else if (t instanceof fl) {
                    this._setRanges([t], e && e.backward);
                    this._setFakeOptions(e)
                } else if (t instanceof hl) {
                    this._setRanges([new fl(t)]);
                    this._setFakeOptions(e)
                } else if (t instanceof Rs) {
                    const o = !!n && !!n.backward;
                    let i;
                    if (e === undefined) {
                        throw new ss["a"]("view-selection-setto-required-second-parameter", this)
                    } else if (e == "in") {
                        i = fl._createIn(t)
                    } else if (e == "on") {
                        i = fl._createOn(t)
                    } else {
                        i = new fl(hl._createAt(t, e))
                    }
                    this._setRanges([i], o);
                    this._setFakeOptions(n)
                } else if (Cs(t)) {
                    this._setRanges(t, e && e.backward);
                    this._setFakeOptions(e)
                } else {
                    throw new ss["a"]("view-selection-setto-not-selectable", this)
                }
                this.fire("change")
            }
            setFocus(t, e) {
                if (this.anchor === null) {
                    throw new ss["a"]("view-selection-setfocus-no-ranges", this)
                }
                const n = hl._createAt(t, e);
                if (n.compareWith(this.focus) == "same") {
                    return
                }
                const o = this.anchor;
                this._ranges.pop();
                if (n.compareWith(o) == "before") {
                    this._addRange(new fl(n, o), true)
                } else {
                    this._addRange(new fl(o, n))
                }
                this.fire("change")
            }
            is(t) {
                return t === "selection" || t === "view:selection"
            }
            _setRanges(t, e = false) {
                t = Array.from(t);
                this._ranges = [];
                for (const e of t) {
                    this._addRange(e)
                }
                this._lastRangeBackward = !!e
            }
            _setFakeOptions(t = {}) {
                this._isFake = !!t.fake;
                this._fakeSelectionLabel = t.fake ? t.label || "" : ""
            }
            _addRange(t, e = false) {
                if (!(t instanceof fl)) {
                    throw new ss["a"]("view-selection-add-range-not-range", this)
                }
                this._pushRange(t);
                this._lastRangeBackward = !!e
            }
            _pushRange(t) {
                for (const e of this._ranges) {
                    if (t.isIntersecting(e)) {
                        throw new ss["a"]("view-selection-range-intersects", this, {
                            addedRange: t,
                            intersectingRange: e
                        })
                    }
                }
                this._ranges.push(new fl(t.start, t.end))
            }
        }
        _s(gl, ds);
        class kl {
            constructor(t = null, e, n) {
                this._selection = new gl;
                this._selection.delegate("change").to(this);
                this._selection.setTo(t, e, n)
            }
            get isFake() {
                return this._selection.isFake
            }
            get fakeSelectionLabel() {
                return this._selection.fakeSelectionLabel
            }
            get anchor() {
                return this._selection.anchor
            }
            get focus() {
                return this._selection.focus
            }
            get isCollapsed() {
                return this._selection.isCollapsed
            }
            get rangeCount() {
                return this._selection.rangeCount
            }
            get isBackward() {
                return this._selection.isBackward
            }
            get editableElement() {
                return this._selection.editableElement
            }
            get _ranges() {
                return this._selection._ranges
            }* getRanges() {
                yield* this._selection.getRanges()
            }
            getFirstRange() {
                return this._selection.getFirstRange()
            }
            getLastRange() {
                return this._selection.getLastRange()
            }
            getFirstPosition() {
                return this._selection.getFirstPosition()
            }
            getLastPosition() {
                return this._selection.getLastPosition()
            }
            getSelectedElement() {
                return this._selection.getSelectedElement()
            }
            isEqual(t) {
                return this._selection.isEqual(t)
            }
            isSimilar(t) {
                return this._selection.isSimilar(t)
            }
            is(t) {
                return t === "selection" || t == "documentSelection" || t == "view:selection" || t == "view:documentSelection"
            }
            _setTo(t, e, n) {
                this._selection.setTo(t, e, n)
            }
            _setFocus(t, e) {
                this._selection.setFocus(t, e)
            }
        }
        _s(kl, ds);
        class bl {
            constructor(t) {
                this.selection = new kl;
                this.roots = new vs({
                    idProperty: "rootName"
                });
                this.stylesProcessor = t;
                this.set("isReadOnly", false);
                this.set("isFocused", false);
                this.set("isComposing", false);
                this._postFixers = new Set
            }
            getRoot(t = "main") {
                return this.roots.get(t)
            }
            registerPostFixer(t) {
                this._postFixers.add(t)
            }
            destroy() {
                this.roots.map((t => t.destroy()));
                this.stopListening()
            }
            _callPostFixers(t) {
                let e = false;
                do {
                    for (const n of this._postFixers) {
                        e = n(t);
                        if (e) {
                            break
                        }
                    }
                } while (e)
            }
        }
        _s(bl, Zc);
        const wl = 10;
        class Al extends Fc {
            constructor(t, e, n, o) {
                super(t, e, n, o);
                this.getFillerOffset = Cl;
                this._priority = wl;
                this._id = null;
                this._clonesGroup = null
            }
            get priority() {
                return this._priority
            }
            get id() {
                return this._id
            }
            getElementsWithSameId() {
                if (this.id === null) {
                    throw new ss["a"]("attribute-element-get-elements-with-same-id-no-id", this)
                }
                return new Set(this._clonesGroup)
            }
            is(t, e = null) {
                if (!e) {
                    return t === "attributeElement" || t === "view:attributeElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node"
                } else {
                    return e === this.name && (t === "attributeElement" || t === "view:attributeElement" || t === "element" || t === "view:element")
                }
            }
            isSimilar(t) {
                if (this.id !== null || t.id !== null) {
                    return this.id === t.id
                }
                return super.isSimilar(t) && this.priority == t.priority
            }
            _clone(t) {
                const e = super._clone(t);
                e._priority = this._priority;
                e._id = this._id;
                return e
            }
        }
        Al.DEFAULT_PRIORITY = wl;

        function Cl() {
            if (_l(this)) {
                return null
            }
            let t = this.parent;
            while (t && t.is("attributeElement")) {
                if (_l(t) > 1) {
                    return null
                }
                t = t.parent
            }
            if (!t || _l(t) > 1) {
                return null
            }
            return this.childCount
        }

        function _l(t) {
            return Array.from(t.getChildren()).filter((t => !t.is("uiElement"))).length
        }
        class vl extends Fc {
            constructor(t, e, n, o) {
                super(t, e, n, o);
                this.getFillerOffset = yl
            }
            is(t, e = null) {
                if (!e) {
                    return t === "emptyElement" || t === "view:emptyElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node"
                } else {
                    return e === this.name && (t === "emptyElement" || t === "view:emptyElement" || t === "element" || t === "view:element")
                }
            }
            _insertChild(t, e) {
                if (e && (e instanceof Rs || Array.from(e).length > 0)) {
                    throw new ss["a"]("view-emptyelement-cannot-add", [this, e])
                }
            }
        }

        function yl() {
            return null
        }
        const xl = navigator.userAgent.toLowerCase();
        const Dl = {
            isMac: El(xl),
            isGecko: Sl(xl),
            isSafari: Tl(xl),
            isAndroid: Il(xl),
            isBlink: Nl(xl),
            features: {
                isRegExpUnicodePropertySupported: Pl()
            }
        };
        var Ml = Dl;

        function El(t) {
            return t.indexOf("macintosh") > -1
        }

        function Sl(t) {
            return !!t.match(/gecko\/\d+/)
        }

        function Tl(t) {
            return t.indexOf(" applewebkit/") > -1 && t.indexOf("chrome") === -1
        }

        function Il(t) {
            return t.indexOf("android") > -1
        }

        function Nl(t) {
            return t.indexOf("chrome/") > -1 && t.indexOf("edge/") < 0
        }

        function Pl() {
            let t = false;
            try {
                t = "ć".search(new RegExp("[\\p{L}]", "u")) === 0
            } catch (t) {}
            return t
        }
        const Bl = {
            "⌘": "ctrl",
            "⇧": "shift",
            "⌥": "alt"
        };
        const Ll = {
            ctrl: "⌘",
            shift: "⇧",
            alt: "⌥"
        };
        const Ol = Gl();

        function zl(t) {
            let e;
            if (typeof t == "string") {
                e = Ol[t.toLowerCase()];
                if (!e) {
                    throw new ss["a"]("keyboard-unknown-key", null, {
                        key: t
                    })
                }
            } else {
                e = t.keyCode + (t.altKey ? Ol.alt : 0) + (t.ctrlKey ? Ol.ctrl : 0) + (t.shiftKey ? Ol.shift : 0)
            }
            return e
        }

        function jl(t) {
            if (typeof t == "string") {
                t = Kl(t)
            }
            return t.map((t => typeof t == "string" ? zl(t) : t)).reduce(((t, e) => e + t), 0)
        }

        function Fl(t) {
            if (!Ml.isMac) {
                return t
            }
            return Kl(t).map((t => Ll[t.toLowerCase()] || t)).reduce(((t, e) => {
                if (t.slice(-1) in Bl) {
                    return t + e
                } else {
                    return t + "+" + e
                }
            }))
        }

        function Rl(t) {
            return t == Ol.arrowright || t == Ol.arrowleft || t == Ol.arrowup || t == Ol.arrowdown
        }

        function Vl(t, e) {
            const n = e === "ltr";
            switch (t) {
                case Ol.arrowleft:
                    return n ? "left" : "right";
                case Ol.arrowright:
                    return n ? "right" : "left";
                case Ol.arrowup:
                    return "up";
                case Ol.arrowdown:
                    return "down"
            }
        }

        function Ul(t, e) {
            const n = Vl(t, e);
            return n === "down" || n === "right"
        }

        function Gl() {
            const t = {
                arrowleft: 37,
                arrowup: 38,
                arrowright: 39,
                arrowdown: 40,
                backspace: 8,
                delete: 46,
                enter: 13,
                space: 32,
                esc: 27,
                tab: 9,
                ctrl: 1114112,
                cmd: 1114112,
                shift: 2228224,
                alt: 4456448
            };
            for (let e = 65; e <= 90; e++) {
                const n = String.fromCharCode(e);
                t[n.toLowerCase()] = e
            }
            for (let e = 48; e <= 57; e++) {
                t[e - 48] = e
            }
            for (let e = 112; e <= 123; e++) {
                t["f" + (e - 111)] = e
            }
            return t
        }

        function Kl(t) {
            return t.split(/\s*\+\s*/)
        }
        class Yl extends Fc {
            constructor(t, e, n, o) {
                super(t, e, n, o);
                this.getFillerOffset = ql
            }
            is(t, e = null) {
                if (!e) {
                    return t === "uiElement" || t === "view:uiElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node"
                } else {
                    return e === this.name && (t === "uiElement" || t === "view:uiElement" || t === "element" || t === "view:element")
                }
            }
            _insertChild(t, e) {
                if (e && (e instanceof Rs || Array.from(e).length > 0)) {
                    throw new ss["a"]("view-uielement-cannot-add", this)
                }
            }
            render(t) {
                return this.toDomElement(t)
            }
            toDomElement(t) {
                const e = t.createElement(this.name);
                for (const t of this.getAttributeKeys()) {
                    e.setAttribute(t, this.getAttribute(t))
                }
                return e
            }
        }

        function Hl(t) {
            t.document.on("keydown", ((e, n) => Wl(e, n, t.domConverter)))
        }

        function ql() {
            return null
        }

        function Wl(t, e, n) {
            if (e.keyCode == Ol.arrowright) {
                const t = e.domTarget.ownerDocument.defaultView.getSelection();
                const o = t.rangeCount == 1 && t.getRangeAt(0).collapsed;
                if (o || e.shiftKey) {
                    const e = t.focusNode;
                    const i = t.focusOffset;
                    const r = n.domPositionToView(e, i);
                    if (r === null) {
                        return
                    }
                    let s = false;
                    const a = r.getLastMatchingPosition((t => {
                        if (t.item.is("uiElement")) {
                            s = true
                        }
                        if (t.item.is("uiElement") || t.item.is("attributeElement")) {
                            return true
                        }
                        return false
                    }));
                    if (s) {
                        const e = n.viewPositionToDom(a);
                        if (o) {
                            t.collapse(e.parent, e.offset)
                        } else {
                            t.extend(e.parent, e.offset)
                        }
                    }
                }
            }
        }
        class Ql extends Fc {
            constructor(t, e, n, o) {
                super(t, e, n, o);
                this.getFillerOffset = $l
            }
            is(t, e = null) {
                if (!e) {
                    return t === "rawElement" || t === "view:rawElement" || t === this.name || t === "view:" + this.name || t === "element" || t === "view:element" || t === "node" || t === "view:node"
                } else {
                    return e === this.name && (t === "rawElement" || t === "view:rawElement" || t === "element" || t === "view:element")
                }
            }
            _insertChild(t, e) {
                if (e && (e instanceof Rs || Array.from(e).length > 0)) {
                    throw new ss["a"]("view-rawelement-cannot-add", [this, e])
                }
            }
        }

        function $l() {
            return null
        }
        class Zl {
            constructor(t, e) {
                this.document = t;
                this._children = [];
                if (e) {
                    this._insertChild(0, e)
                }
            } [Symbol.iterator]() {
                return this._children[Symbol.iterator]()
            }
            get childCount() {
                return this._children.length
            }
            get isEmpty() {
                return this.childCount === 0
            }
            get root() {
                return this
            }
            get parent() {
                return null
            }
            is(t) {
                return t === "documentFragment" || t === "view:documentFragment"
            }
            _appendChild(t) {
                return this._insertChild(this.childCount, t)
            }
            getChild(t) {
                return this._children[t]
            }
            getChildIndex(t) {
                return this._children.indexOf(t)
            }
            getChildren() {
                return this._children[Symbol.iterator]()
            }
            _insertChild(t, e) {
                this._fireChange("children", this);
                let n = 0;
                const o = Jl(this.document, e);
                for (const e of o) {
                    if (e.parent !== null) {
                        e._remove()
                    }
                    e.parent = this;
                    this._children.splice(t, 0, e);
                    t++;
                    n++
                }
                return n
            }
            _removeChildren(t, e = 1) {
                this._fireChange("children", this);
                for (let n = t; n < t + e; n++) {
                    this._children[n].parent = null
                }
                return this._children.splice(t, e)
            }
            _fireChange(t, e) {
                this.fire("change:" + t, e)
            }
        }
        _s(Zl, ds);

        function Jl(t, e) {
            if (typeof e == "string") {
                return [new Vs(t, e)]
            }
            if (!Cs(e)) {
                e = [e]
            }
            return Array.from(e).map((e => {
                if (typeof e == "string") {
                    return new Vs(t, e)
                }
                if (e instanceof Us) {
                    return new Vs(t, e.data)
                }
                return e
            }))
        }
        class Xl {
            constructor(t) {
                this.document = t;
                this._cloneGroups = new Map
            }
            setSelection(t, e, n) {
                this.document.selection._setTo(t, e, n)
            }
            setSelectionFocus(t, e) {
                this.document.selection._setFocus(t, e)
            }
            createText(t) {
                return new Vs(this.document, t)
            }
            createAttributeElement(t, e, n = {}) {
                const o = new Al(this.document, t, e);
                if (n.priority) {
                    o._priority = n.priority
                }
                if (n.id) {
                    o._id = n.id
                }
                return o
            }
            createContainerElement(t, e) {
                return new Gc(this.document, t, e)
            }
            createEditableElement(t, e) {
                const n = new cl(this.document, t, e);
                n._document = this.document;
                return n
            }
            createEmptyElement(t, e) {
                return new vl(this.document, t, e)
            }
            createUIElement(t, e, n) {
                const o = new Yl(this.document, t, e);
                if (n) {
                    o.render = n
                }
                return o
            }
            createRawElement(t, e, n) {
                const o = new Ql(this.document, t, e);
                o.render = n || (() => {});
                return o
            }
            setAttribute(t, e, n) {
                n._setAttribute(t, e)
            }
            removeAttribute(t, e) {
                e._removeAttribute(t)
            }
            addClass(t, e) {
                e._addClass(t)
            }
            removeClass(t, e) {
                e._removeClass(t)
            }
            setStyle(t, e, n) {
                if (B(t) && n === undefined) {
                    n = e
                }
                n._setStyle(t, e)
            }
            removeStyle(t, e) {
                e._removeStyle(t)
            }
            setCustomProperty(t, e, n) {
                n._setCustomProperty(t, e)
            }
            removeCustomProperty(t, e) {
                return e._removeCustomProperty(t)
            }
            breakAttributes(t) {
                if (t instanceof hl) {
                    return this._breakAttributes(t)
                } else {
                    return this._breakAttributesRange(t)
                }
            }
            breakContainer(t) {
                const e = t.parent;
                if (!e.is("containerElement")) {
                    throw new ss["a"]("view-writer-break-non-container-element", this.document)
                }
                if (!e.parent) {
                    throw new ss["a"]("view-writer-break-root", this.document)
                }
                if (t.isAtStart) {
                    return hl._createBefore(e)
                } else if (!t.isAtEnd) {
                    const n = e._clone(false);
                    this.insert(hl._createAfter(e), n);
                    const o = new fl(t, hl._createAt(e, "end"));
                    const i = new hl(n, 0);
                    this.move(o, i)
                }
                return hl._createAfter(e)
            }
            mergeAttributes(t) {
                const e = t.offset;
                const n = t.parent;
                if (n.is("$text")) {
                    return t
                }
                if (n.is("attributeElement") && n.childCount === 0) {
                    const t = n.parent;
                    const e = n.index;
                    n._remove();
                    this._removeFromClonedElementsGroup(n);
                    return this.mergeAttributes(new hl(t, e))
                }
                const o = n.getChild(e - 1);
                const i = n.getChild(e);
                if (!o || !i) {
                    return t
                }
                if (o.is("$text") && i.is("$text")) {
                    return rd(o, i)
                } else if (o.is("attributeElement") && i.is("attributeElement") && o.isSimilar(i)) {
                    const t = o.childCount;
                    o._appendChild(i.getChildren());
                    i._remove();
                    this._removeFromClonedElementsGroup(i);
                    return this.mergeAttributes(new hl(o, t))
                }
                return t
            }
            mergeContainers(t) {
                const e = t.nodeBefore;
                const n = t.nodeAfter;
                if (!e || !n || !e.is("containerElement") || !n.is("containerElement")) {
                    throw new ss["a"]("view-writer-merge-containers-invalid-position", this.document)
                }
                const o = e.getChild(e.childCount - 1);
                const i = o instanceof Vs ? hl._createAt(o, "end") : hl._createAt(e, "end");
                this.move(fl._createIn(n), hl._createAt(e, "end"));
                this.remove(fl._createOn(n));
                return i
            }
            insert(t, e) {
                e = Cs(e) ? [...e] : [e];
                sd(e, this.document);
                const n = ed(t);
                if (!n) {
                    throw new ss["a"]("view-writer-invalid-position-container", this.document)
                }
                const o = this._breakAttributes(t, true);
                const i = n._insertChild(o.offset, e);
                for (const t of e) {
                    this._addToClonedElementsGroup(t)
                }
                const r = o.getShiftedBy(i);
                const s = this.mergeAttributes(o);
                if (i === 0) {
                    return new fl(s, s)
                } else {
                    if (!s.isEqual(o)) {
                        r.offset--
                    }
                    const t = this.mergeAttributes(r);
                    return new fl(s, t)
                }
            }
            remove(t) {
                const e = t instanceof fl ? t : fl._createOn(t);
                ld(e, this.document);
                if (e.isCollapsed) {
                    return new Zl(this.document)
                }
                const {
                    start: n,
                    end: o
                } = this._breakAttributesRange(e, true);
                const i = n.parent;
                const r = o.offset - n.offset;
                const s = i._removeChildren(n.offset, r);
                for (const t of s) {
                    this._removeFromClonedElementsGroup(t)
                }
                const a = this.mergeAttributes(n);
                e.start = a;
                e.end = a.clone();
                return new Zl(this.document, s)
            }
            clear(t, e) {
                ld(t, this.document);
                const n = t.getWalker({
                    direction: "backward",
                    ignoreElementEnd: true
                });
                for (const o of n) {
                    const n = o.item;
                    let i;
                    if (n.is("element") && e.isSimilar(n)) {
                        i = fl._createOn(n)
                    } else if (!o.nextPosition.isAfter(t.start) && n.is("$textProxy")) {
                        const t = n.getAncestors().find((t => t.is("element") && e.isSimilar(t)));
                        if (t) {
                            i = fl._createIn(t)
                        }
                    }
                    if (i) {
                        if (i.end.isAfter(t.end)) {
                            i.end = t.end
                        }
                        if (i.start.isBefore(t.start)) {
                            i.start = t.start
                        }
                        this.remove(i)
                    }
                }
            }
            move(t, e) {
                let n;
                if (e.isAfter(t.end)) {
                    e = this._breakAttributes(e, true);
                    const o = e.parent;
                    const i = o.childCount;
                    t = this._breakAttributesRange(t, true);
                    n = this.remove(t);
                    e.offset += o.childCount - i
                } else {
                    n = this.remove(t)
                }
                return this.insert(e, n)
            }
            wrap(t, e) {
                if (!(e instanceof Al)) {
                    throw new ss["a"]("view-writer-wrap-invalid-attribute", this.document)
                }
                ld(t, this.document);
                if (!t.isCollapsed) {
                    return this._wrapRange(t, e)
                } else {
                    let n = t.start;
                    if (n.parent.is("element") && !td(n.parent)) {
                        n = n.getLastMatchingPosition((t => t.item.is("uiElement")))
                    }
                    n = this._wrapPosition(n, e);
                    const o = this.document.selection;
                    if (o.isCollapsed && o.getFirstPosition().isEqual(t.start)) {
                        this.setSelection(n)
                    }
                    return new fl(n)
                }
            }
            unwrap(t, e) {
                if (!(e instanceof Al)) {
                    throw new ss["a"]("view-writer-unwrap-invalid-attribute", this.document)
                }
                ld(t, this.document);
                if (t.isCollapsed) {
                    return t
                }
                const {
                    start: n,
                    end: o
                } = this._breakAttributesRange(t, true);
                const i = n.parent;
                const r = this._unwrapChildren(i, n.offset, o.offset, e);
                const s = this.mergeAttributes(r.start);
                if (!s.isEqual(r.start)) {
                    r.end.offset--
                }
                const a = this.mergeAttributes(r.end);
                return new fl(s, a)
            }
            rename(t, e) {
                const n = new Gc(this.document, t, e.getAttributes());
                this.insert(hl._createAfter(e), n);
                this.move(fl._createIn(e), hl._createAt(n, 0));
                this.remove(fl._createOn(e));
                return n
            }
            clearClonedElementsGroup(t) {
                this._cloneGroups.delete(t)
            }
            createPositionAt(t, e) {
                return hl._createAt(t, e)
            }
            createPositionAfter(t) {
                return hl._createAfter(t)
            }
            createPositionBefore(t) {
                return hl._createBefore(t)
            }
            createRange(t, e) {
                return new fl(t, e)
            }
            createRangeOn(t) {
                return fl._createOn(t)
            }
            createRangeIn(t) {
                return fl._createIn(t)
            }
            createSelection(t, e, n) {
                return new gl(t, e, n)
            }
            _wrapChildren(t, e, n, o) {
                let i = e;
                const r = [];
                while (i < n) {
                    const e = t.getChild(i);
                    const n = e.is("$text");
                    const s = e.is("attributeElement");
                    const a = e.is("emptyElement");
                    const c = e.is("uiElement");
                    const l = e.is("rawElement");
                    if (s && this._wrapAttributeElement(o, e)) {
                        r.push(new hl(t, i))
                    } else if (n || a || c || l || s && nd(o, e)) {
                        const n = o._clone();
                        e._remove();
                        n._appendChild(e);
                        t._insertChild(i, n);
                        this._addToClonedElementsGroup(n);
                        r.push(new hl(t, i))
                    } else if (s) {
                        this._wrapChildren(e, 0, e.childCount, o)
                    }
                    i++
                }
                let s = 0;
                for (const t of r) {
                    t.offset -= s;
                    if (t.offset == e) {
                        continue
                    }
                    const o = this.mergeAttributes(t);
                    if (!o.isEqual(t)) {
                        s++;
                        n--
                    }
                }
                return fl._createFromParentsAndOffsets(t, e, t, n)
            }
            _unwrapChildren(t, e, n, o) {
                let i = e;
                const r = [];
                while (i < n) {
                    const e = t.getChild(i);
                    if (!e.is("attributeElement")) {
                        i++;
                        continue
                    }
                    if (e.isSimilar(o)) {
                        const o = e.getChildren();
                        const s = e.childCount;
                        e._remove();
                        t._insertChild(i, o);
                        this._removeFromClonedElementsGroup(e);
                        r.push(new hl(t, i), new hl(t, i + s));
                        i += s;
                        n += s - 1;
                        continue
                    }
                    if (this._unwrapAttributeElement(o, e)) {
                        r.push(new hl(t, i), new hl(t, i + 1));
                        i++;
                        continue
                    }
                    this._unwrapChildren(e, 0, e.childCount, o);
                    i++
                }
                let s = 0;
                for (const t of r) {
                    t.offset -= s;
                    if (t.offset == e || t.offset == n) {
                        continue
                    }
                    const o = this.mergeAttributes(t);
                    if (!o.isEqual(t)) {
                        s++;
                        n--
                    }
                }
                return fl._createFromParentsAndOffsets(t, e, t, n)
            }
            _wrapRange(t, e) {
                const {
                    start: n,
                    end: o
                } = this._breakAttributesRange(t, true);
                const i = n.parent;
                const r = this._wrapChildren(i, n.offset, o.offset, e);
                const s = this.mergeAttributes(r.start);
                if (!s.isEqual(r.start)) {
                    r.end.offset--
                }
                const a = this.mergeAttributes(r.end);
                return new fl(s, a)
            }
            _wrapPosition(t, e) {
                if (e.isSimilar(t.parent)) {
                    return od(t.clone())
                }
                if (t.parent.is("$text")) {
                    t = id(t)
                }
                const n = this.createAttributeElement();
                n._priority = Number.POSITIVE_INFINITY;
                n.isSimilar = () => false;
                t.parent._insertChild(t.offset, n);
                const o = new fl(t, t.getShiftedBy(1));
                this.wrap(o, e);
                const i = new hl(n.parent, n.index);
                n._remove();
                const r = i.nodeBefore;
                const s = i.nodeAfter;
                if (r instanceof Vs && s instanceof Vs) {
                    return rd(r, s)
                }
                return od(i)
            }
            _wrapAttributeElement(t, e) {
                if (!dd(t, e)) {
                    return false
                }
                if (t.name !== e.name || t.priority !== e.priority) {
                    return false
                }
                for (const n of t.getAttributeKeys()) {
                    if (n === "class" || n === "style") {
                        continue
                    }
                    if (e.hasAttribute(n) && e.getAttribute(n) !== t.getAttribute(n)) {
                        return false
                    }
                }
                for (const n of t.getStyleNames()) {
                    if (e.hasStyle(n) && e.getStyle(n) !== t.getStyle(n)) {
                        return false
                    }
                }
                for (const n of t.getAttributeKeys()) {
                    if (n === "class" || n === "style") {
                        continue
                    }
                    if (!e.hasAttribute(n)) {
                        this.setAttribute(n, t.getAttribute(n), e)
                    }
                }
                for (const n of t.getStyleNames()) {
                    if (!e.hasStyle(n)) {
                        this.setStyle(n, t.getStyle(n), e)
                    }
                }
                for (const n of t.getClassNames()) {
                    if (!e.hasClass(n)) {
                        this.addClass(n, e)
                    }
                }
                return true
            }
            _unwrapAttributeElement(t, e) {
                if (!dd(t, e)) {
                    return false
                }
                if (t.name !== e.name || t.priority !== e.priority) {
                    return false
                }
                for (const n of t.getAttributeKeys()) {
                    if (n === "class" || n === "style") {
                        continue
                    }
                    if (!e.hasAttribute(n) || e.getAttribute(n) !== t.getAttribute(n)) {
                        return false
                    }
                }
                if (!e.hasClass(...t.getClassNames())) {
                    return false
                }
                for (const n of t.getStyleNames()) {
                    if (!e.hasStyle(n) || e.getStyle(n) !== t.getStyle(n)) {
                        return false
                    }
                }
                for (const n of t.getAttributeKeys()) {
                    if (n === "class" || n === "style") {
                        continue
                    }
                    this.removeAttribute(n, e)
                }
                this.removeClass(Array.from(t.getClassNames()), e);
                this.removeStyle(Array.from(t.getStyleNames()), e);
                return true
            }
            _breakAttributesRange(t, e = false) {
                const n = t.start;
                const o = t.end;
                ld(t, this.document);
                if (t.isCollapsed) {
                    const n = this._breakAttributes(t.start, e);
                    return new fl(n, n)
                }
                const i = this._breakAttributes(o, e);
                const r = i.parent.childCount;
                const s = this._breakAttributes(n, e);
                i.offset += i.parent.childCount - r;
                return new fl(s, i)
            }
            _breakAttributes(t, e = false) {
                const n = t.offset;
                const o = t.parent;
                if (t.parent.is("emptyElement")) {
                    throw new ss["a"]("view-writer-cannot-break-empty-element", this.document)
                }
                if (t.parent.is("uiElement")) {
                    throw new ss["a"]("view-writer-cannot-break-ui-element", this.document)
                }
                if (t.parent.is("rawElement")) {
                    throw new ss["a"]("view-writer-cannot-break-raw-element", this.document)
                }
                if (!e && o.is("$text") && cd(o.parent)) {
                    return t.clone()
                }
                if (cd(o)) {
                    return t.clone()
                }
                if (o.is("$text")) {
                    return this._breakAttributes(id(t), e)
                }
                const i = o.childCount;
                if (n == i) {
                    const t = new hl(o.parent, o.index + 1);
                    return this._breakAttributes(t, e)
                } else {
                    if (n === 0) {
                        const t = new hl(o.parent, o.index);
                        return this._breakAttributes(t, e)
                    } else {
                        const t = o.index + 1;
                        const i = o._clone();
                        o.parent._insertChild(t, i);
                        this._addToClonedElementsGroup(i);
                        const r = o.childCount - n;
                        const s = o._removeChildren(n, r);
                        i._appendChild(s);
                        const a = new hl(o.parent, t);
                        return this._breakAttributes(a, e)
                    }
                }
            }
            _addToClonedElementsGroup(t) {
                if (!t.root.is("rootElement")) {
                    return
                }
                if (t.is("element")) {
                    for (const e of t.getChildren()) {
                        this._addToClonedElementsGroup(e)
                    }
                }
                const e = t.id;
                if (!e) {
                    return
                }
                let n = this._cloneGroups.get(e);
                if (!n) {
                    n = new Set;
                    this._cloneGroups.set(e, n)
                }
                n.add(t);
                t._clonesGroup = n
            }
            _removeFromClonedElementsGroup(t) {
                if (t.is("element")) {
                    for (const e of t.getChildren()) {
                        this._removeFromClonedElementsGroup(e)
                    }
                }
                const e = t.id;
                if (!e) {
                    return
                }
                const n = this._cloneGroups.get(e);
                if (!n) {
                    return
                }
                n.delete(t)
            }
        }

        function td(t) {
            return Array.from(t.getChildren()).some((t => !t.is("uiElement")))
        }

        function ed(t) {
            let e = t.parent;
            while (!cd(e)) {
                if (!e) {
                    return undefined
                }
                e = e.parent
            }
            return e
        }

        function nd(t, e) {
            if (t.priority < e.priority) {
                return true
            } else if (t.priority > e.priority) {
                return false
            }
            return t.getIdentity() < e.getIdentity()
        }

        function od(t) {
            const e = t.nodeBefore;
            if (e && e.is("$text")) {
                return new hl(e, e.data.length)
            }
            const n = t.nodeAfter;
            if (n && n.is("$text")) {
                return new hl(n, 0)
            }
            return t
        }

        function id(t) {
            if (t.offset == t.parent.data.length) {
                return new hl(t.parent.parent, t.parent.index + 1)
            }
            if (t.offset === 0) {
                return new hl(t.parent.parent, t.parent.index)
            }
            const e = t.parent.data.slice(t.offset);
            t.parent._data = t.parent.data.slice(0, t.offset);
            t.parent.parent._insertChild(t.parent.index + 1, new Vs(t.root.document, e));
            return new hl(t.parent.parent, t.parent.index + 1)
        }

        function rd(t, e) {
            const n = t.data.length;
            t._data += e.data;
            e._remove();
            return new hl(t, n)
        }

        function sd(t, e) {
            for (const n of t) {
                if (!ad.some((t => n instanceof t))) {
                    throw new ss["a"]("view-writer-insert-invalid-node-type", e)
                }
                if (!n.is("$text")) {
                    sd(n.getChildren(), e)
                }
            }
        }
        const ad = [Vs, Al, Gc, vl, Ql, Yl];

        function cd(t) {
            return t && (t.is("containerElement") || t.is("documentFragment"))
        }

        function ld(t, e) {
            const n = ed(t.start);
            const o = ed(t.end);
            if (!n || !o || n !== o) {
                throw new ss["a"]("view-writer-invalid-range-container", e)
            }
        }

        function dd(t, e) {
            return t.id === null && e.id === null
        }

        function ud(t) {
            return Object.prototype.toString.call(t) == "[object Text]"
        }
        const hd = t => t.createTextNode(" ");
        const fd = t => {
            const e = t.createElement("br");
            e.dataset.ckeFiller = true;
            return e
        };
        const pd = 7;
        const md = (() => {
            let t = "";
            for (let e = 0; e < pd; e++) {
                t += "​"
            }
            return t
        })();

        function gd(t) {
            return ud(t) && t.data.substr(0, pd) === md
        }

        function kd(t) {
            return t.data.length == pd && gd(t)
        }

        function bd(t) {
            if (gd(t)) {
                return t.data.slice(pd)
            } else {
                return t.data
            }
        }

        function wd(t) {
            t.document.on("keydown", Ad)
        }

        function Ad(t, e) {
            if (e.keyCode == Ol.arrowleft) {
                const t = e.domTarget.ownerDocument.defaultView.getSelection();
                if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) {
                    const e = t.getRangeAt(0).startContainer;
                    const n = t.getRangeAt(0).startOffset;
                    if (gd(e) && n <= pd) {
                        t.collapse(e, 0)
                    }
                }
            }
        }

        function Cd(t, e, n, o = false) {
            n = n || function(t, e) {
                return t === e
            };
            if (!Array.isArray(t)) {
                t = Array.prototype.slice.call(t)
            }
            if (!Array.isArray(e)) {
                e = Array.prototype.slice.call(e)
            }
            const i = _d(t, e, n);
            return o ? Dd(i, e.length) : xd(e, i)
        }

        function _d(t, e, n) {
            const o = vd(t, e, n);
            if (o === -1) {
                return {
                    firstIndex: -1,
                    lastIndexOld: -1,
                    lastIndexNew: -1
                }
            }
            const i = yd(t, o);
            const r = yd(e, o);
            const s = vd(i, r, n);
            const a = t.length - s;
            const c = e.length - s;
            return {
                firstIndex: o,
                lastIndexOld: a,
                lastIndexNew: c
            }
        }

        function vd(t, e, n) {
            for (let o = 0; o < Math.max(t.length, e.length); o++) {
                if (t[o] === undefined || e[o] === undefined || !n(t[o], e[o])) {
                    return o
                }
            }
            return -1
        }

        function yd(t, e) {
            return t.slice(e).reverse()
        }

        function xd(t, e) {
            const n = [];
            const {
                firstIndex: o,
                lastIndexOld: i,
                lastIndexNew: r
            } = e;
            if (r - o > 0) {
                n.push({
                    index: o,
                    type: "insert",
                    values: t.slice(o, r)
                })
            }
            if (i - o > 0) {
                n.push({
                    index: o + (r - o),
                    type: "delete",
                    howMany: i - o
                })
            }
            return n
        }

        function Dd(t, e) {
            const {
                firstIndex: n,
                lastIndexOld: o,
                lastIndexNew: i
            } = t;
            if (n === -1) {
                return Array(e).fill("equal")
            }
            let r = [];
            if (n > 0) {
                r = r.concat(Array(n).fill("equal"))
            }
            if (i - n > 0) {
                r = r.concat(Array(i - n).fill("insert"))
            }
            if (o - n > 0) {
                r = r.concat(Array(o - n).fill("delete"))
            }
            if (i < e) {
                r = r.concat(Array(e - i).fill("equal"))
            }
            return r
        }

        function Md(t, e, n) {
            n = n || function(t, e) {
                return t === e
            };
            const o = t.length;
            const i = e.length;
            if (o > 200 || i > 200 || o + i > 300) {
                return Md.fastDiff(t, e, n, true)
            }
            let r, s;
            if (i < o) {
                const n = t;
                t = e;
                e = n;
                r = "delete";
                s = "insert"
            } else {
                r = "insert";
                s = "delete"
            }
            const a = t.length;
            const c = e.length;
            const l = c - a;
            const d = {};
            const u = {};

            function h(o) {
                const i = (u[o - 1] !== undefined ? u[o - 1] : -1) + 1;
                const l = u[o + 1] !== undefined ? u[o + 1] : -1;
                const h = i > l ? -1 : 1;
                if (d[o + h]) {
                    d[o] = d[o + h].slice(0)
                }
                if (!d[o]) {
                    d[o] = []
                }
                d[o].push(i > l ? r : s);
                let f = Math.max(i, l);
                let p = f - o;
                while (p < a && f < c && n(t[p], e[f])) {
                    p++;
                    f++;
                    d[o].push("equal")
                }
                return f
            }
            let f = 0;
            let p;
            do {
                for (p = -f; p < l; p++) {
                    u[p] = h(p)
                }
                for (p = l + f; p > l; p--) {
                    u[p] = h(p)
                }
                u[l] = h(l);
                f++
            } while (u[l] !== c);
            return d[l].slice(1)
        }
        Md.fastDiff = Cd;

        function Ed(t, e, n) {
            t.insertBefore(n, t.childNodes[e] || null)
        }

        function Sd(t) {
            const e = t.parentNode;
            if (e) {
                e.removeChild(t)
            }
        }

        function Td(t) {
            if (t) {
                if (t.defaultView) {
                    return t instanceof t.defaultView.Document
                } else if (t.ownerDocument && t.ownerDocument.defaultView) {
                    return t instanceof t.ownerDocument.defaultView.Node
                }
            }
            return false
        }
        class Id {
            constructor(t, e) {
                this.domDocuments = new Set;
                this.domConverter = t;
                this.markedAttributes = new Set;
                this.markedChildren = new Set;
                this.markedTexts = new Set;
                this.selection = e;
                this.isFocused = false;
                this._inlineFiller = null;
                this._fakeSelectionContainer = null
            }
            markToSync(t, e) {
                if (t === "text") {
                    if (this.domConverter.mapViewToDom(e.parent)) {
                        this.markedTexts.add(e)
                    }
                } else {
                    if (!this.domConverter.mapViewToDom(e)) {
                        return
                    }
                    if (t === "attributes") {
                        this.markedAttributes.add(e)
                    } else if (t === "children") {
                        this.markedChildren.add(e)
                    } else {
                        throw new ss["a"]("view-renderer-unknown-type", this)
                    }
                }
            }
            render() {
                let t;
                for (const t of this.markedChildren) {
                    this._updateChildrenMappings(t)
                }
                if (this._inlineFiller && !this._isSelectionInInlineFiller()) {
                    this._removeInlineFiller()
                }
                if (this._inlineFiller) {
                    t = this._getInlineFillerPosition()
                } else if (this._needsInlineFillerAtSelection()) {
                    t = this.selection.getFirstPosition();
                    this.markedChildren.add(t.parent)
                }
                for (const t of this.markedAttributes) {
                    this._updateAttrs(t)
                }
                for (const e of this.markedChildren) {
                    this._updateChildren(e, {
                        inlineFillerPosition: t
                    })
                }
                for (const e of this.markedTexts) {
                    if (!this.markedChildren.has(e.parent) && this.domConverter.mapViewToDom(e.parent)) {
                        this._updateText(e, {
                            inlineFillerPosition: t
                        })
                    }
                }
                if (t) {
                    const e = this.domConverter.viewPositionToDom(t);
                    const n = e.parent.ownerDocument;
                    if (!gd(e.parent)) {
                        this._inlineFiller = Pd(n, e.parent, e.offset)
                    } else {
                        this._inlineFiller = e.parent
                    }
                } else {
                    this._inlineFiller = null
                }
                this._updateSelection();
                this._updateFocus();
                this.markedTexts.clear();
                this.markedAttributes.clear();
                this.markedChildren.clear()
            }
            _updateChildrenMappings(t) {
                const e = this.domConverter.mapViewToDom(t);
                if (!e) {
                    return
                }
                const n = this.domConverter.mapViewToDom(t).childNodes;
                const o = Array.from(this.domConverter.viewChildrenToDom(t, e.ownerDocument, {
                    withChildren: false
                }));
                const i = this._diffNodeLists(n, o);
                const r = this._findReplaceActions(i, n, o);
                if (r.indexOf("replace") !== -1) {
                    const e = {
                        equal: 0,
                        insert: 0,
                        delete: 0
                    };
                    for (const i of r) {
                        if (i === "replace") {
                            const i = e.equal + e.insert;
                            const r = e.equal + e.delete;
                            const s = t.getChild(i);
                            if (s && !(s.is("uiElement") || s.is("rawElement"))) {
                                this._updateElementMappings(s, n[r])
                            }
                            Sd(o[i]);
                            e.equal++
                        } else {
                            e[i]++
                        }
                    }
                }
            }
            _updateElementMappings(t, e) {
                this.domConverter.unbindDomElement(e);
                this.domConverter.bindElements(e, t);
                this.markedChildren.add(t);
                this.markedAttributes.add(t)
            }
            _getInlineFillerPosition() {
                const t = this.selection.getFirstPosition();
                if (t.parent.is("$text")) {
                    return hl._createBefore(this.selection.getFirstPosition().parent)
                } else {
                    return t
                }
            }
            _isSelectionInInlineFiller() {
                if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
                    return false
                }
                const t = this.selection.getFirstPosition();
                const e = this.domConverter.viewPositionToDom(t);
                if (e && ud(e.parent) && gd(e.parent)) {
                    return true
                }
                return false
            }
            _removeInlineFiller() {
                const t = this._inlineFiller;
                if (!gd(t)) {
                    throw new ss["a"]("view-renderer-filler-was-lost", this)
                }
                if (kd(t)) {
                    t.parentNode.removeChild(t)
                } else {
                    t.data = t.data.substr(pd)
                }
                this._inlineFiller = null
            }
            _needsInlineFillerAtSelection() {
                if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
                    return false
                }
                const t = this.selection.getFirstPosition();
                const e = t.parent;
                const n = t.offset;
                if (!this.domConverter.mapViewToDom(e.root)) {
                    return false
                }
                if (!e.is("element")) {
                    return false
                }
                if (!Nd(e)) {
                    return false
                }
                if (n === e.getFillerOffset()) {
                    return false
                }
                const o = t.nodeBefore;
                const i = t.nodeAfter;
                if (o instanceof Vs || i instanceof Vs) {
                    return false
                }
                return true
            }
            _updateText(t, e) {
                const n = this.domConverter.findCorrespondingDomText(t);
                const o = this.domConverter.viewToDom(t, n.ownerDocument);
                const i = n.data;
                let r = o.data;
                const s = e.inlineFillerPosition;
                if (s && s.parent == t.parent && s.offset == t.index) {
                    r = md + r
                }
                if (i != r) {
                    const t = Cd(i, r);
                    for (const e of t) {
                        if (e.type === "insert") {
                            n.insertData(e.index, e.values.join(""))
                        } else {
                            n.deleteData(e.index, e.howMany)
                        }
                    }
                }
            }
            _updateAttrs(t) {
                const e = this.domConverter.mapViewToDom(t);
                if (!e) {
                    return
                }
                const n = Array.from(e.attributes).map((t => t.name));
                const o = t.getAttributeKeys();
                for (const n of o) {
                    e.setAttribute(n, t.getAttribute(n))
                }
                for (const o of n) {
                    if (!t.hasAttribute(o)) {
                        e.removeAttribute(o)
                    }
                }
            }
            _updateChildren(t, e) {
                const n = this.domConverter.mapViewToDom(t);
                if (!n) {
                    return
                }
                const o = e.inlineFillerPosition;
                const i = this.domConverter.mapViewToDom(t).childNodes;
                const r = Array.from(this.domConverter.viewChildrenToDom(t, n.ownerDocument, {
                    bind: true,
                    inlineFillerPosition: o
                }));
                if (o && o.parent === t) {
                    Pd(n.ownerDocument, r, o.offset)
                }
                const s = this._diffNodeLists(i, r);
                let a = 0;
                const c = new Set;
                for (const t of s) {
                    if (t === "delete") {
                        c.add(i[a]);
                        Sd(i[a])
                    } else if (t === "equal") {
                        a++
                    }
                }
                a = 0;
                for (const t of s) {
                    if (t === "insert") {
                        Ed(n, a, r[a]);
                        a++
                    } else if (t === "equal") {
                        this._markDescendantTextToSync(this.domConverter.domToView(r[a]));
                        a++
                    }
                }
                for (const t of c) {
                    if (!t.parentNode) {
                        this.domConverter.unbindDomElement(t)
                    }
                }
            }
            _diffNodeLists(t, e) {
                t = zd(t, this._fakeSelectionContainer);
                return Md(t, e, Ld.bind(null, this.domConverter))
            }
            _findReplaceActions(t, e, n) {
                if (t.indexOf("insert") === -1 || t.indexOf("delete") === -1) {
                    return t
                }
                let o = [];
                let i = [];
                let r = [];
                const s = {
                    equal: 0,
                    insert: 0,
                    delete: 0
                };
                for (const a of t) {
                    if (a === "insert") {
                        r.push(n[s.equal + s.insert])
                    } else if (a === "delete") {
                        i.push(e[s.equal + s.delete])
                    } else {
                        o = o.concat(Md(i, r, Bd).map((t => t === "equal" ? "replace" : t)));
                        o.push("equal");
                        i = [];
                        r = []
                    }
                    s[a]++
                }
                return o.concat(Md(i, r, Bd).map((t => t === "equal" ? "replace" : t)))
            }
            _markDescendantTextToSync(t) {
                if (!t) {
                    return
                }
                if (t.is("$text")) {
                    this.markedTexts.add(t)
                } else if (t.is("element")) {
                    for (const e of t.getChildren()) {
                        this._markDescendantTextToSync(e)
                    }
                }
            }
            _updateSelection() {
                if (this.selection.rangeCount === 0) {
                    this._removeDomSelection();
                    this._removeFakeSelection();
                    return
                }
                const t = this.domConverter.mapViewToDom(this.selection.editableElement);
                if (!this.isFocused || !t) {
                    return
                }
                if (this.selection.isFake) {
                    this._updateFakeSelection(t)
                } else {
                    this._removeFakeSelection();
                    this._updateDomSelection(t)
                }
            }
            _updateFakeSelection(t) {
                const e = t.ownerDocument;
                if (!this._fakeSelectionContainer) {
                    this._fakeSelectionContainer = jd(e)
                }
                const n = this._fakeSelectionContainer;
                this.domConverter.bindFakeSelection(n, this.selection);
                if (!this._fakeSelectionNeedsUpdate(t)) {
                    return
                }
                if (!n.parentElement || n.parentElement != t) {
                    t.appendChild(n)
                }
                n.textContent = this.selection.fakeSelectionLabel || " ";
                const o = e.getSelection();
                const i = e.createRange();
                o.removeAllRanges();
                i.selectNodeContents(n);
                o.addRange(i)
            }
            _updateDomSelection(t) {
                const e = t.ownerDocument.defaultView.getSelection();
                if (!this._domSelectionNeedsUpdate(e)) {
                    return
                }
                const n = this.domConverter.viewPositionToDom(this.selection.anchor);
                const o = this.domConverter.viewPositionToDom(this.selection.focus);
                t.focus();
                e.collapse(n.parent, n.offset);
                e.extend(o.parent, o.offset);
                if (Ml.isGecko) {
                    Od(o, e)
                }
            }
            _domSelectionNeedsUpdate(t) {
                if (!this.domConverter.isDomSelectionCorrect(t)) {
                    return true
                }
                const e = t && this.domConverter.domSelectionToView(t);
                if (e && this.selection.isEqual(e)) {
                    return false
                }
                if (!this.selection.isCollapsed && this.selection.isSimilar(e)) {
                    return false
                }
                return true
            }
            _fakeSelectionNeedsUpdate(t) {
                const e = this._fakeSelectionContainer;
                const n = t.ownerDocument.getSelection();
                if (!e || e.parentElement !== t) {
                    return true
                }
                if (n.anchorNode !== e && !e.contains(n.anchorNode)) {
                    return true
                }
                return e.textContent !== this.selection.fakeSelectionLabel
            }
            _removeDomSelection() {
                for (const t of this.domDocuments) {
                    const e = t.getSelection();
                    if (e.rangeCount) {
                        const e = t.activeElement;
                        const n = this.domConverter.mapDomToView(e);
                        if (e && n) {
                            t.getSelection().removeAllRanges()
                        }
                    }
                }
            }
            _removeFakeSelection() {
                const t = this._fakeSelectionContainer;
                if (t) {
                    t.remove()
                }
            }
            _updateFocus() {
                if (this.isFocused) {
                    const t = this.selection.editableElement;
                    if (t) {
                        this.domConverter.focus(t)
                    }
                }
            }
        }
        _s(Id, Zc);

        function Nd(t) {
            if (t.getAttribute("contenteditable") == "false") {
                return false
            }
            const e = t.findAncestor((t => t.hasAttribute("contenteditable")));
            return !e || e.getAttribute("contenteditable") == "true"
        }

        function Pd(t, e, n) {
            const o = e instanceof Array ? e : e.childNodes;
            const i = o[n];
            if (ud(i)) {
                i.data = md + i.data;
                return i
            } else {
                const i = t.createTextNode(md);
                if (Array.isArray(e)) {
                    o.splice(n, 0, i)
                } else {
                    Ed(e, n, i)
                }
                return i
            }
        }

        function Bd(t, e) {
            return Td(t) && Td(e) && !ud(t) && !ud(e) && t.nodeType !== Node.COMMENT_NODE && e.nodeType !== Node.COMMENT_NODE && t.tagName.toLowerCase() === e.tagName.toLowerCase()
        }

        function Ld(t, e, n) {
            if (e === n) {
                return true
            } else if (ud(e) && ud(n)) {
                return e.data === n.data
            } else if (t.isBlockFiller(e) && t.isBlockFiller(n)) {
                return true
            }
            return false
        }

        function Od(t, e) {
            const n = t.parent;
            if (n.nodeType != Node.ELEMENT_NODE || t.offset != n.childNodes.length - 1) {
                return
            }
            const o = n.childNodes[t.offset];
            if (o && o.tagName == "BR") {
                e.addRange(e.getRangeAt(0))
            }
        }

        function zd(t, e) {
            const n = Array.from(t);
            if (n.length == 0 || !e) {
                return n
            }
            const o = n[n.length - 1];
            if (o == e) {
                n.pop()
            }
            return n
        }

        function jd(t) {
            const e = t.createElement("div");
            e.className = "ck-fake-selection-container";
            Object.assign(e.style, {
                position: "fixed",
                top: 0,
                left: "-9999px",
                width: "42px"
            });
            e.textContent = " ";
            return e
        }
        var Fd = {
            window: window,
            document: document
        };

        function Rd(t) {
            let e = 0;
            while (t.previousSibling) {
                t = t.previousSibling;
                e++
            }
            return e
        }

        function Vd(t) {
            const e = [];
            while (t && t.nodeType != Node.DOCUMENT_NODE) {
                e.unshift(t);
                t = t.parentNode
            }
            return e
        }

        function Ud(t, e) {
            const n = Vd(t);
            const o = Vd(e);
            let i = 0;
            while (n[i] == o[i] && n[i]) {
                i++
            }
            return i === 0 ? null : n[i - 1]
        }
        const Gd = fd(document);
        class Kd {
            constructor(t, e = {}) {
                this.document = t;
                this.blockFillerMode = e.blockFillerMode || "br";
                this.preElements = ["pre"];
                this.blockElements = ["p", "div", "h1", "h2", "h3", "h4", "h5", "h6", "li", "dd", "dt", "figcaption", "td", "th"];
                this._blockFiller = this.blockFillerMode == "br" ? fd : hd;
                this._domToViewMapping = new WeakMap;
                this._viewToDomMapping = new WeakMap;
                this._fakeSelectionMapping = new WeakMap;
                this._rawContentElementMatcher = new Ys;
                this._encounteredRawContentDomNodes = new WeakSet
            }
            bindFakeSelection(t, e) {
                this._fakeSelectionMapping.set(t, new gl(e))
            }
            fakeSelectionToView(t) {
                return this._fakeSelectionMapping.get(t)
            }
            bindElements(t, e) {
                this._domToViewMapping.set(t, e);
                this._viewToDomMapping.set(e, t)
            }
            unbindDomElement(t) {
                const e = this._domToViewMapping.get(t);
                if (e) {
                    this._domToViewMapping.delete(t);
                    this._viewToDomMapping.delete(e);
                    for (const e of t.childNodes) {
                        this.unbindDomElement(e)
                    }
                }
            }
            bindDocumentFragments(t, e) {
                this._domToViewMapping.set(t, e);
                this._viewToDomMapping.set(e, t)
            }
            viewToDom(t, e, n = {}) {
                if (t.is("$text")) {
                    const n = this._processDataFromViewText(t);
                    return e.createTextNode(n)
                } else {
                    if (this.mapViewToDom(t)) {
                        return this.mapViewToDom(t)
                    }
                    let o;
                    if (t.is("documentFragment")) {
                        o = e.createDocumentFragment();
                        if (n.bind) {
                            this.bindDocumentFragments(o, t)
                        }
                    } else if (t.is("uiElement")) {
                        o = t.render(e);
                        if (n.bind) {
                            this.bindElements(o, t)
                        }
                        return o
                    } else {
                        if (t.hasAttribute("xmlns")) {
                            o = e.createElementNS(t.getAttribute("xmlns"), t.name)
                        } else {
                            o = e.createElement(t.name)
                        }
                        if (t.is("rawElement")) {
                            t.render(o)
                        }
                        if (n.bind) {
                            this.bindElements(o, t)
                        }
                        for (const e of t.getAttributeKeys()) {
                            o.setAttribute(e, t.getAttribute(e))
                        }
                    }
                    if (n.withChildren !== false) {
                        for (const i of this.viewChildrenToDom(t, e, n)) {
                            o.appendChild(i)
                        }
                    }
                    return o
                }
            }* viewChildrenToDom(t, e, n = {}) {
                const o = t.getFillerOffset && t.getFillerOffset();
                let i = 0;
                for (const r of t.getChildren()) {
                    if (o === i) {
                        yield this._blockFiller(e)
                    }
                    yield this.viewToDom(r, e, n);
                    i++
                }
                if (o === i) {
                    yield this._blockFiller(e)
                }
            }
            viewRangeToDom(t) {
                const e = this.viewPositionToDom(t.start);
                const n = this.viewPositionToDom(t.end);
                const o = document.createRange();
                o.setStart(e.parent, e.offset);
                o.setEnd(n.parent, n.offset);
                return o
            }
            viewPositionToDom(t) {
                const e = t.parent;
                if (e.is("$text")) {
                    const n = this.findCorrespondingDomText(e);
                    if (!n) {
                        return null
                    }
                    let o = t.offset;
                    if (gd(n)) {
                        o += pd
                    }
                    return {
                        parent: n,
                        offset: o
                    }
                } else {
                    let n, o, i;
                    if (t.offset === 0) {
                        n = this.mapViewToDom(e);
                        if (!n) {
                            return null
                        }
                        i = n.childNodes[0]
                    } else {
                        const e = t.nodeBefore;
                        o = e.is("$text") ? this.findCorrespondingDomText(e) : this.mapViewToDom(t.nodeBefore);
                        if (!o) {
                            return null
                        }
                        n = o.parentNode;
                        i = o.nextSibling
                    }
                    if (ud(i) && gd(i)) {
                        return {
                            parent: i,
                            offset: pd
                        }
                    }
                    const r = o ? Rd(o) + 1 : 0;
                    return {
                        parent: n,
                        offset: r
                    }
                }
            }
            domToView(t, e = {}) {
                if (this.isBlockFiller(t, this.blockFillerMode)) {
                    return null
                }
                const n = this.getHostViewElement(t);
                if (n) {
                    return n
                }
                if (ud(t)) {
                    if (kd(t)) {
                        return null
                    } else {
                        const e = this._processDataFromDomText(t);
                        return e === "" ? null : new Vs(this.document, e)
                    }
                } else if (this.isComment(t)) {
                    return null
                } else {
                    if (this.mapDomToView(t)) {
                        return this.mapDomToView(t)
                    }
                    let n;
                    if (this.isDocumentFragment(t)) {
                        n = new Zl(this.document);
                        if (e.bind) {
                            this.bindDocumentFragments(t, n)
                        }
                    } else {
                        const o = e.keepOriginalCase ? t.tagName : t.tagName.toLowerCase();
                        n = new Fc(this.document, o);
                        if (e.bind) {
                            this.bindElements(t, n)
                        }
                        const i = t.attributes;
                        for (let t = i.length - 1; t >= 0; t--) {
                            n._setAttribute(i[t].name, i[t].value)
                        }
                        if (e.withChildren !== false && this._rawContentElementMatcher.match(n)) {
                            n._setCustomProperty("$rawContent", t.innerHTML);
                            this._encounteredRawContentDomNodes.add(t);
                            return n
                        }
                    }
                    if (e.withChildren !== false) {
                        for (const o of this.domChildrenToView(t, e)) {
                            n._appendChild(o)
                        }
                    }
                    return n
                }
            }* domChildrenToView(t, e = {}) {
                for (let n = 0; n < t.childNodes.length; n++) {
                    const o = t.childNodes[n];
                    const i = this.domToView(o, e);
                    if (i !== null) {
                        yield i
                    }
                }
            }
            domSelectionToView(t) {
                if (t.rangeCount === 1) {
                    let e = t.getRangeAt(0).startContainer;
                    if (ud(e)) {
                        e = e.parentNode
                    }
                    const n = this.fakeSelectionToView(e);
                    if (n) {
                        return n
                    }
                }
                const e = this.isDomSelectionBackward(t);
                const n = [];
                for (let e = 0; e < t.rangeCount; e++) {
                    const o = t.getRangeAt(e);
                    const i = this.domRangeToView(o);
                    if (i) {
                        n.push(i)
                    }
                }
                return new gl(n, {
                    backward: e
                })
            }
            domRangeToView(t) {
                const e = this.domPositionToView(t.startContainer, t.startOffset);
                const n = this.domPositionToView(t.endContainer, t.endOffset);
                if (e && n) {
                    return new fl(e, n)
                }
                return null
            }
            domPositionToView(t, e) {
                if (this.isBlockFiller(t, this.blockFillerMode)) {
                    return this.domPositionToView(t.parentNode, Rd(t))
                }
                const n = this.mapDomToView(t);
                if (n && (n.is("uiElement") || n.is("rawElement"))) {
                    return hl._createBefore(n)
                }
                if (ud(t)) {
                    if (kd(t)) {
                        return this.domPositionToView(t.parentNode, Rd(t))
                    }
                    const n = this.findCorrespondingViewText(t);
                    let o = e;
                    if (!n) {
                        return null
                    }
                    if (gd(t)) {
                        o -= pd;
                        o = o < 0 ? 0 : o
                    }
                    return new hl(n, o)
                } else {
                    if (e === 0) {
                        const e = this.mapDomToView(t);
                        if (e) {
                            return new hl(e, 0)
                        }
                    } else {
                        const n = t.childNodes[e - 1];
                        const o = ud(n) ? this.findCorrespondingViewText(n) : this.mapDomToView(n);
                        if (o && o.parent) {
                            return new hl(o.parent, o.index + 1)
                        }
                    }
                    return null
                }
            }
            mapDomToView(t) {
                const e = this.getHostViewElement(t);
                return e || this._domToViewMapping.get(t)
            }
            findCorrespondingViewText(t) {
                if (kd(t)) {
                    return null
                }
                const e = this.getHostViewElement(t);
                if (e) {
                    return e
                }
                const n = t.previousSibling;
                if (n) {
                    if (!this.isElement(n)) {
                        return null
                    }
                    const t = this.mapDomToView(n);
                    if (t) {
                        const e = t.nextSibling;
                        if (e instanceof Vs) {
                            return t.nextSibling
                        } else {
                            return null
                        }
                    }
                } else {
                    const e = this.mapDomToView(t.parentNode);
                    if (e) {
                        const t = e.getChild(0);
                        if (t instanceof Vs) {
                            return t
                        } else {
                            return null
                        }
                    }
                }
                return null
            }
            mapViewToDom(t) {
                return this._viewToDomMapping.get(t)
            }
            findCorrespondingDomText(t) {
                const e = t.previousSibling;
                if (e && this.mapViewToDom(e)) {
                    return this.mapViewToDom(e).nextSibling
                }
                if (!e && t.parent && this.mapViewToDom(t.parent)) {
                    return this.mapViewToDom(t.parent).childNodes[0]
                }
                return null
            }
            focus(t) {
                const e = this.mapViewToDom(t);
                if (e && e.ownerDocument.activeElement !== e) {
                    const {
                        scrollX: t,
                        scrollY: n
                    } = Fd.window;
                    const o = [];
                    Hd(e, (t => {
                        const {
                            scrollLeft: e,
                            scrollTop: n
                        } = t;
                        o.push([e, n])
                    }));
                    e.focus();
                    Hd(e, (t => {
                        const [e, n] = o.shift();
                        t.scrollLeft = e;
                        t.scrollTop = n
                    }));
                    Fd.window.scrollTo(t, n)
                }
            }
            isElement(t) {
                return t && t.nodeType == Node.ELEMENT_NODE
            }
            isDocumentFragment(t) {
                return t && t.nodeType == Node.DOCUMENT_FRAGMENT_NODE
            }
            isComment(t) {
                return t && t.nodeType == Node.COMMENT_NODE
            }
            isBlockFiller(t) {
                if (this.blockFillerMode == "br") {
                    return t.isEqualNode(Gd)
                }
                if (t.tagName === "BR" && Wd(t, this.blockElements) && t.parentNode.childNodes.length === 1) {
                    return true
                }
                return qd(t, this.blockElements)
            }
            isDomSelectionBackward(t) {
                if (t.isCollapsed) {
                    return false
                }
                const e = document.createRange();
                e.setStart(t.anchorNode, t.anchorOffset);
                e.setEnd(t.focusNode, t.focusOffset);
                const n = e.collapsed;
                e.detach();
                return n
            }
            getHostViewElement(t) {
                const e = Vd(t);
                e.pop();
                while (e.length) {
                    const t = e.pop();
                    const n = this._domToViewMapping.get(t);
                    if (n && (n.is("uiElement") || n.is("rawElement"))) {
                        return n
                    }
                }
                return null
            }
            isDomSelectionCorrect(t) {
                return this._isDomSelectionPositionCorrect(t.anchorNode, t.anchorOffset) && this._isDomSelectionPositionCorrect(t.focusNode, t.focusOffset)
            }
            registerRawContentMatcher(t) {
                this._rawContentElementMatcher.add(t)
            }
            _isDomSelectionPositionCorrect(t, e) {
                if (ud(t) && gd(t) && e < pd) {
                    return false
                }
                if (this.isElement(t) && gd(t.childNodes[e])) {
                    return false
                }
                const n = this.mapDomToView(t);
                if (n && (n.is("uiElement") || n.is("rawElement"))) {
                    return false
                }
                return true
            }
            _processDataFromViewText(t) {
                let e = t.data;
                if (t.getAncestors().some((t => this.preElements.includes(t.name)))) {
                    return e
                }
                if (e.charAt(0) == " ") {
                    const n = this._getTouchingViewTextNode(t, false);
                    const o = n && this._nodeEndsWithSpace(n);
                    if (o || !n) {
                        e = " " + e.substr(1)
                    }
                }
                if (e.charAt(e.length - 1) == " ") {
                    const n = this._getTouchingViewTextNode(t, true);
                    if (e.charAt(e.length - 2) == " " || !n || n.data.charAt(0) == " ") {
                        e = e.substr(0, e.length - 1) + " "
                    }
                }
                return e.replace(/ {2}/g, "  ")
            }
            _nodeEndsWithSpace(t) {
                if (t.getAncestors().some((t => this.preElements.includes(t.name)))) {
                    return false
                }
                const e = this._processDataFromViewText(t);
                return e.charAt(e.length - 1) == " "
            }
            _processDataFromDomText(t) {
                let e = t.data;
                if (Yd(t, this.preElements)) {
                    return bd(t)
                }
                e = e.replace(/[ \n\t\r]{1,}/g, " ");
                const n = this._getTouchingInlineDomNode(t, false);
                const o = this._getTouchingInlineDomNode(t, true);
                const i = this._checkShouldLeftTrimDomText(t, n);
                const r = this._checkShouldRightTrimDomText(t, o);
                if (i) {
                    e = e.replace(/^ /, "")
                }
                if (r) {
                    e = e.replace(/ $/, "")
                }
                e = bd(new Text(e));
                e = e.replace(/ \u00A0/g, "  ");
                if (/( |\u00A0)\u00A0$/.test(e) || !o || o.data && o.data.charAt(0) == " ") {
                    e = e.replace(/\u00A0$/, " ")
                }
                if (i) {
                    e = e.replace(/^\u00A0/, " ")
                }
                return e
            }
            _checkShouldLeftTrimDomText(t, e) {
                if (!e) {
                    return true
                }
                if (Wr(e)) {
                    return true
                }
                if (this._encounteredRawContentDomNodes.has(t.previousSibling)) {
                    return false
                }
                return /[^\S\u00A0]/.test(e.data.charAt(e.data.length - 1))
            }
            _checkShouldRightTrimDomText(t, e) {
                if (e) {
                    return false
                }
                return !gd(t)
            }
            _getTouchingViewTextNode(t, e) {
                const n = new ul({
                    startPosition: e ? hl._createAfter(t) : hl._createBefore(t),
                    direction: e ? "forward" : "backward"
                });
                for (const t of n) {
                    if (t.item.is("containerElement")) {
                        return null
                    } else if (t.item.is("element", "br")) {
                        return null
                    } else if (t.item.is("$textProxy")) {
                        return t.item
                    }
                }
                return null
            }
            _getTouchingInlineDomNode(t, e) {
                if (!t.parentNode) {
                    return null
                }
                const n = e ? "nextNode" : "previousNode";
                const o = t.ownerDocument;
                const i = Vd(t)[0];
                const r = o.createTreeWalker(i, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, {
                    acceptNode(t) {
                        if (ud(t)) {
                            return NodeFilter.FILTER_ACCEPT
                        }
                        if (t.tagName == "BR") {
                            return NodeFilter.FILTER_ACCEPT
                        }
                        return NodeFilter.FILTER_SKIP
                    }
                });
                r.currentNode = t;
                const s = r[n]();
                if (s !== null) {
                    const e = Ud(t, s);
                    if (e && !Yd(t, this.blockElements, e) && !Yd(s, this.blockElements, e)) {
                        return s
                    }
                }
                return null
            }
        }

        function Yd(t, e, n) {
            let o = Vd(t);
            if (n) {
                o = o.slice(o.indexOf(n) + 1)
            }
            return o.some((t => t.tagName && e.includes(t.tagName.toLowerCase())))
        }

        function Hd(t, e) {
            while (t && t != Fd.document) {
                e(t);
                t = t.parentNode
            }
        }

        function qd(t, e) {
            const n = ud(t) && t.data == " ";
            return n && Wd(t, e) && t.parentNode.childNodes.length === 1
        }

        function Wd(t, e) {
            const n = t.parentNode;
            return n && n.tagName && e.includes(n.tagName.toLowerCase())
        }

        function Qd(t) {
            const e = Object.prototype.toString.apply(t);
            if (e == "[object Window]") {
                return true
            }
            if (e == "[object global]") {
                return true
            }
            return false
        }
        const $d = Hc({}, ds, {
            listenTo(t, ...e) {
                if (Td(t) || Qd(t)) {
                    const n = this._getProxyEmitter(t) || new Jd(t);
                    n.attach(...e);
                    t = n
                }
                ds.listenTo.call(this, t, ...e)
            },
            stopListening(t, e, n) {
                if (Td(t) || Qd(t)) {
                    const e = this._getProxyEmitter(t);
                    if (!e) {
                        return
                    }
                    t = e
                }
                ds.stopListening.call(this, t, e, n);
                if (t instanceof Jd) {
                    t.detach(e)
                }
            },
            _getProxyEmitter(t) {
                return us(this, Xd(t))
            }
        });
        var Zd = $d;
        class Jd {
            constructor(t) {
                hs(this, Xd(t));
                this._domNode = t
            }
        }
        Hc(Jd.prototype, ds, {
            attach(t, e, n = {}) {
                if (this._domListeners && this._domListeners[t]) {
                    return
                }
                const o = {
                    capture: !!n.useCapture,
                    passive: !!n.usePassive
                };
                const i = this._createDomListener(t, o);
                this._domNode.addEventListener(t, i, o);
                if (!this._domListeners) {
                    this._domListeners = {}
                }
                this._domListeners[t] = i
            },
            detach(t) {
                let e;
                if (this._domListeners[t] && (!(e = this._events[t]) || !e.callbacks.length)) {
                    this._domListeners[t].removeListener()
                }
            },
            _createDomListener(t, e) {
                const n = e => {
                    this.fire(t, e)
                };
                n.removeListener = () => {
                    this._domNode.removeEventListener(t, n, e);
                    delete this._domListeners[t]
                };
                return n
            }
        });

        function Xd(t) {
            return t["data-ck-expando"] || (t["data-ck-expando"] = ns())
        }
        class tu {
            constructor(t) {
                this.view = t;
                this.document = t.document;
                this.isEnabled = false
            }
            enable() {
                this.isEnabled = true
            }
            disable() {
                this.isEnabled = false
            }
            destroy() {
                this.disable();
                this.stopListening()
            }
            checkShouldIgnoreEventFromTarget(t) {
                if (t && t.nodeType === 3) {
                    t = t.parentNode
                }
                if (!t || t.nodeType !== 1) {
                    return false
                }
                return t.matches("[data-cke-ignore-events], [data-cke-ignore-events] *")
            }
        }
        _s(tu, Zd);
        var eu = "__lodash_hash_undefined__";

        function nu(t) {
            this.__data__.set(t, eu);
            return this
        }
        var ou = nu;

        function iu(t) {
            return this.__data__.has(t)
        }
        var ru = iu;

        function su(t) {
            var e = -1,
                n = t == null ? 0 : t.length;
            this.__data__ = new Ae;
            while (++e < n) {
                this.add(t[e])
            }
        }
        su.prototype.add = su.prototype.push = ou;
        su.prototype.has = ru;
        var au = su;

        function cu(t, e) {
            var n = -1,
                o = t == null ? 0 : t.length;
            while (++n < o) {
                if (e(t[n], n, t)) {
                    return true
                }
            }
            return false
        }
        var lu = cu;

        function du(t, e) {
            return t.has(e)
        }
        var uu = du;
        var hu = 1,
            fu = 2;

        function pu(t, e, n, o, i, r) {
            var s = n & hu,
                a = t.length,
                c = e.length;
            if (a != c && !(s && c > a)) {
                return false
            }
            var l = r.get(t);
            if (l && r.get(e)) {
                return l == e
            }
            var d = -1,
                u = true,
                h = n & fu ? new au : undefined;
            r.set(t, e);
            r.set(e, t);
            while (++d < a) {
                var f = t[d],
                    p = e[d];
                if (o) {
                    var m = s ? o(p, f, d, e, t, r) : o(f, p, d, t, e, r)
                }
                if (m !== undefined) {
                    if (m) {
                        continue
                    }
                    u = false;
                    break
                }
                if (h) {
                    if (!lu(e, (function(t, e) {
                            if (!uu(h, e) && (f === t || i(f, t, n, o, r))) {
                                return h.push(e)
                            }
                        }))) {
                        u = false;
                        break
                    }
                } else if (!(f === p || i(f, p, n, o, r))) {
                    u = false;
                    break
                }
            }
            r["delete"](t);
            r["delete"](e);
            return u
        }
        var mu = pu;

        function gu(t) {
            var e = -1,
                n = Array(t.size);
            t.forEach((function(t, o) {
                n[++e] = [o, t]
            }));
            return n
        }
        var ku = gu;

        function bu(t) {
            var e = -1,
                n = Array(t.size);
            t.forEach((function(t) {
                n[++e] = t
            }));
            return n
        }
        var wu = bu;
        var Au = 1,
            Cu = 2;
        var _u = "[object Boolean]",
            vu = "[object Date]",
            yu = "[object Error]",
            xu = "[object Map]",
            Du = "[object Number]",
            Mu = "[object RegExp]",
            Eu = "[object Set]",
            Su = "[object String]",
            Tu = "[object Symbol]";
        var Iu = "[object ArrayBuffer]",
            Nu = "[object DataView]";
        var Pu = r ? r.prototype : undefined,
            Bu = Pu ? Pu.valueOf : undefined;

        function Lu(t, e, n, o, i, r, s) {
            switch (n) {
                case Nu:
                    if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) {
                        return false
                    }
                    t = t.buffer;
                    e = e.buffer;
                case Iu:
                    if (t.byteLength != e.byteLength || !r(new fi(t), new fi(e))) {
                        return false
                    }
                    return true;
                case _u:
                case vu:
                case Du:
                    return j(+t, +e);
                case yu:
                    return t.name == e.name && t.message == e.message;
                case Mu:
                case Su:
                    return t == e + "";
                case xu:
                    var a = ku;
                case Eu:
                    var c = o & Au;
                    a || (a = wu);
                    if (t.size != e.size && !c) {
                        return false
                    }
                    var l = s.get(t);
                    if (l) {
                        return l == e
                    }
                    o |= Cu;
                    s.set(t, e);
                    var d = mu(a(t), a(e), o, i, r, s);
                    s["delete"](t);
                    return d;
                case Tu:
                    if (Bu) {
                        return Bu.call(t) == Bu.call(e)
                    }
            }
            return false
        }
        var Ou = Lu;
        var zu = 1;
        var ju = Object.prototype;
        var Fu = ju.hasOwnProperty;

        function Ru(t, e, n, o, i, r) {
            var s = n & zu,
                a = jo(t),
                c = a.length,
                l = jo(e),
                d = l.length;
            if (c != d && !s) {
                return false
            }
            var u = c;
            while (u--) {
                var h = a[u];
                if (!(s ? h in e : Fu.call(e, h))) {
                    return false
                }
            }
            var f = r.get(t);
            if (f && r.get(e)) {
                return f == e
            }
            var p = true;
            r.set(t, e);
            r.set(e, t);
            var m = s;
            while (++u < c) {
                h = a[u];
                var g = t[h],
                    k = e[h];
                if (o) {
                    var b = s ? o(k, g, h, e, t, r) : o(g, k, h, t, e, r)
                }
                if (!(b === undefined ? g === k || i(g, k, n, o, r) : b)) {
                    p = false;
                    break
                }
                m || (m = h == "constructor")
            }
            if (p && !m) {
                var w = t.constructor,
                    A = e.constructor;
                if (w != A && ("constructor" in t && "constructor" in e) && !(typeof w == "function" && w instanceof w && typeof A == "function" && A instanceof A)) {
                    p = false
                }
            }
            r["delete"](t);
            r["delete"](e);
            return p
        }
        var Vu = Ru;
        var Uu = 1;
        var Gu = "[object Arguments]",
            Ku = "[object Array]",
            Yu = "[object Object]";
        var Hu = Object.prototype;
        var qu = Hu.hasOwnProperty;

        function Wu(t, e, n, o, i, r) {
            var s = Qe(t),
                a = Qe(e),
                c = s ? Ku : ai(t),
                l = a ? Ku : ai(e);
            c = c == Gu ? Yu : c;
            l = l == Gu ? Yu : l;
            var d = c == Yu,
                u = l == Yu,
                h = c == l;
            if (h && Object($e["a"])(t)) {
                if (!Object($e["a"])(e)) {
                    return false
                }
                s = true;
                d = false
            }
            if (h && !d) {
                r || (r = new xe);
                return s || zn(t) ? mu(t, e, n, o, i, r) : Ou(t, e, c, n, o, i, r)
            }
            if (!(n & Uu)) {
                var f = d && qu.call(t, "__wrapped__"),
                    p = u && qu.call(e, "__wrapped__");
                if (f || p) {
                    var m = f ? t.value() : t,
                        g = p ? e.value() : e;
                    r || (r = new xe);
                    return i(m, g, n, o, r)
                }
            }
            if (!h) {
                return false
            }
            r || (r = new xe);
            return Vu(t, e, n, o, i, r)
        }
        var Qu = Wu;

        function $u(t, e, n, o, i) {
            if (t === e) {
                return true
            }
            if (t == null || e == null || !D(t) && !D(e)) {
                return t !== t && e !== e
            }
            return Qu(t, e, n, o, $u, i)
        }
        var Zu = $u;

        function Ju(t, e, n) {
            n = typeof n == "function" ? n : undefined;
            var o = n ? n(t, e) : undefined;
            return o === undefined ? Zu(t, e, undefined, n) : !!o
        }
        var Xu = Ju;
        class th extends tu {
            constructor(t) {
                super(t);
                this._config = {
                    childList: true,
                    characterData: true,
                    characterDataOldValue: true,
                    subtree: true
                };
                this.domConverter = t.domConverter;
                this.renderer = t._renderer;
                this._domElements = [];
                this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this))
            }
            flush() {
                this._onMutations(this._mutationObserver.takeRecords())
            }
            observe(t) {
                this._domElements.push(t);
                if (this.isEnabled) {
                    this._mutationObserver.observe(t, this._config)
                }
            }
            enable() {
                super.enable();
                for (const t of this._domElements) {
                    this._mutationObserver.observe(t, this._config)
                }
            }
            disable() {
                super.disable();
                this._mutationObserver.disconnect()
            }
            destroy() {
                super.destroy();
                this._mutationObserver.disconnect()
            }
            _onMutations(t) {
                if (t.length === 0) {
                    return
                }
                const e = this.domConverter;
                const n = new Map;
                const o = new Set;
                for (const n of t) {
                    if (n.type === "childList") {
                        const t = e.mapDomToView(n.target);
                        if (t && (t.is("uiElement") || t.is("rawElement"))) {
                            continue
                        }
                        if (t && !this._isBogusBrMutation(n)) {
                            o.add(t)
                        }
                    }
                }
                for (const i of t) {
                    const t = e.mapDomToView(i.target);
                    if (t && (t.is("uiElement") || t.is("rawElement"))) {
                        continue
                    }
                    if (i.type === "characterData") {
                        const t = e.findCorrespondingViewText(i.target);
                        if (t && !o.has(t.parent)) {
                            n.set(t, {
                                type: "text",
                                oldText: t.data,
                                newText: bd(i.target),
                                node: t
                            })
                        } else if (!t && gd(i.target)) {
                            o.add(e.mapDomToView(i.target.parentNode))
                        }
                    }
                }
                const i = [];
                for (const t of n.values()) {
                    this.renderer.markToSync("text", t.node);
                    i.push(t)
                }
                for (const t of o) {
                    const n = e.mapViewToDom(t);
                    const o = Array.from(t.getChildren());
                    const r = Array.from(e.domChildrenToView(n, {
                        withChildren: false
                    }));
                    if (!Xu(o, r, a)) {
                        this.renderer.markToSync("children", t);
                        i.push({
                            type: "children",
                            oldChildren: o,
                            newChildren: r,
                            node: t
                        })
                    }
                }
                const r = t[0].target.ownerDocument.getSelection();
                let s = null;
                if (r && r.anchorNode) {
                    const t = e.domPositionToView(r.anchorNode, r.anchorOffset);
                    const n = e.domPositionToView(r.focusNode, r.focusOffset);
                    if (t && n) {
                        s = new gl(t);
                        s.setFocus(n)
                    }
                }
                if (i.length) {
                    this.document.fire("mutations", i, s);
                    this.view.forceRender()
                }

                function a(t, e) {
                    if (Array.isArray(t)) {
                        return
                    }
                    if (t === e) {
                        return true
                    } else if (t.is("$text") && e.is("$text")) {
                        return t.data === e.data
                    }
                    return false
                }
            }
            _isBogusBrMutation(t) {
                let e = null;
                if (t.nextSibling === null && t.removedNodes.length === 0 && t.addedNodes.length == 1) {
                    e = this.domConverter.domToView(t.addedNodes[0], {
                        withChildren: false
                    })
                }
                return e && e.is("element", "br")
            }
        }
        class eh {
            constructor(t, e, n) {
                this.view = t;
                this.document = t.document;
                this.domEvent = e;
                this.domTarget = e.target;
                Hc(this, n)
            }
            get target() {
                return this.view.domConverter.mapDomToView(this.domTarget)
            }
            preventDefault() {
                this.domEvent.preventDefault()
            }
            stopPropagation() {
                this.domEvent.stopPropagation()
            }
        }
        class nh extends tu {
            constructor(t) {
                super(t);
                this.useCapture = false
            }
            observe(t) {
                const e = typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType;
                e.forEach((e => {
                    this.listenTo(t, e, ((t, e) => {
                        if (this.isEnabled && !this.checkShouldIgnoreEventFromTarget(e.target)) {
                            this.onDomEvent(e)
                        }
                    }), {
                        useCapture: this.useCapture
                    })
                }))
            }
            fire(t, e, n) {
                if (this.isEnabled) {
                    this.document.fire(t, new eh(this.view, e, n))
                }
            }
        }
        class oh extends nh {
            constructor(t) {
                super(t);
                this.domEventType = ["keydown", "keyup"]
            }
            onDomEvent(t) {
                this.fire(t.type, t, {
                    keyCode: t.keyCode,
                    altKey: t.altKey,
                    ctrlKey: t.ctrlKey || t.metaKey,
                    shiftKey: t.shiftKey,
                    get keystroke() {
                        return zl(this)
                    }
                })
            }
        }
        var ih = function() {
            return o["a"].Date.now()
        };
        var rh = ih;
        var sh = 0 / 0;
        var ah = /^\s+|\s+$/g;
        var ch = /^[-+]0x[0-9a-f]+$/i;
        var lh = /^0b[01]+$/i;
        var dh = /^0o[0-7]+$/i;
        var uh = parseInt;

        function hh(t) {
            if (typeof t == "number") {
                return t
            }
            if (Xs(t)) {
                return sh
            }
            if (ct(t)) {
                var e = typeof t.valueOf == "function" ? t.valueOf() : t;
                t = ct(e) ? e + "" : e
            }
            if (typeof t != "string") {
                return t === 0 ? t : +t
            }
            t = t.replace(ah, "");
            var n = lh.test(t);
            return n || dh.test(t) ? uh(t.slice(2), n ? 2 : 8) : ch.test(t) ? sh : +t
        }
        var fh = hh;
        var ph = "Expected a function";
        var mh = Math.max,
            gh = Math.min;

        function kh(t, e, n) {
            var o, i, r, s, a, c, l = 0,
                d = false,
                u = false,
                h = true;
            if (typeof t != "function") {
                throw new TypeError(ph)
            }
            e = fh(e) || 0;
            if (ct(n)) {
                d = !!n.leading;
                u = "maxWait" in n;
                r = u ? mh(fh(n.maxWait) || 0, e) : r;
                h = "trailing" in n ? !!n.trailing : h
            }

            function f(e) {
                var n = o,
                    r = i;
                o = i = undefined;
                l = e;
                s = t.apply(r, n);
                return s
            }

            function p(t) {
                l = t;
                a = setTimeout(k, e);
                return d ? f(t) : s
            }

            function m(t) {
                var n = t - c,
                    o = t - l,
                    i = e - n;
                return u ? gh(i, r - o) : i
            }

            function g(t) {
                var n = t - c,
                    o = t - l;
                return c === undefined || n >= e || n < 0 || u && o >= r
            }

            function k() {
                var t = rh();
                if (g(t)) {
                    return b(t)
                }
                a = setTimeout(k, m(t))
            }

            function b(t) {
                a = undefined;
                if (h && o) {
                    return f(t)
                }
                o = i = undefined;
                return s
            }

            function w() {
                if (a !== undefined) {
                    clearTimeout(a)
                }
                l = 0;
                o = c = i = a = undefined
            }

            function A() {
                return a === undefined ? s : b(rh())
            }

            function C() {
                var t = rh(),
                    n = g(t);
                o = arguments;
                i = this;
                c = t;
                if (n) {
                    if (a === undefined) {
                        return p(c)
                    }
                    if (u) {
                        clearTimeout(a);
                        a = setTimeout(k, e);
                        return f(c)
                    }
                }
                if (a === undefined) {
                    a = setTimeout(k, e)
                }
                return s
            }
            C.cancel = w;
            C.flush = A;
            return C
        }
        var bh = kh;
        class wh extends tu {
            constructor(t) {
                super(t);
                this._fireSelectionChangeDoneDebounced = bh((t => this.document.fire("selectionChangeDone", t)), 200)
            }
            observe() {
                const t = this.document;
                t.on("keydown", ((e, n) => {
                    const o = t.selection;
                    if (o.isFake && Rl(n.keyCode) && this.isEnabled) {
                        n.preventDefault();
                        this._handleSelectionMove(n.keyCode)
                    }
                }), {
                    priority: "lowest"
                })
            }
            destroy() {
                super.destroy();
                this._fireSelectionChangeDoneDebounced.cancel()
            }
            _handleSelectionMove(t) {
                const e = this.document.selection;
                const n = new gl(e.getRanges(), {
                    backward: e.isBackward,
                    fake: false
                });
                if (t == Ol.arrowleft || t == Ol.arrowup) {
                    n.setTo(n.getFirstPosition())
                }
                if (t == Ol.arrowright || t == Ol.arrowdown) {
                    n.setTo(n.getLastPosition())
                }
                const o = {
                    oldSelection: e,
                    newSelection: n,
                    domSelection: null
                };
                this.document.fire("selectionChange", o);
                this._fireSelectionChangeDoneDebounced(o)
            }
        }
        class Ah extends tu {
            constructor(t) {
                super(t);
                this.mutationObserver = t.getObserver(th);
                this.selection = this.document.selection;
                this.domConverter = t.domConverter;
                this._documents = new WeakSet;
                this._fireSelectionChangeDoneDebounced = bh((t => this.document.fire("selectionChangeDone", t)), 200);
                this._clearInfiniteLoopInterval = setInterval((() => this._clearInfiniteLoop()), 1e3);
                this._loopbackCounter = 0
            }
            observe(t) {
                const e = t.ownerDocument;
                if (this._documents.has(e)) {
                    return
                }
                this.listenTo(e, "selectionchange", ((t, n) => {
                    this._handleSelectionChange(n, e)
                }));
                this._documents.add(e)
            }
            destroy() {
                super.destroy();
                clearInterval(this._clearInfiniteLoopInterval);
                this._fireSelectionChangeDoneDebounced.cancel()
            }
            _handleSelectionChange(t, e) {
                if (!this.isEnabled) {
                    return
                }
                const n = e.defaultView.getSelection();
                if (this.checkShouldIgnoreEventFromTarget(n.anchorNode)) {
                    return
                }
                this.mutationObserver.flush();
                const o = this.domConverter.domSelectionToView(n);
                if (o.rangeCount == 0) {
                    this.view.hasDomSelection = false;
                    return
                }
                this.view.hasDomSelection = true;
                if (this.selection.isEqual(o) && this.domConverter.isDomSelectionCorrect(n)) {
                    return
                }
                if (++this._loopbackCounter > 60) {
                    return
                }
                if (this.selection.isSimilar(o)) {
                    this.view.forceRender()
                } else {
                    const t = {
                        oldSelection: this.selection,
                        newSelection: o,
                        domSelection: n
                    };
                    this.document.fire("selectionChange", t);
                    this._fireSelectionChangeDoneDebounced(t)
                }
            }
            _clearInfiniteLoop() {
                this._loopbackCounter = 0
            }
        }
        class Ch extends nh {
            constructor(t) {
                super(t);
                this.domEventType = ["focus", "blur"];
                this.useCapture = true;
                const e = this.document;
                e.on("focus", (() => {
                    e.isFocused = true;
                    this._renderTimeoutId = setTimeout((() => t.forceRender()), 50)
                }));
                e.on("blur", ((n, o) => {
                    const i = e.selection.editableElement;
                    if (i === null || i === o.target) {
                        e.isFocused = false;
                        t.forceRender()
                    }
                }))
            }
            onDomEvent(t) {
                this.fire(t.type, t)
            }
            destroy() {
                if (this._renderTimeoutId) {
                    clearTimeout(this._renderTimeoutId)
                }
                super.destroy()
            }
        }
        class _h extends nh {
            constructor(t) {
                super(t);
                this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
                const e = this.document;
                e.on("compositionstart", (() => {
                    e.isComposing = true
                }));
                e.on("compositionend", (() => {
                    e.isComposing = false
                }))
            }
            onDomEvent(t) {
                this.fire(t.type, t)
            }
        }
        class vh extends nh {
            constructor(t) {
                super(t);
                this.domEventType = ["beforeinput"]
            }
            onDomEvent(t) {
                this.fire(t.type, t)
            }
        }

        function yh(t) {
            return Object.prototype.toString.apply(t) == "[object Range]"
        }

        function xh(t) {
            const e = t.ownerDocument.defaultView.getComputedStyle(t);
            return {
                top: parseInt(e.borderTopWidth, 10),
                right: parseInt(e.borderRightWidth, 10),
                bottom: parseInt(e.borderBottomWidth, 10),
                left: parseInt(e.borderLeftWidth, 10)
            }
        }
        const Dh = ["top", "right", "bottom", "left", "width", "height"];
        class Mh {
            constructor(t) {
                const e = yh(t);
                Object.defineProperty(this, "_source", {
                    value: t._source || t,
                    writable: true,
                    enumerable: false
                });
                if (Wr(t) || e) {
                    if (e) {
                        const e = Mh.getDomRangeRects(t);
                        Eh(this, Mh.getBoundingRect(e))
                    } else {
                        Eh(this, t.getBoundingClientRect())
                    }
                } else if (Qd(t)) {
                    const {
                        innerWidth: e,
                        innerHeight: n
                    } = t;
                    Eh(this, {
                        top: 0,
                        right: e,
                        bottom: n,
                        left: 0,
                        width: e,
                        height: n
                    })
                } else {
                    Eh(this, t)
                }
            }
            clone() {
                return new Mh(this)
            }
            moveTo(t, e) {
                this.top = e;
                this.right = t + this.width;
                this.bottom = e + this.height;
                this.left = t;
                return this
            }
            moveBy(t, e) {
                this.top += e;
                this.right += t;
                this.left += t;
                this.bottom += e;
                return this
            }
            getIntersection(t) {
                const e = {
                    top: Math.max(this.top, t.top),
                    right: Math.min(this.right, t.right),
                    bottom: Math.min(this.bottom, t.bottom),
                    left: Math.max(this.left, t.left)
                };
                e.width = e.right - e.left;
                e.height = e.bottom - e.top;
                if (e.width < 0 || e.height < 0) {
                    return null
                } else {
                    return new Mh(e)
                }
            }
            getIntersectionArea(t) {
                const e = this.getIntersection(t);
                if (e) {
                    return e.getArea()
                } else {
                    return 0
                }
            }
            getArea() {
                return this.width * this.height
            }
            getVisible() {
                const t = this._source;
                let e = this.clone();
                if (!Sh(t)) {
                    let n = t.parentNode || t.commonAncestorContainer;
                    while (n && !Sh(n)) {
                        const t = new Mh(n);
                        const o = e.getIntersection(t);
                        if (o) {
                            if (o.getArea() < e.getArea()) {
                                e = o
                            }
                        } else {
                            return null
                        }
                        n = n.parentNode
                    }
                }
                return e
            }
            isEqual(t) {
                for (const e of Dh) {
                    if (this[e] !== t[e]) {
                        return false
                    }
                }
                return true
            }
            contains(t) {
                const e = this.getIntersection(t);
                return !!(e && e.isEqual(t))
            }
            excludeScrollbarsAndBorders() {
                const t = this._source;
                let e, n, o;
                if (Qd(t)) {
                    e = t.innerWidth - t.document.documentElement.clientWidth;
                    n = t.innerHeight - t.document.documentElement.clientHeight;
                    o = t.getComputedStyle(t.document.documentElement).direction
                } else {
                    const i = xh(this._source);
                    e = t.offsetWidth - t.clientWidth - i.left - i.right;
                    n = t.offsetHeight - t.clientHeight - i.top - i.bottom;
                    o = t.ownerDocument.defaultView.getComputedStyle(t).direction;
                    this.left += i.left;
                    this.top += i.top;
                    this.right -= i.right;
                    this.bottom -= i.bottom;
                    this.width = this.right - this.left;
                    this.height = this.bottom - this.top
                }
                this.width -= e;
                if (o === "ltr") {
                    this.right -= e
                } else {
                    this.left += e
                }
                this.height -= n;
                this.bottom -= n;
                return this
            }
            static getDomRangeRects(t) {
                const e = [];
                const n = Array.from(t.getClientRects());
                if (n.length) {
                    for (const t of n) {
                        e.push(new Mh(t))
                    }
                } else {
                    let n = t.startContainer;
                    if (ud(n)) {
                        n = n.parentNode
                    }
                    const o = new Mh(n.getBoundingClientRect());
                    o.right = o.left;
                    o.width = 0;
                    e.push(o)
                }
                return e
            }
            static getBoundingRect(t) {
                const e = {
                    left: Number.POSITIVE_INFINITY,
                    top: Number.POSITIVE_INFINITY,
                    right: Number.NEGATIVE_INFINITY,
                    bottom: Number.NEGATIVE_INFINITY
                };
                let n = 0;
                for (const o of t) {
                    n++;
                    e.left = Math.min(e.left, o.left);
                    e.top = Math.min(e.top, o.top);
                    e.right = Math.max(e.right, o.right);
                    e.bottom = Math.max(e.bottom, o.bottom)
                }
                if (n == 0) {
                    return null
                }
                e.width = e.right - e.left;
                e.height = e.bottom - e.top;
                return new Mh(e)
            }
        }

        function Eh(t, e) {
            for (const n of Dh) {
                t[n] = e[n]
            }
        }

        function Sh(t) {
            if (!Wr(t)) {
                return false
            }
            return t === t.ownerDocument.body
        }
        const Th = {};

        function Ih({
            target: t,
            viewportOffset: e = 0
        }) {
            const n = Fh(t);
            let o = n;
            let i = null;
            while (o) {
                let r;
                if (o == n) {
                    r = Rh(t)
                } else {
                    r = Rh(i)
                }
                Bh(r, (() => Vh(t, o)));
                const s = Vh(t, o);
                Ph(o, s, e);
                if (o.parent != o) {
                    i = o.frameElement;
                    o = o.parent;
                    if (!i) {
                        return
                    }
                } else {
                    o = null
                }
            }
        }

        function Nh(t) {
            const e = Rh(t);
            Bh(e, (() => new Mh(t)))
        }
        Object.assign(Th, {
            scrollViewportToShowTarget: Ih,
            scrollAncestorsToShowTarget: Nh
        });

        function Ph(t, e, n) {
            const o = e.clone().moveBy(0, n);
            const i = e.clone().moveBy(0, -n);
            const r = new Mh(t).excludeScrollbarsAndBorders();
            const s = [i, o];
            if (!s.every((t => r.contains(t)))) {
                let {
                    scrollX: s,
                    scrollY: a
                } = t;
                if (Oh(i, r)) {
                    a -= r.top - e.top + n
                } else if (Lh(o, r)) {
                    a += e.bottom - r.bottom + n
                }
                if (zh(e, r)) {
                    s -= r.left - e.left + n
                } else if (jh(e, r)) {
                    s += e.right - r.right + n
                }
                t.scrollTo(s, a)
            }
        }

        function Bh(t, e) {
            const n = Fh(t);
            let o, i;
            while (t != n.document.body) {
                i = e();
                o = new Mh(t).excludeScrollbarsAndBorders();
                if (!o.contains(i)) {
                    if (Oh(i, o)) {
                        t.scrollTop -= o.top - i.top
                    } else if (Lh(i, o)) {
                        t.scrollTop += i.bottom - o.bottom
                    }
                    if (zh(i, o)) {
                        t.scrollLeft -= o.left - i.left
                    } else if (jh(i, o)) {
                        t.scrollLeft += i.right - o.right
                    }
                }
                t = t.parentNode
            }
        }

        function Lh(t, e) {
            return t.bottom > e.bottom
        }

        function Oh(t, e) {
            return t.top < e.top
        }

        function zh(t, e) {
            return t.left < e.left
        }

        function jh(t, e) {
            return t.right > e.right
        }

        function Fh(t) {
            if (yh(t)) {
                return t.startContainer.ownerDocument.defaultView
            } else {
                return t.ownerDocument.defaultView
            }
        }

        function Rh(t) {
            if (yh(t)) {
                let e = t.commonAncestorContainer;
                if (ud(e)) {
                    e = e.parentNode
                }
                return e
            } else {
                return t.parentNode
            }
        }

        function Vh(t, e) {
            const n = Fh(t);
            const o = new Mh(t);
            if (n === e) {
                return o
            } else {
                let t = n;
                while (t != e) {
                    const e = t.frameElement;
                    const n = new Mh(e).excludeScrollbarsAndBorders();
                    o.moveBy(n.left, n.top);
                    t = t.parent
                }
            }
            return o
        }
        class Uh {
            constructor(t) {
                this.document = new bl(t);
                this.domConverter = new Kd(this.document);
                this.domRoots = new Map;
                this.set("isRenderingInProgress", false);
                this.set("hasDomSelection", false);
                this._renderer = new Id(this.domConverter, this.document.selection);
                this._renderer.bind("isFocused").to(this.document);
                this._initialDomRootAttributes = new WeakMap;
                this._observers = new Map;
                this._ongoingChange = false;
                this._postFixersInProgress = false;
                this._renderingDisabled = false;
                this._hasChangedSinceTheLastRendering = false;
                this._writer = new Xl(this.document);
                this.addObserver(th);
                this.addObserver(Ah);
                this.addObserver(Ch);
                this.addObserver(oh);
                this.addObserver(wh);
                this.addObserver(_h);
                if (Ml.isAndroid) {
                    this.addObserver(vh)
                }
                wd(this);
                Hl(this);
                this.on("render", (() => {
                    this._render();
                    this.document.fire("layoutChanged");
                    this._hasChangedSinceTheLastRendering = false
                }));
                this.listenTo(this.document.selection, "change", (() => {
                    this._hasChangedSinceTheLastRendering = true
                }))
            }
            attachDomRoot(t, e = "main") {
                const n = this.document.getRoot(e);
                n._name = t.tagName.toLowerCase();
                const o = {};
                for (const {
                        name: e,
                        value: i
                    } of Array.from(t.attributes)) {
                    o[e] = i;
                    if (e === "class") {
                        this._writer.addClass(i.split(" "), n)
                    } else {
                        this._writer.setAttribute(e, i, n)
                    }
                }
                this._initialDomRootAttributes.set(t, o);
                const i = () => {
                    this._writer.setAttribute("contenteditable", !n.isReadOnly, n);
                    if (n.isReadOnly) {
                        this._writer.addClass("ck-read-only", n)
                    } else {
                        this._writer.removeClass("ck-read-only", n)
                    }
                };
                i();
                this.domRoots.set(e, t);
                this.domConverter.bindElements(t, n);
                this._renderer.markToSync("children", n);
                this._renderer.markToSync("attributes", n);
                this._renderer.domDocuments.add(t.ownerDocument);
                n.on("change:children", ((t, e) => this._renderer.markToSync("children", e)));
                n.on("change:attributes", ((t, e) => this._renderer.markToSync("attributes", e)));
                n.on("change:text", ((t, e) => this._renderer.markToSync("text", e)));
                n.on("change:isReadOnly", (() => this.change(i)));
                n.on("change", (() => {
                    this._hasChangedSinceTheLastRendering = true
                }));
                for (const n of this._observers.values()) {
                    n.observe(t, e)
                }
            }
            detachDomRoot(t) {
                const e = this.domRoots.get(t);
                Array.from(e.attributes).forEach((({
                    name: t
                }) => e.removeAttribute(t)));
                const n = this._initialDomRootAttributes.get(e);
                for (const t in n) {
                    e.setAttribute(t, n[t])
                }
                this.domRoots.delete(t);
                this.domConverter.unbindDomElement(e)
            }
            getDomRoot(t = "main") {
                return this.domRoots.get(t)
            }
            addObserver(t) {
                let e = this._observers.get(t);
                if (e) {
                    return e
                }
                e = new t(this);
                this._observers.set(t, e);
                for (const [t, n] of this.domRoots) {
                    e.observe(n, t)
                }
                e.enable();
                return e
            }
            getObserver(t) {
                return this._observers.get(t)
            }
            disableObservers() {
                for (const t of this._observers.values()) {
                    t.disable()
                }
            }
            enableObservers() {
                for (const t of this._observers.values()) {
                    t.enable()
                }
            }
            scrollToTheSelection() {
                const t = this.document.selection.getFirstRange();
                if (t) {
                    Ih({
                        target: this.domConverter.viewRangeToDom(t),
                        viewportOffset: 20
                    })
                }
            }
            focus() {
                if (!this.document.isFocused) {
                    const t = this.document.selection.editableElement;
                    if (t) {
                        this.domConverter.focus(t);
                        this.forceRender()
                    } else {}
                }
            }
            change(t) {
                if (this.isRenderingInProgress || this._postFixersInProgress) {
                    throw new ss["a"]("cannot-change-view-tree", this)
                }
                try {
                    if (this._ongoingChange) {
                        return t(this._writer)
                    }
                    this._ongoingChange = true;
                    const e = t(this._writer);
                    this._ongoingChange = false;
                    if (!this._renderingDisabled && this._hasChangedSinceTheLastRendering) {
                        this._postFixersInProgress = true;
                        this.document._callPostFixers(this._writer);
                        this._postFixersInProgress = false;
                        this.fire("render")
                    }
                    return e
                } catch (t) {
                    ss["a"].rethrowUnexpectedError(t, this)
                }
            }
            forceRender() {
                this._hasChangedSinceTheLastRendering = true;
                this.change((() => {}))
            }
            destroy() {
                for (const t of this._observers.values()) {
                    t.destroy()
                }
                this.document.destroy();
                this.stopListening()
            }
            createPositionAt(t, e) {
                return hl._createAt(t, e)
            }
            createPositionAfter(t) {
                return hl._createAfter(t)
            }
            createPositionBefore(t) {
                return hl._createBefore(t)
            }
            createRange(t, e) {
                return new fl(t, e)
            }
            createRangeOn(t) {
                return fl._createOn(t)
            }
            createRangeIn(t) {
                return fl._createIn(t)
            }
            createSelection(t, e, n) {
                return new gl(t, e, n)
            }
            _disableRendering(t) {
                this._renderingDisabled = t;
                if (t == false) {
                    this.change((() => {}))
                }
            }
            _render() {
                this.isRenderingInProgress = true;
                this.disableObservers();
                this._renderer.render();
                this.enableObservers();
                this.isRenderingInProgress = false
            }
        }
        _s(Uh, Zc);
        class Gh {
            constructor(t) {
                this.parent = null;
                this._attrs = Ks(t)
            }
            get index() {
                let t;
                if (!this.parent) {
                    return null
                }
                if ((t = this.parent.getChildIndex(this)) === null) {
                    throw new ss["a"]("model-node-not-found-in-parent", this)
                }
                return t
            }
            get startOffset() {
                let t;
                if (!this.parent) {
                    return null
                }
                if ((t = this.parent.getChildStartOffset(this)) === null) {
                    throw new ss["a"]("model-node-not-found-in-parent", this)
                }
                return t
            }
            get offsetSize() {
                return 1
            }
            get endOffset() {
                if (!this.parent) {
                    return null
                }
                return this.startOffset + this.offsetSize
            }
            get nextSibling() {
                const t = this.index;
                return t !== null && this.parent.getChild(t + 1) || null
            }
            get previousSibling() {
                const t = this.index;
                return t !== null && this.parent.getChild(t - 1) || null
            }
            get root() {
                let t = this;
                while (t.parent) {
                    t = t.parent
                }
                return t
            }
            isAttached() {
                return this.root.is("rootElement")
            }
            getPath() {
                const t = [];
                let e = this;
                while (e.parent) {
                    t.unshift(e.startOffset);
                    e = e.parent
                }
                return t
            }
            getAncestors(t = {
                includeSelf: false,
                parentFirst: false
            }) {
                const e = [];
                let n = t.includeSelf ? this : this.parent;
                while (n) {
                    e[t.parentFirst ? "push" : "unshift"](n);
                    n = n.parent
                }
                return e
            }
            getCommonAncestor(t, e = {}) {
                const n = this.getAncestors(e);
                const o = t.getAncestors(e);
                let i = 0;
                while (n[i] == o[i] && n[i]) {
                    i++
                }
                return i === 0 ? null : n[i - 1]
            }
            isBefore(t) {
                if (this == t) {
                    return false
                }
                if (this.root !== t.root) {
                    return false
                }
                const e = this.getPath();
                const n = t.getPath();
                const o = Os(e, n);
                switch (o) {
                    case "prefix":
                        return true;
                    case "extension":
                        return false;
                    default:
                        return e[o] < n[o]
                }
            }
            isAfter(t) {
                if (this == t) {
                    return false
                }
                if (this.root !== t.root) {
                    return false
                }
                return !this.isBefore(t)
            }
            hasAttribute(t) {
                return this._attrs.has(t)
            }
            getAttribute(t) {
                return this._attrs.get(t)
            }
            getAttributes() {
                return this._attrs.entries()
            }
            getAttributeKeys() {
                return this._attrs.keys()
            }
            toJSON() {
                const t = {};
                if (this._attrs.size) {
                    t.attributes = Array.from(this._attrs).reduce(((t, e) => {
                        t[e[0]] = e[1];
                        return t
                    }), {})
                }
                return t
            }
            is(t) {
                return t === "node" || t === "model:node"
            }
            _clone() {
                return new Gh(this._attrs)
            }
            _remove() {
                this.parent._removeChildren(this.index)
            }
            _setAttribute(t, e) {
                this._attrs.set(t, e)
            }
            _setAttributesTo(t) {
                this._attrs = Ks(t)
            }
            _removeAttribute(t) {
                return this._attrs.delete(t)
            }
            _clearAttributes() {
                this._attrs.clear()
            }
        }
        class Kh extends Gh {
            constructor(t, e) {
                super(e);
                this._data = t || ""
            }
            get offsetSize() {
                return this.data.length
            }
            get data() {
                return this._data
            }
            is(t) {
                return t === "$text" || t === "model:$text" || t === "text" || t === "model:text" || t === "node" || t === "model:node"
            }
            toJSON() {
                const t = super.toJSON();
                t.data = this.data;
                return t
            }
            _clone() {
                return new Kh(this.data, this.getAttributes())
            }
            static fromJSON(t) {
                return new Kh(t.data, t.attributes)
            }
        }
        class Yh {
            constructor(t, e, n) {
                this.textNode = t;
                if (e < 0 || e > t.offsetSize) {
                    throw new ss["a"]("model-textproxy-wrong-offsetintext", this)
                }
                if (n < 0 || e + n > t.offsetSize) {
                    throw new ss["a"]("model-textproxy-wrong-length", this)
                }
                this.data = t.data.substring(e, e + n);
                this.offsetInText = e
            }
            get startOffset() {
                return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null
            }
            get offsetSize() {
                return this.data.length
            }
            get endOffset() {
                return this.startOffset !== null ? this.startOffset + this.offsetSize : null
            }
            get isPartial() {
                return this.offsetSize !== this.textNode.offsetSize
            }
            get parent() {
                return this.textNode.parent
            }
            get root() {
                return this.textNode.root
            }
            is(t) {
                return t === "$textProxy" || t === "model:$textProxy" || t === "textProxy" || t === "model:textProxy"
            }
            getPath() {
                const t = this.textNode.getPath();
                if (t.length > 0) {
                    t[t.length - 1] += this.offsetInText
                }
                return t
            }
            getAncestors(t = {
                includeSelf: false,
                parentFirst: false
            }) {
                const e = [];
                let n = t.includeSelf ? this : this.parent;
                while (n) {
                    e[t.parentFirst ? "push" : "unshift"](n);
                    n = n.parent
                }
                return e
            }
            hasAttribute(t) {
                return this.textNode.hasAttribute(t)
            }
            getAttribute(t) {
                return this.textNode.getAttribute(t)
            }
            getAttributes() {
                return this.textNode.getAttributes()
            }
            getAttributeKeys() {
                return this.textNode.getAttributeKeys()
            }
        }
        class Hh {
            constructor(t) {
                this._nodes = [];
                if (t) {
                    this._insertNodes(0, t)
                }
            } [Symbol.iterator]() {
                return this._nodes[Symbol.iterator]()
            }
            get length() {
                return this._nodes.length
            }
            get maxOffset() {
                return this._nodes.reduce(((t, e) => t + e.offsetSize), 0)
            }
            getNode(t) {
                return this._nodes[t] || null
            }
            getNodeIndex(t) {
                const e = this._nodes.indexOf(t);
                return e == -1 ? null : e
            }
            getNodeStartOffset(t) {
                const e = this.getNodeIndex(t);
                return e === null ? null : this._nodes.slice(0, e).reduce(((t, e) => t + e.offsetSize), 0)
            }
            indexToOffset(t) {
                if (t == this._nodes.length) {
                    return this.maxOffset
                }
                const e = this._nodes[t];
                if (!e) {
                    throw new ss["a"]("model-nodelist-index-out-of-bounds", this)
                }
                return this.getNodeStartOffset(e)
            }
            offsetToIndex(t) {
                let e = 0;
                for (const n of this._nodes) {
                    if (t >= e && t < e + n.offsetSize) {
                        return this.getNodeIndex(n)
                    }
                    e += n.offsetSize
                }
                if (e != t) {
                    throw new ss["a"]("model-nodelist-offset-out-of-bounds", this, {
                        offset: t,
                        nodeList: this
                    })
                }
                return this.length
            }
            _insertNodes(t, e) {
                for (const t of e) {
                    if (!(t instanceof Gh)) {
                        throw new ss["a"]("model-nodelist-insertnodes-not-node", this)
                    }
                }
                this._nodes.splice(t, 0, ...e)
            }
            _removeNodes(t, e = 1) {
                return this._nodes.splice(t, e)
            }
            toJSON() {
                return this._nodes.map((t => t.toJSON()))
            }
        }
        class qh extends Gh {
            constructor(t, e, n) {
                super(e);
                this.name = t;
                this._children = new Hh;
                if (n) {
                    this._insertChild(0, n)
                }
            }
            get childCount() {
                return this._children.length
            }
            get maxOffset() {
                return this._children.maxOffset
            }
            get isEmpty() {
                return this.childCount === 0
            }
            is(t, e = null) {
                if (!e) {
                    return t === "element" || t === "model:element" || t === "node" || t === "model:node"
                }
                return e === this.name && (t === "element" || t === "model:element")
            }
            getChild(t) {
                return this._children.getNode(t)
            }
            getChildren() {
                return this._children[Symbol.iterator]()
            }
            getChildIndex(t) {
                return this._children.getNodeIndex(t)
            }
            getChildStartOffset(t) {
                return this._children.getNodeStartOffset(t)
            }
            offsetToIndex(t) {
                return this._children.offsetToIndex(t)
            }
            getNodeByPath(t) {
                let e = this;
                for (const n of t) {
                    e = e.getChild(e.offsetToIndex(n))
                }
                return e
            }
            findAncestor(t, e = {
                includeSelf: false
            }) {
                let n = e.includeSelf ? this : this.parent;
                while (n) {
                    if (n.name === t) {
                        return n
                    }
                    n = n.parent
                }
                return null
            }
            toJSON() {
                const t = super.toJSON();
                t.name = this.name;
                if (this._children.length > 0) {
                    t.children = [];
                    for (const e of this._children) {
                        t.children.push(e.toJSON())
                    }
                }
                return t
            }
            _clone(t = false) {
                const e = t ? Array.from(this._children).map((t => t._clone(true))) : null;
                return new qh(this.name, this.getAttributes(), e)
            }
            _appendChild(t) {
                this._insertChild(this.childCount, t)
            }
            _insertChild(t, e) {
                const n = Wh(e);
                for (const t of n) {
                    if (t.parent !== null) {
                        t._remove()
                    }
                    t.parent = this
                }
                this._children._insertNodes(t, n)
            }
            _removeChildren(t, e = 1) {
                const n = this._children._removeNodes(t, e);
                for (const t of n) {
                    t.parent = null
                }
                return n
            }
            static fromJSON(t) {
                let e = null;
                if (t.children) {
                    e = [];
                    for (const n of t.children) {
                        if (n.name) {
                            e.push(qh.fromJSON(n))
                        } else {
                            e.push(Kh.fromJSON(n))
                        }
                    }
                }
                return new qh(t.name, t.attributes, e)
            }
        }

        function Wh(t) {
            if (typeof t == "string") {
                return [new Kh(t)]
            }
            if (!Cs(t)) {
                t = [t]
            }
            return Array.from(t).map((t => {
                if (typeof t == "string") {
                    return new Kh(t)
                }
                if (t instanceof Yh) {
                    return new Kh(t.data, t.getAttributes())
                }
                return t
            }))
        }
        class Qh {
            constructor(t = {}) {
                if (!t.boundaries && !t.startPosition) {
                    throw new ss["a"]("model-tree-walker-no-start-position", null)
                }
                const e = t.direction || "forward";
                if (e != "forward" && e != "backward") {
                    throw new ss["a"]("model-tree-walker-unknown-direction", t, {
                        direction: e
                    })
                }
                this.direction = e;
                this.boundaries = t.boundaries || null;
                if (t.startPosition) {
                    this.position = t.startPosition.clone()
                } else {
                    this.position = Zh._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"])
                }
                this.position.stickiness = "toNone";
                this.singleCharacters = !!t.singleCharacters;
                this.shallow = !!t.shallow;
                this.ignoreElementEnd = !!t.ignoreElementEnd;
                this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
                this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
                this._visitedParent = this.position.parent
            } [Symbol.iterator]() {
                return this
            }
            skip(t) {
                let e, n, o, i;
                do {
                    o = this.position;
                    i = this._visitedParent;
                    ({
                        done: e,
                        value: n
                    } = this.next())
                } while (!e && t(n));
                if (!e) {
                    this.position = o;
                    this._visitedParent = i
                }
            }
            next() {
                if (this.direction == "forward") {
                    return this._next()
                } else {
                    return this._previous()
                }
            }
            _next() {
                const t = this.position;
                const e = this.position.clone();
                const n = this._visitedParent;
                if (n.parent === null && e.offset === n.maxOffset) {
                    return {
                        done: true
                    }
                }
                if (n === this._boundaryEndParent && e.offset == this.boundaries.end.offset) {
                    return {
                        done: true
                    }
                }
                const o = e.parent;
                const i = Jh(e, o);
                const r = i ? i : Xh(e, o, i);
                if (r instanceof qh) {
                    if (!this.shallow) {
                        e.path.push(0);
                        this._visitedParent = r
                    } else {
                        e.offset++
                    }
                    this.position = e;
                    return $h("elementStart", r, t, e, 1)
                } else if (r instanceof Kh) {
                    let o;
                    if (this.singleCharacters) {
                        o = 1
                    } else {
                        let t = r.endOffset;
                        if (this._boundaryEndParent == n && this.boundaries.end.offset < t) {
                            t = this.boundaries.end.offset
                        }
                        o = t - e.offset
                    }
                    const i = e.offset - r.startOffset;
                    const s = new Yh(r, i, o);
                    e.offset += o;
                    this.position = e;
                    return $h("text", s, t, e, o)
                } else {
                    e.path.pop();
                    e.offset++;
                    this.position = e;
                    this._visitedParent = n.parent;
                    if (this.ignoreElementEnd) {
                        return this._next()
                    } else {
                        return $h("elementEnd", n, t, e)
                    }
                }
            }
            _previous() {
                const t = this.position;
                const e = this.position.clone();
                const n = this._visitedParent;
                if (n.parent === null && e.offset === 0) {
                    return {
                        done: true
                    }
                }
                if (n == this._boundaryStartParent && e.offset == this.boundaries.start.offset) {
                    return {
                        done: true
                    }
                }
                const o = e.parent;
                const i = Jh(e, o);
                const r = i ? i : tf(e, o, i);
                if (r instanceof qh) {
                    e.offset--;
                    if (!this.shallow) {
                        e.path.push(r.maxOffset);
                        this.position = e;
                        this._visitedParent = r;
                        if (this.ignoreElementEnd) {
                            return this._previous()
                        } else {
                            return $h("elementEnd", r, t, e)
                        }
                    } else {
                        this.position = e;
                        return $h("elementStart", r, t, e, 1)
                    }
                } else if (r instanceof Kh) {
                    let o;
                    if (this.singleCharacters) {
                        o = 1
                    } else {
                        let t = r.startOffset;
                        if (this._boundaryStartParent == n && this.boundaries.start.offset > t) {
                            t = this.boundaries.start.offset
                        }
                        o = e.offset - t
                    }
                    const i = e.offset - r.startOffset;
                    const s = new Yh(r, i - o, o);
                    e.offset -= o;
                    this.position = e;
                    return $h("text", s, t, e, o)
                } else {
                    e.path.pop();
                    this.position = e;
                    this._visitedParent = n.parent;
                    return $h("elementStart", n, t, e, 1)
                }
            }
        }

        function $h(t, e, n, o, i) {
            return {
                done: false,
                value: {
                    type: t,
                    item: e,
                    previousPosition: n,
                    nextPosition: o,
                    length: i
                }
            }
        }
        class Zh {
            constructor(t, e, n = "toNone") {
                if (!t.is("element") && !t.is("documentFragment")) {
                    throw new ss["a"]("model-position-root-invalid", t)
                }
                if (!(e instanceof Array) || e.length === 0) {
                    throw new ss["a"]("model-position-path-incorrect-format", t, {
                        path: e
                    })
                }
                if (t.is("rootElement")) {
                    e = e.slice()
                } else {
                    e = [...t.getPath(), ...e];
                    t = t.root
                }
                this.root = t;
                this.path = e;
                this.stickiness = n
            }
            get offset() {
                return this.path[this.path.length - 1]
            }
            set offset(t) {
                this.path[this.path.length - 1] = t
            }
            get parent() {
                let t = this.root;
                for (let e = 0; e < this.path.length - 1; e++) {
                    t = t.getChild(t.offsetToIndex(this.path[e]));
                    if (!t) {
                        throw new ss["a"]("model-position-path-incorrect", this, {
                            position: this
                        })
                    }
                }
                if (t.is("$text")) {
                    throw new ss["a"]("model-position-path-incorrect", this, {
                        position: this
                    })
                }
                return t
            }
            get index() {
                return this.parent.offsetToIndex(this.offset)
            }
            get textNode() {
                return Jh(this, this.parent)
            }
            get nodeAfter() {
                const t = this.parent;
                return Xh(this, t, Jh(this, t))
            }
            get nodeBefore() {
                const t = this.parent;
                return tf(this, t, Jh(this, t))
            }
            get isAtStart() {
                return this.offset === 0
            }
            get isAtEnd() {
                return this.offset == this.parent.maxOffset
            }
            compareWith(t) {
                if (this.root != t.root) {
                    return "different"
                }
                const e = Os(this.path, t.path);
                switch (e) {
                    case "same":
                        return "same";
                    case "prefix":
                        return "before";
                    case "extension":
                        return "after";
                    default:
                        return this.path[e] < t.path[e] ? "before" : "after"
                }
            }
            getLastMatchingPosition(t, e = {}) {
                e.startPosition = this;
                const n = new Qh(e);
                n.skip(t);
                return n.position
            }
            getParentPath() {
                return this.path.slice(0, -1)
            }
            getAncestors() {
                const t = this.parent;
                if (t.is("documentFragment")) {
                    return [t]
                } else {
                    return t.getAncestors({
                        includeSelf: true
                    })
                }
            }
            findAncestor(t) {
                const e = this.parent;
                if (e.is("element")) {
                    return e.findAncestor(t, {
                        includeSelf: true
                    })
                }
                return null
            }
            getCommonPath(t) {
                if (this.root != t.root) {
                    return []
                }
                const e = Os(this.path, t.path);
                const n = typeof e == "string" ? Math.min(this.path.length, t.path.length) : e;
                return this.path.slice(0, n)
            }
            getCommonAncestor(t) {
                const e = this.getAncestors();
                const n = t.getAncestors();
                let o = 0;
                while (e[o] == n[o] && e[o]) {
                    o++
                }
                return o === 0 ? null : e[o - 1]
            }
            getShiftedBy(t) {
                const e = this.clone();
                const n = e.offset + t;
                e.offset = n < 0 ? 0 : n;
                return e
            }
            isAfter(t) {
                return this.compareWith(t) == "after"
            }
            isBefore(t) {
                return this.compareWith(t) == "before"
            }
            isEqual(t) {
                return this.compareWith(t) == "same"
            }
            isTouching(t) {
                let e = null;
                let n = null;
                const o = this.compareWith(t);
                switch (o) {
                    case "same":
                        return true;
                    case "before":
                        e = Zh._createAt(this);
                        n = Zh._createAt(t);
                        break;
                    case "after":
                        e = Zh._createAt(t);
                        n = Zh._createAt(this);
                        break;
                    default:
                        return false
                }
                let i = e.parent;
                while (e.path.length + n.path.length) {
                    if (e.isEqual(n)) {
                        return true
                    }
                    if (e.path.length > n.path.length) {
                        if (e.offset !== i.maxOffset) {
                            return false
                        }
                        e.path = e.path.slice(0, -1);
                        i = i.parent;
                        e.offset++
                    } else {
                        if (n.offset !== 0) {
                            return false
                        }
                        n.path = n.path.slice(0, -1)
                    }
                }
            }
            is(t) {
                return t === "position" || t === "model:position"
            }
            hasSameParentAs(t) {
                if (this.root !== t.root) {
                    return false
                }
                const e = this.getParentPath();
                const n = t.getParentPath();
                return Os(e, n) == "same"
            }
            getTransformedByOperation(t) {
                let e;
                switch (t.type) {
                    case "insert":
                        e = this._getTransformedByInsertOperation(t);
                        break;
                    case "move":
                    case "remove":
                    case "reinsert":
                        e = this._getTransformedByMoveOperation(t);
                        break;
                    case "split":
                        e = this._getTransformedBySplitOperation(t);
                        break;
                    case "merge":
                        e = this._getTransformedByMergeOperation(t);
                        break;
                    default:
                        e = Zh._createAt(this);
                        break
                }
                return e
            }
            _getTransformedByInsertOperation(t) {
                return this._getTransformedByInsertion(t.position, t.howMany)
            }
            _getTransformedByMoveOperation(t) {
                return this._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany)
            }
            _getTransformedBySplitOperation(t) {
                const e = t.movedRange;
                const n = e.containsPosition(this) || e.start.isEqual(this) && this.stickiness == "toNext";
                if (n) {
                    return this._getCombined(t.splitPosition, t.moveTargetPosition)
                } else {
                    if (t.graveyardPosition) {
                        return this._getTransformedByMove(t.graveyardPosition, t.insertionPosition, 1)
                    } else {
                        return this._getTransformedByInsertion(t.insertionPosition, 1)
                    }
                }
            }
            _getTransformedByMergeOperation(t) {
                const e = t.movedRange;
                const n = e.containsPosition(this) || e.start.isEqual(this);
                let o;
                if (n) {
                    o = this._getCombined(t.sourcePosition, t.targetPosition);
                    if (t.sourcePosition.isBefore(t.targetPosition)) {
                        o = o._getTransformedByDeletion(t.deletionPosition, 1)
                    }
                } else if (this.isEqual(t.deletionPosition)) {
                    o = Zh._createAt(t.deletionPosition)
                } else {
                    o = this._getTransformedByMove(t.deletionPosition, t.graveyardPosition, 1)
                }
                return o
            }
            _getTransformedByDeletion(t, e) {
                const n = Zh._createAt(this);
                if (this.root != t.root) {
                    return n
                }
                if (Os(t.getParentPath(), this.getParentPath()) == "same") {
                    if (t.offset < this.offset) {
                        if (t.offset + e > this.offset) {
                            return null
                        } else {
                            n.offset -= e
                        }
                    }
                } else if (Os(t.getParentPath(), this.getParentPath()) == "prefix") {
                    const o = t.path.length - 1;
                    if (t.offset <= this.path[o]) {
                        if (t.offset + e > this.path[o]) {
                            return null
                        } else {
                            n.path[o] -= e
                        }
                    }
                }
                return n
            }
            _getTransformedByInsertion(t, e) {
                const n = Zh._createAt(this);
                if (this.root != t.root) {
                    return n
                }
                if (Os(t.getParentPath(), this.getParentPath()) == "same") {
                    if (t.offset < this.offset || t.offset == this.offset && this.stickiness != "toPrevious") {
                        n.offset += e
                    }
                } else if (Os(t.getParentPath(), this.getParentPath()) == "prefix") {
                    const o = t.path.length - 1;
                    if (t.offset <= this.path[o]) {
                        n.path[o] += e
                    }
                }
                return n
            }
            _getTransformedByMove(t, e, n) {
                e = e._getTransformedByDeletion(t, n);
                if (t.isEqual(e)) {
                    return Zh._createAt(this)
                }
                const o = this._getTransformedByDeletion(t, n);
                const i = o === null || t.isEqual(this) && this.stickiness == "toNext" || t.getShiftedBy(n).isEqual(this) && this.stickiness == "toPrevious";
                if (i) {
                    return this._getCombined(t, e)
                } else {
                    return o._getTransformedByInsertion(e, n)
                }
            }
            _getCombined(t, e) {
                const n = t.path.length - 1;
                const o = Zh._createAt(e);
                o.stickiness = this.stickiness;
                o.offset = o.offset + this.path[n] - t.offset;
                o.path = [...o.path, ...this.path.slice(n + 1)];
                return o
            }
            toJSON() {
                return {
                    root: this.root.toJSON(),
                    path: Array.from(this.path),
                    stickiness: this.stickiness
                }
            }
            clone() {
                return new this.constructor(this.root, this.path, this.stickiness)
            }
            static _createAt(t, e, n = "toNone") {
                if (t instanceof Zh) {
                    return new Zh(t.root, t.path, t.stickiness)
                } else {
                    const o = t;
                    if (e == "end") {
                        e = o.maxOffset
                    } else if (e == "before") {
                        return this._createBefore(o, n)
                    } else if (e == "after") {
                        return this._createAfter(o, n)
                    } else if (e !== 0 && !e) {
                        throw new ss["a"]("model-createpositionat-offset-required", [this, t])
                    }
                    if (!o.is("element") && !o.is("documentFragment")) {
                        throw new ss["a"]("model-position-parent-incorrect", [this, t])
                    }
                    const i = o.getPath();
                    i.push(e);
                    return new this(o.root, i, n)
                }
            }
            static _createAfter(t, e) {
                if (!t.parent) {
                    throw new ss["a"]("model-position-after-root", [this, t], {
                        root: t
                    })
                }
                return this._createAt(t.parent, t.endOffset, e)
            }
            static _createBefore(t, e) {
                if (!t.parent) {
                    throw new ss["a"]("model-position-before-root", t, {
                        root: t
                    })
                }
                return this._createAt(t.parent, t.startOffset, e)
            }
            static fromJSON(t, e) {
                if (t.root === "$graveyard") {
                    const n = new Zh(e.graveyard, t.path);
                    n.stickiness = t.stickiness;
                    return n
                }
                if (!e.getRoot(t.root)) {
                    throw new ss["a"]("model-position-fromjson-no-root", e, {
                        rootName: t.root
                    })
                }
                return new Zh(e.getRoot(t.root), t.path, t.stickiness)
            }
        }

        function Jh(t, e) {
            const n = e.getChild(e.offsetToIndex(t.offset));
            if (n && n.is("$text") && n.startOffset < t.offset) {
                return n
            }
            return null
        }

        function Xh(t, e, n) {
            if (n !== null) {
                return null
            }
            return e.getChild(e.offsetToIndex(t.offset))
        }

        function tf(t, e, n) {
            if (n !== null) {
                return null
            }
            return e.getChild(e.offsetToIndex(t.offset) - 1)
        }
        class ef {
            constructor(t, e = null) {
                this.start = Zh._createAt(t);
                this.end = e ? Zh._createAt(e) : Zh._createAt(t);
                this.start.stickiness = this.isCollapsed ? "toNone" : "toNext";
                this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious"
            }*[Symbol.iterator]() {
                yield* new Qh({
                    boundaries: this,
                    ignoreElementEnd: true
                })
            }
            get isCollapsed() {
                return this.start.isEqual(this.end)
            }
            get isFlat() {
                const t = this.start.getParentPath();
                const e = this.end.getParentPath();
                return Os(t, e) == "same"
            }
            get root() {
                return this.start.root
            }
            containsPosition(t) {
                return t.isAfter(this.start) && t.isBefore(this.end)
            }
            containsRange(t, e = false) {
                if (t.isCollapsed) {
                    e = false
                }
                const n = this.containsPosition(t.start) || e && this.start.isEqual(t.start);
                const o = this.containsPosition(t.end) || e && this.end.isEqual(t.end);
                return n && o
            }
            containsItem(t) {
                const e = Zh._createBefore(t);
                return this.containsPosition(e) || this.start.isEqual(e)
            }
            is(t) {
                return t === "range" || t === "model:range"
            }
            isEqual(t) {
                return this.start.isEqual(t.start) && this.end.isEqual(t.end)
            }
            isIntersecting(t) {
                return this.start.isBefore(t.end) && this.end.isAfter(t.start)
            }
            getDifference(t) {
                const e = [];
                if (this.isIntersecting(t)) {
                    if (this.containsPosition(t.start)) {
                        e.push(new ef(this.start, t.start))
                    }
                    if (this.containsPosition(t.end)) {
                        e.push(new ef(t.end, this.end))
                    }
                } else {
                    e.push(new ef(this.start, this.end))
                }
                return e
            }
            getIntersection(t) {
                if (this.isIntersecting(t)) {
                    let e = this.start;
                    let n = this.end;
                    if (this.containsPosition(t.start)) {
                        e = t.start
                    }
                    if (this.containsPosition(t.end)) {
                        n = t.end
                    }
                    return new ef(e, n)
                }
                return null
            }
            getJoined(t, e = false) {
                let n = this.isIntersecting(t);
                if (!n) {
                    if (this.start.isBefore(t.start)) {
                        n = e ? this.end.isTouching(t.start) : this.end.isEqual(t.start)
                    } else {
                        n = e ? t.end.isTouching(this.start) : t.end.isEqual(this.start)
                    }
                }
                if (!n) {
                    return null
                }
                let o = this.start;
                let i = this.end;
                if (t.start.isBefore(o)) {
                    o = t.start
                }
                if (t.end.isAfter(i)) {
                    i = t.end
                }
                return new ef(o, i)
            }
            getMinimalFlatRanges() {
                const t = [];
                const e = this.start.getCommonPath(this.end).length;
                const n = Zh._createAt(this.start);
                let o = n.parent;
                while (n.path.length > e + 1) {
                    const e = o.maxOffset - n.offset;
                    if (e !== 0) {
                        t.push(new ef(n, n.getShiftedBy(e)))
                    }
                    n.path = n.path.slice(0, -1);
                    n.offset++;
                    o = o.parent
                }
                while (n.path.length <= this.end.path.length) {
                    const e = this.end.path[n.path.length - 1];
                    const o = e - n.offset;
                    if (o !== 0) {
                        t.push(new ef(n, n.getShiftedBy(o)))
                    }
                    n.offset = e;
                    n.path.push(0)
                }
                return t
            }
            getWalker(t = {}) {
                t.boundaries = this;
                return new Qh(t)
            }* getItems(t = {}) {
                t.boundaries = this;
                t.ignoreElementEnd = true;
                const e = new Qh(t);
                for (const t of e) {
                    yield t.item
                }
            }* getPositions(t = {}) {
                t.boundaries = this;
                const e = new Qh(t);
                yield e.position;
                for (const t of e) {
                    yield t.nextPosition
                }
            }
            getTransformedByOperation(t) {
                switch (t.type) {
                    case "insert":
                        return this._getTransformedByInsertOperation(t);
                    case "move":
                    case "remove":
                    case "reinsert":
                        return this._getTransformedByMoveOperation(t);
                    case "split":
                        return [this._getTransformedBySplitOperation(t)];
                    case "merge":
                        return [this._getTransformedByMergeOperation(t)]
                }
                return [new ef(this.start, this.end)]
            }
            getTransformedByOperations(t) {
                const e = [new ef(this.start, this.end)];
                for (const n of t) {
                    for (let t = 0; t < e.length; t++) {
                        const o = e[t].getTransformedByOperation(n);
                        e.splice(t, 1, ...o);
                        t += o.length - 1
                    }
                }
                for (let t = 0; t < e.length; t++) {
                    const n = e[t];
                    for (let o = t + 1; o < e.length; o++) {
                        const t = e[o];
                        if (n.containsRange(t) || t.containsRange(n) || n.isEqual(t)) {
                            e.splice(o, 1)
                        }
                    }
                }
                return e
            }
            getCommonAncestor() {
                return this.start.getCommonAncestor(this.end)
            }
            getContainedElement() {
                if (this.isCollapsed) {
                    return null
                }
                const t = this.start.nodeAfter;
                const e = this.end.nodeBefore;
                if (t && t.is("element") && t === e) {
                    return t
                }
                return null
            }
            toJSON() {
                return {
                    start: this.start.toJSON(),
                    end: this.end.toJSON()
                }
            }
            clone() {
                return new this.constructor(this.start, this.end)
            }
            _getTransformedByInsertOperation(t, e = false) {
                return this._getTransformedByInsertion(t.position, t.howMany, e)
            }
            _getTransformedByMoveOperation(t, e = false) {
                const n = t.sourcePosition;
                const o = t.howMany;
                const i = t.targetPosition;
                return this._getTransformedByMove(n, i, o, e)
            }
            _getTransformedBySplitOperation(t) {
                const e = this.start._getTransformedBySplitOperation(t);
                let n = this.end._getTransformedBySplitOperation(t);
                if (this.end.isEqual(t.insertionPosition)) {
                    n = this.end.getShiftedBy(1)
                }
                if (e.root != n.root) {
                    n = this.end.getShiftedBy(-1)
                }
                return new ef(e, n)
            }
            _getTransformedByMergeOperation(t) {
                if (this.start.isEqual(t.targetPosition) && this.end.isEqual(t.deletionPosition)) {
                    return new ef(this.start)
                }
                let e = this.start._getTransformedByMergeOperation(t);
                let n = this.end._getTransformedByMergeOperation(t);
                if (e.root != n.root) {
                    n = this.end.getShiftedBy(-1)
                }
                if (e.isAfter(n)) {
                    if (t.sourcePosition.isBefore(t.targetPosition)) {
                        e = Zh._createAt(n);
                        e.offset = 0
                    } else {
                        if (!t.deletionPosition.isEqual(e)) {
                            n = t.deletionPosition
                        }
                        e = t.targetPosition
                    }
                    return new ef(e, n)
                }
                return new ef(e, n)
            }
            _getTransformedByInsertion(t, e, n = false) {
                if (n && this.containsPosition(t)) {
                    return [new ef(this.start, t), new ef(t.getShiftedBy(e), this.end._getTransformedByInsertion(t, e))]
                } else {
                    const n = new ef(this.start, this.end);
                    n.start = n.start._getTransformedByInsertion(t, e);
                    n.end = n.end._getTransformedByInsertion(t, e);
                    return [n]
                }
            }
            _getTransformedByMove(t, e, n, o = false) {
                if (this.isCollapsed) {
                    const o = this.start._getTransformedByMove(t, e, n);
                    return [new ef(o)]
                }
                const i = ef._createFromPositionAndShift(t, n);
                const r = e._getTransformedByDeletion(t, n);
                if (this.containsPosition(e) && !o) {
                    if (i.containsPosition(this.start) || i.containsPosition(this.end)) {
                        const o = this.start._getTransformedByMove(t, e, n);
                        const i = this.end._getTransformedByMove(t, e, n);
                        return [new ef(o, i)]
                    }
                }
                let s;
                const a = this.getDifference(i);
                let c = null;
                const l = this.getIntersection(i);
                if (a.length == 1) {
                    c = new ef(a[0].start._getTransformedByDeletion(t, n), a[0].end._getTransformedByDeletion(t, n))
                } else if (a.length == 2) {
                    c = new ef(this.start, this.end._getTransformedByDeletion(t, n))
                }
                if (c) {
                    s = c._getTransformedByInsertion(r, n, l !== null || o)
                } else {
                    s = []
                }
                if (l) {
                    const t = new ef(l.start._getCombined(i.start, r), l.end._getCombined(i.start, r));
                    if (s.length == 2) {
                        s.splice(1, 0, t)
                    } else {
                        s.push(t)
                    }
                }
                return s
            }
            _getTransformedByDeletion(t, e) {
                let n = this.start._getTransformedByDeletion(t, e);
                let o = this.end._getTransformedByDeletion(t, e);
                if (n == null && o == null) {
                    return null
                }
                if (n == null) {
                    n = t
                }
                if (o == null) {
                    o = t
                }
                return new ef(n, o)
            }
            static _createFromPositionAndShift(t, e) {
                const n = t;
                const o = t.getShiftedBy(e);
                return e > 0 ? new this(n, o) : new this(o, n)
            }
            static _createIn(t) {
                return new this(Zh._createAt(t, 0), Zh._createAt(t, t.maxOffset))
            }
            static _createOn(t) {
                return this._createFromPositionAndShift(Zh._createBefore(t), t.offsetSize)
            }
            static _createFromRanges(t) {
                if (t.length === 0) {
                    throw new ss["a"]("range-create-from-ranges-empty-array", null)
                } else if (t.length == 1) {
                    return t[0].clone()
                }
                const e = t[0];
                t.sort(((t, e) => t.start.isAfter(e.start) ? 1 : -1));
                const n = t.indexOf(e);
                const o = new this(e.start, e.end);
                if (n > 0) {
                    for (let e = n - 1; true; e++) {
                        if (t[e].end.isEqual(o.start)) {
                            o.start = Zh._createAt(t[e].start)
                        } else {
                            break
                        }
                    }
                }
                for (let e = n + 1; e < t.length; e++) {
                    if (t[e].start.isEqual(o.end)) {
                        o.end = Zh._createAt(t[e].end)
                    } else {
                        break
                    }
                }
                return o
            }
            static fromJSON(t, e) {
                return new this(Zh.fromJSON(t.start, e), Zh.fromJSON(t.end, e))
            }
        }
        class nf {
            constructor() {
                this._modelToViewMapping = new WeakMap;
                this._viewToModelMapping = new WeakMap;
                this._viewToModelLengthCallbacks = new Map;
                this._markerNameToElements = new Map;
                this._elementToMarkerNames = new Map;
                this._unboundMarkerNames = new Set;
                this.on("modelToViewPosition", ((t, e) => {
                    if (e.viewPosition) {
                        return
                    }
                    const n = this._modelToViewMapping.get(e.modelPosition.parent);
                    e.viewPosition = this.findPositionIn(n, e.modelPosition.offset)
                }), {
                    priority: "low"
                });
                this.on("viewToModelPosition", ((t, e) => {
                    if (e.modelPosition) {
                        return
                    }
                    const n = this.findMappedViewAncestor(e.viewPosition);
                    const o = this._viewToModelMapping.get(n);
                    const i = this._toModelOffset(e.viewPosition.parent, e.viewPosition.offset, n);
                    e.modelPosition = Zh._createAt(o, i)
                }), {
                    priority: "low"
                })
            }
            bindElements(t, e) {
                this._modelToViewMapping.set(t, e);
                this._viewToModelMapping.set(e, t)
            }
            unbindViewElement(t) {
                const e = this.toModelElement(t);
                this._viewToModelMapping.delete(t);
                if (this._elementToMarkerNames.has(t)) {
                    for (const e of this._elementToMarkerNames.get(t)) {
                        this._unboundMarkerNames.add(e)
                    }
                }
                if (this._modelToViewMapping.get(e) == t) {
                    this._modelToViewMapping.delete(e)
                }
            }
            unbindModelElement(t) {
                const e = this.toViewElement(t);
                this._modelToViewMapping.delete(t);
                if (this._viewToModelMapping.get(e) == t) {
                    this._viewToModelMapping.delete(e)
                }
            }
            bindElementToMarker(t, e) {
                const n = this._markerNameToElements.get(e) || new Set;
                n.add(t);
                const o = this._elementToMarkerNames.get(t) || new Set;
                o.add(e);
                this._markerNameToElements.set(e, n);
                this._elementToMarkerNames.set(t, o)
            }
            unbindElementFromMarkerName(t, e) {
                const n = this._markerNameToElements.get(e);
                if (n) {
                    n.delete(t);
                    if (n.size == 0) {
                        this._markerNameToElements.delete(e)
                    }
                }
                const o = this._elementToMarkerNames.get(t);
                if (o) {
                    o.delete(e);
                    if (o.size == 0) {
                        this._elementToMarkerNames.delete(t)
                    }
                }
            }
            flushUnboundMarkerNames() {
                const t = Array.from(this._unboundMarkerNames);
                this._unboundMarkerNames.clear();
                return t
            }
            clearBindings() {
                this._modelToViewMapping = new WeakMap;
                this._viewToModelMapping = new WeakMap;
                this._markerNameToElements = new Map;
                this._elementToMarkerNames = new Map;
                this._unboundMarkerNames = new Set
            }
            toModelElement(t) {
                return this._viewToModelMapping.get(t)
            }
            toViewElement(t) {
                return this._modelToViewMapping.get(t)
            }
            toModelRange(t) {
                return new ef(this.toModelPosition(t.start), this.toModelPosition(t.end))
            }
            toViewRange(t) {
                return new fl(this.toViewPosition(t.start), this.toViewPosition(t.end))
            }
            toModelPosition(t) {
                const e = {
                    viewPosition: t,
                    mapper: this
                };
                this.fire("viewToModelPosition", e);
                return e.modelPosition
            }
            toViewPosition(t, e = {
                isPhantom: false
            }) {
                const n = {
                    modelPosition: t,
                    mapper: this,
                    isPhantom: e.isPhantom
                };
                this.fire("modelToViewPosition", n);
                return n.viewPosition
            }
            markerNameToElements(t) {
                const e = this._markerNameToElements.get(t);
                if (!e) {
                    return null
                }
                const n = new Set;
                for (const t of e) {
                    if (t.is("attributeElement")) {
                        for (const e of t.getElementsWithSameId()) {
                            n.add(e)
                        }
                    } else {
                        n.add(t)
                    }
                }
                return n
            }
            registerViewToModelLength(t, e) {
                this._viewToModelLengthCallbacks.set(t, e)
            }
            findMappedViewAncestor(t) {
                let e = t.parent;
                while (!this._viewToModelMapping.has(e)) {
                    e = e.parent
                }
                return e
            }
            _toModelOffset(t, e, n) {
                if (n != t) {
                    const o = this._toModelOffset(t.parent, t.index, n);
                    const i = this._toModelOffset(t, e, t);
                    return o + i
                }
                if (t.is("$text")) {
                    return e
                }
                let o = 0;
                for (let n = 0; n < e; n++) {
                    o += this.getModelLength(t.getChild(n))
                }
                return o
            }
            getModelLength(t) {
                if (this._viewToModelLengthCallbacks.get(t.name)) {
                    const e = this._viewToModelLengthCallbacks.get(t.name);
                    return e(t)
                } else if (this._viewToModelMapping.has(t)) {
                    return 1
                } else if (t.is("$text")) {
                    return t.data.length
                } else if (t.is("uiElement")) {
                    return 0
                } else {
                    let e = 0;
                    for (const n of t.getChildren()) {
                        e += this.getModelLength(n)
                    }
                    return e
                }
            }
            findPositionIn(t, e) {
                let n;
                let o = 0;
                let i = 0;
                let r = 0;
                if (t.is("$text")) {
                    return new hl(t, e)
                }
                while (i < e) {
                    n = t.getChild(r);
                    o = this.getModelLength(n);
                    i += o;
                    r++
                }
                if (i == e) {
                    return this._moveViewPositionToTextNode(new hl(t, r))
                } else {
                    return this.findPositionIn(n, e - (i - o))
                }
            }
            _moveViewPositionToTextNode(t) {
                const e = t.nodeBefore;
                const n = t.nodeAfter;
                if (e instanceof Vs) {
                    return new hl(e, e.data.length)
                } else if (n instanceof Vs) {
                    return new hl(n, 0)
                }
                return t
            }
        }
        _s(nf, ds);
        class of {
            constructor() {
                this._consumable = new Map;
                this._textProxyRegistry = new Map
            }
            add(t, e) {
                e = rf(e);
                if (t instanceof Yh) {
                    t = this._getSymbolForTextProxy(t)
                }
                if (!this._consumable.has(t)) {
                    this._consumable.set(t, new Map)
                }
                this._consumable.get(t).set(e, true)
            }
            consume(t, e) {
                e = rf(e);
                if (t instanceof Yh) {
                    t = this._getSymbolForTextProxy(t)
                }
                if (this.test(t, e)) {
                    this._consumable.get(t).set(e, false);
                    return true
                } else {
                    return false
                }
            }
            test(t, e) {
                e = rf(e);
                if (t instanceof Yh) {
                    t = this._getSymbolForTextProxy(t)
                }
                const n = this._consumable.get(t);
                if (n === undefined) {
                    return null
                }
                const o = n.get(e);
                if (o === undefined) {
                    return null
                }
                return o
            }
            revert(t, e) {
                e = rf(e);
                if (t instanceof Yh) {
                    t = this._getSymbolForTextProxy(t)
                }
                const n = this.test(t, e);
                if (n === false) {
                    this._consumable.get(t).set(e, true);
                    return true
                } else if (n === true) {
                    return false
                }
                return null
            }
            _getSymbolForTextProxy(t) {
                let e = null;
                const n = this._textProxyRegistry.get(t.startOffset);
                if (n) {
                    const o = n.get(t.endOffset);
                    if (o) {
                        e = o.get(t.parent)
                    }
                }
                if (!e) {
                    e = this._addSymbolForTextProxy(t.startOffset, t.endOffset, t.parent)
                }
                return e
            }
            _addSymbolForTextProxy(t, e, n) {
                const o = Symbol("textProxySymbol");
                let i, r;
                i = this._textProxyRegistry.get(t);
                if (!i) {
                    i = new Map;
                    this._textProxyRegistry.set(t, i)
                }
                r = i.get(e);
                if (!r) {
                    r = new Map;
                    i.set(e, r)
                }
                r.set(n, o);
                return o
            }
        }

        function rf(t) {
            const e = t.split(":");
            return e.length > 1 ? e[0] + ":" + e[1] : e[0]
        }
        class sf {
            constructor(t) {
                this.conversionApi = Object.assign({
                    dispatcher: this
                }, t);
                this._reconversionEventsMapping = new Map
            }
            convertChanges(t, e, n) {
                for (const e of t.getMarkersToRemove()) {
                    this.convertMarkerRemove(e.name, e.range, n)
                }
                const o = this._mapChangesWithAutomaticReconversion(t);
                for (const t of o) {
                    if (t.type === "insert") {
                        this.convertInsert(ef._createFromPositionAndShift(t.position, t.length), n)
                    } else if (t.type === "remove") {
                        this.convertRemove(t.position, t.length, t.name, n)
                    } else if (t.type === "reconvert") {
                        this.reconvertElement(t.element, n)
                    } else {
                        this.convertAttribute(t.range, t.attributeKey, t.attributeOldValue, t.attributeNewValue, n)
                    }
                }
                for (const t of this.conversionApi.mapper.flushUnboundMarkerNames()) {
                    const o = e.get(t).getRange();
                    this.convertMarkerRemove(t, o, n);
                    this.convertMarkerAdd(t, o, n)
                }
                for (const e of t.getMarkersToAdd()) {
                    this.convertMarkerAdd(e.name, e.range, n)
                }
            }
            convertInsert(t, e) {
                this.conversionApi.writer = e;
                this.conversionApi.consumable = this._createInsertConsumable(t);
                for (const e of Array.from(t).map(lf)) {
                    this._convertInsertWithAttributes(e)
                }
                this._clearConversionApi()
            }
            convertRemove(t, e, n, o) {
                this.conversionApi.writer = o;
                this.fire("remove:" + n, {
                    position: t,
                    length: e
                }, this.conversionApi);
                this._clearConversionApi()
            }
            convertAttribute(t, e, n, o, i) {
                this.conversionApi.writer = i;
                this.conversionApi.consumable = this._createConsumableForRange(t, `attribute:${e}`);
                for (const i of t) {
                    const t = i.item;
                    const r = ef._createFromPositionAndShift(i.previousPosition, i.length);
                    const s = {
                        item: t,
                        range: r,
                        attributeKey: e,
                        attributeOldValue: n,
                        attributeNewValue: o
                    };
                    this._testAndFire(`attribute:${e}`, s)
                }
                this._clearConversionApi()
            }
            reconvertElement(t, e) {
                const n = ef._createOn(t);
                this.conversionApi.writer = e;
                this.conversionApi.consumable = this._createInsertConsumable(n);
                const o = this.conversionApi.mapper;
                const i = o.toViewElement(t);
                e.remove(i);
                this._convertInsertWithAttributes({
                    item: t,
                    range: n
                });
                const r = o.toViewElement(t);
                for (const n of ef._createIn(t)) {
                    const {
                        item: t
                    } = n;
                    const i = df(t, o);
                    if (i) {
                        if (i.root !== r.root) {
                            e.move(e.createRangeOn(i), o.toViewPosition(Zh._createBefore(t)))
                        }
                    } else {
                        this._convertInsertWithAttributes(lf(n))
                    }
                }
                o.unbindViewElement(i);
                this._clearConversionApi()
            }
            convertSelection(t, e, n) {
                const o = Array.from(e.getMarkersAtPosition(t.getFirstPosition()));
                this.conversionApi.writer = n;
                this.conversionApi.consumable = this._createSelectionConsumable(t, o);
                this.fire("selection", {
                    selection: t
                }, this.conversionApi);
                if (!t.isCollapsed) {
                    return
                }
                for (const e of o) {
                    const n = e.getRange();
                    if (!af(t.getFirstPosition(), e, this.conversionApi.mapper)) {
                        continue
                    }
                    const o = {
                        item: t,
                        markerName: e.name,
                        markerRange: n
                    };
                    if (this.conversionApi.consumable.test(t, "addMarker:" + e.name)) {
                        this.fire("addMarker:" + e.name, o, this.conversionApi)
                    }
                }
                for (const e of t.getAttributeKeys()) {
                    const n = {
                        item: t,
                        range: t.getFirstRange(),
                        attributeKey: e,
                        attributeOldValue: null,
                        attributeNewValue: t.getAttribute(e)
                    };
                    if (this.conversionApi.consumable.test(t, "attribute:" + n.attributeKey)) {
                        this.fire("attribute:" + n.attributeKey + ":$text", n, this.conversionApi)
                    }
                }
                this._clearConversionApi()
            }
            convertMarkerAdd(t, e, n) {
                if (!e.root.document || e.root.rootName == "$graveyard") {
                    return
                }
                this.conversionApi.writer = n;
                const o = "addMarker:" + t;
                const i = new of ;
                i.add(e, o);
                this.conversionApi.consumable = i;
                this.fire(o, {
                    markerName: t,
                    markerRange: e
                }, this.conversionApi);
                if (!i.test(e, o)) {
                    return
                }
                this.conversionApi.consumable = this._createConsumableForRange(e, o);
                for (const n of e.getItems()) {
                    if (!this.conversionApi.consumable.test(n, o)) {
                        continue
                    }
                    const i = {
                        item: n,
                        range: ef._createOn(n),
                        markerName: t,
                        markerRange: e
                    };
                    this.fire(o, i, this.conversionApi)
                }
                this._clearConversionApi()
            }
            convertMarkerRemove(t, e, n) {
                if (!e.root.document || e.root.rootName == "$graveyard") {
                    return
                }
                this.conversionApi.writer = n;
                this.fire("removeMarker:" + t, {
                    markerName: t,
                    markerRange: e
                }, this.conversionApi);
                this._clearConversionApi()
            }
            _mapReconversionTriggerEvent(t, e) {
                this._reconversionEventsMapping.set(e, t)
            }
            _createInsertConsumable(t) {
                const e = new of ;
                for (const n of t) {
                    const t = n.item;
                    e.add(t, "insert");
                    for (const n of t.getAttributeKeys()) {
                        e.add(t, "attribute:" + n)
                    }
                }
                return e
            }
            _createConsumableForRange(t, e) {
                const n = new of ;
                for (const o of t.getItems()) {
                    n.add(o, e)
                }
                return n
            }
            _createSelectionConsumable(t, e) {
                const n = new of ;
                n.add(t, "selection");
                for (const o of e) {
                    n.add(t, "addMarker:" + o.name)
                }
                for (const e of t.getAttributeKeys()) {
                    n.add(t, "attribute:" + e)
                }
                return n
            }
            _testAndFire(t, e) {
                if (!this.conversionApi.consumable.test(e.item, t)) {
                    return
                }
                this.fire(cf(t, e), e, this.conversionApi)
            }
            _clearConversionApi() {
                delete this.conversionApi.writer;
                delete this.conversionApi.consumable
            }
            _convertInsertWithAttributes(t) {
                this._testAndFire("insert", t);
                for (const e of t.item.getAttributeKeys()) {
                    t.attributeKey = e;
                    t.attributeOldValue = null;
                    t.attributeNewValue = t.item.getAttribute(e);
                    this._testAndFire(`attribute:${e}`, t)
                }
            }
            _mapChangesWithAutomaticReconversion(t) {
                const e = new Set;
                const n = [];
                for (const o of t.getChanges()) {
                    const t = o.position || o.range.start;
                    const i = t.parent;
                    const r = Jh(t, i);
                    if (r) {
                        n.push(o);
                        continue
                    }
                    const s = o.type === "attribute" ? Xh(t, i, null) : i;
                    if (s.is("$text")) {
                        n.push(o);
                        continue
                    }
                    let a;
                    if (o.type === "attribute") {
                        a = `attribute:${o.attributeKey}:${s.name}`
                    } else {
                        a = `${o.type}:${o.name}`
                    }
                    if (this._isReconvertTriggerEvent(a, s.name)) {
                        if (e.has(s)) {
                            continue
                        }
                        e.add(s);
                        n.push({
                            type: "reconvert",
                            element: s
                        })
                    } else {
                        n.push(o)
                    }
                }
                return n
            }
            _isReconvertTriggerEvent(t, e) {
                return this._reconversionEventsMapping.get(t) === e
            }
        }
        _s(sf, ds);

        function af(t, e, n) {
            const o = e.getRange();
            const i = Array.from(t.getAncestors());
            i.shift();
            i.reverse();
            const r = i.some((t => {
                if (o.containsItem(t)) {
                    const e = n.toViewElement(t);
                    return !!e.getCustomProperty("addHighlight")
                }
            }));
            return !r
        }

        function cf(t, e) {
            const n = e.item.name || "$text";
            return `${t}:${n}`
        }

        function lf(t) {
            const e = t.item;
            const n = ef._createFromPositionAndShift(t.previousPosition, t.length);
            return {
                item: e,
                range: n
            }
        }

        function df(t, e) {
            if (t.is("textProxy")) {
                const n = e.toViewPosition(Zh._createBefore(t));
                const o = n.parent;
                return o.is("$text") ? o : null
            }
            return e.toViewElement(t)
        }
        class uf {
            constructor(t, e, n) {
                this._lastRangeBackward = false;
                this._ranges = [];
                this._attrs = new Map;
                if (t) {
                    this.setTo(t, e, n)
                }
            }
            get anchor() {
                if (this._ranges.length > 0) {
                    const t = this._ranges[this._ranges.length - 1];
                    return this._lastRangeBackward ? t.end : t.start
                }
                return null
            }
            get focus() {
                if (this._ranges.length > 0) {
                    const t = this._ranges[this._ranges.length - 1];
                    return this._lastRangeBackward ? t.start : t.end
                }
                return null
            }
            get isCollapsed() {
                const t = this._ranges.length;
                if (t === 1) {
                    return this._ranges[0].isCollapsed
                } else {
                    return false
                }
            }
            get rangeCount() {
                return this._ranges.length
            }
            get isBackward() {
                return !this.isCollapsed && this._lastRangeBackward
            }
            isEqual(t) {
                if (this.rangeCount != t.rangeCount) {
                    return false
                } else if (this.rangeCount === 0) {
                    return true
                }
                if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) {
                    return false
                }
                for (const e of this._ranges) {
                    let n = false;
                    for (const o of t._ranges) {
                        if (e.isEqual(o)) {
                            n = true;
                            break
                        }
                    }
                    if (!n) {
                        return false
                    }
                }
                return true
            }* getRanges() {
                for (const t of this._ranges) {
                    yield new ef(t.start, t.end)
                }
            }
            getFirstRange() {
                let t = null;
                for (const e of this._ranges) {
                    if (!t || e.start.isBefore(t.start)) {
                        t = e
                    }
                }
                return t ? new ef(t.start, t.end) : null
            }
            getLastRange() {
                let t = null;
                for (const e of this._ranges) {
                    if (!t || e.end.isAfter(t.end)) {
                        t = e
                    }
                }
                return t ? new ef(t.start, t.end) : null
            }
            getFirstPosition() {
                const t = this.getFirstRange();
                return t ? t.start.clone() : null
            }
            getLastPosition() {
                const t = this.getLastRange();
                return t ? t.end.clone() : null
            }
            setTo(t, e, n) {
                if (t === null) {
                    this._setRanges([])
                } else if (t instanceof uf) {
                    this._setRanges(t.getRanges(), t.isBackward)
                } else if (t && typeof t.getRanges == "function") {
                    this._setRanges(t.getRanges(), t.isBackward)
                } else if (t instanceof ef) {
                    this._setRanges([t], !!e && !!e.backward)
                } else if (t instanceof Zh) {
                    this._setRanges([new ef(t)])
                } else if (t instanceof Gh) {
                    const o = !!n && !!n.backward;
                    let i;
                    if (e == "in") {
                        i = ef._createIn(t)
                    } else if (e == "on") {
                        i = ef._createOn(t)
                    } else if (e !== undefined) {
                        i = new ef(Zh._createAt(t, e))
                    } else {
                        throw new ss["a"]("model-selection-setto-required-second-parameter", [this, t])
                    }
                    this._setRanges([i], o)
                } else if (Cs(t)) {
                    this._setRanges(t, e && !!e.backward)
                } else {
                    throw new ss["a"]("model-selection-setto-not-selectable", [this, t])
                }
            }
            _setRanges(t, e = false) {
                t = Array.from(t);
                const n = t.some((e => {
                    if (!(e instanceof ef)) {
                        throw new ss["a"]("model-selection-set-ranges-not-range", [this, t])
                    }
                    return this._ranges.every((t => !t.isEqual(e)))
                }));
                if (t.length === this._ranges.length && !n) {
                    return
                }
                this._removeAllRanges();
                for (const e of t) {
                    this._pushRange(e)
                }
                this._lastRangeBackward = !!e;
                this.fire("change:range", {
                    directChange: true
                })
            }
            setFocus(t, e) {
                if (this.anchor === null) {
                    throw new ss["a"]("model-selection-setfocus-no-ranges", [this, t])
                }
                const n = Zh._createAt(t, e);
                if (n.compareWith(this.focus) == "same") {
                    return
                }
                const o = this.anchor;
                if (this._ranges.length) {
                    this._popRange()
                }
                if (n.compareWith(o) == "before") {
                    this._pushRange(new ef(n, o));
                    this._lastRangeBackward = true
                } else {
                    this._pushRange(new ef(o, n));
                    this._lastRangeBackward = false
                }
                this.fire("change:range", {
                    directChange: true
                })
            }
            getAttribute(t) {
                return this._attrs.get(t)
            }
            getAttributes() {
                return this._attrs.entries()
            }
            getAttributeKeys() {
                return this._attrs.keys()
            }
            hasAttribute(t) {
                return this._attrs.has(t)
            }
            removeAttribute(t) {
                if (this.hasAttribute(t)) {
                    this._attrs.delete(t);
                    this.fire("change:attribute", {
                        attributeKeys: [t],
                        directChange: true
                    })
                }
            }
            setAttribute(t, e) {
                if (this.getAttribute(t) !== e) {
                    this._attrs.set(t, e);
                    this.fire("change:attribute", {
                        attributeKeys: [t],
                        directChange: true
                    })
                }
            }
            getSelectedElement() {
                if (this.rangeCount !== 1) {
                    return null
                }
                return this.getFirstRange().getContainedElement()
            }
            is(t) {
                return t === "selection" || t === "model:selection"
            }* getSelectedBlocks() {
                const t = new WeakSet;
                for (const e of this.getRanges()) {
                    const n = pf(e.start, t);
                    if (n && mf(n, e)) {
                        yield n
                    }
                    for (const n of e.getWalker()) {
                        const o = n.item;
                        if (n.type == "elementEnd" && ff(o, t, e)) {
                            yield o
                        }
                    }
                    const o = pf(e.end, t);
                    if (o && !e.end.isTouching(Zh._createAt(o, 0)) && mf(o, e)) {
                        yield o
                    }
                }
            }
            containsEntireContent(t = this.anchor.root) {
                const e = Zh._createAt(t, 0);
                const n = Zh._createAt(t, "end");
                return e.isTouching(this.getFirstPosition()) && n.isTouching(this.getLastPosition())
            }
            _pushRange(t) {
                this._checkRange(t);
                this._ranges.push(new ef(t.start, t.end))
            }
            _checkRange(t) {
                for (let e = 0; e < this._ranges.length; e++) {
                    if (t.isIntersecting(this._ranges[e])) {
                        throw new ss["a"]("model-selection-range-intersects", [this, t], {
                            addedRange: t,
                            intersectingRange: this._ranges[e]
                        })
                    }
                }
            }
            _removeAllRanges() {
                while (this._ranges.length > 0) {
                    this._popRange()
                }
            }
            _popRange() {
                this._ranges.pop()
            }
        }
        _s(uf, ds);

        function hf(t, e) {
            if (e.has(t)) {
                return false
            }
            e.add(t);
            return t.root.document.model.schema.isBlock(t) && t.parent
        }

        function ff(t, e, n) {
            return hf(t, e) && mf(t, n)
        }

        function pf(t, e) {
            const n = t.parent;
            const o = n.root.document.model.schema;
            const i = t.parent.getAncestors({
                parentFirst: true,
                includeSelf: true
            });
            let r = false;
            const s = i.find((t => {
                if (r) {
                    return false
                }
                r = o.isLimit(t);
                return !r && hf(t, e)
            }));
            i.forEach((t => e.add(t)));
            return s
        }

        function mf(t, e) {
            const n = gf(t);
            if (!n) {
                return true
            }
            const o = e.containsRange(ef._createOn(n), true);
            return !o
        }

        function gf(t) {
            const e = t.root.document.model.schema;
            let n = t.parent;
            while (n) {
                if (e.isBlock(n)) {
                    return n
                }
                n = n.parent
            }
        }
        class kf extends ef {
            constructor(t, e) {
                super(t, e);
                bf.call(this)
            }
            detach() {
                this.stopListening()
            }
            is(t) {
                return t === "liveRange" || t === "model:liveRange" || t == "range" || t === "model:range"
            }
            toRange() {
                return new ef(this.start, this.end)
            }
            static fromRange(t) {
                return new kf(t.start, t.end)
            }
        }

        function bf() {
            this.listenTo(this.root.document.model, "applyOperation", ((t, e) => {
                const n = e[0];
                if (!n.isDocumentOperation) {
                    return
                }
                wf.call(this, n)
            }), {
                priority: "low"
            })
        }

        function wf(t) {
            const e = this.getTransformedByOperation(t);
            const n = ef._createFromRanges(e);
            const o = !n.isEqual(this);
            const i = Af(this, t);
            let r = null;
            if (o) {
                if (n.root.rootName == "$graveyard") {
                    if (t.type == "remove") {
                        r = t.sourcePosition
                    } else {
                        r = t.deletionPosition
                    }
                }
                const e = this.toRange();
                this.start = n.start;
                this.end = n.end;
                this.fire("change:range", e, {
                    deletionPosition: r
                })
            } else if (i) {
                this.fire("change:content", this.toRange(), {
                    deletionPosition: r
                })
            }
        }

        function Af(t, e) {
            switch (e.type) {
                case "insert":
                    return t.containsPosition(e.position);
                case "move":
                case "remove":
                case "reinsert":
                case "merge":
                    return t.containsPosition(e.sourcePosition) || t.start.isEqual(e.sourcePosition) || t.containsPosition(e.targetPosition);
                case "split":
                    return t.containsPosition(e.splitPosition) || t.containsPosition(e.insertionPosition)
            }
            return false
        }
        _s(kf, ds);
        const Cf = "selection:";
        class _f {
            constructor(t) {
                this._selection = new vf(t);
                this._selection.delegate("change:range").to(this);
                this._selection.delegate("change:attribute").to(this);
                this._selection.delegate("change:marker").to(this)
            }
            get isCollapsed() {
                return this._selection.isCollapsed
            }
            get anchor() {
                return this._selection.anchor
            }
            get focus() {
                return this._selection.focus
            }
            get rangeCount() {
                return this._selection.rangeCount
            }
            get hasOwnRange() {
                return this._selection.hasOwnRange
            }
            get isBackward() {
                return this._selection.isBackward
            }
            get isGravityOverridden() {
                return this._selection.isGravityOverridden
            }
            get markers() {
                return this._selection.markers
            }
            get _ranges() {
                return this._selection._ranges
            }
            getRanges() {
                return this._selection.getRanges()
            }
            getFirstPosition() {
                return this._selection.getFirstPosition()
            }
            getLastPosition() {
                return this._selection.getLastPosition()
            }
            getFirstRange() {
                return this._selection.getFirstRange()
            }
            getLastRange() {
                return this._selection.getLastRange()
            }
            getSelectedBlocks() {
                return this._selection.getSelectedBlocks()
            }
            getSelectedElement() {
                return this._selection.getSelectedElement()
            }
            containsEntireContent(t) {
                return this._selection.containsEntireContent(t)
            }
            destroy() {
                this._selection.destroy()
            }
            getAttributeKeys() {
                return this._selection.getAttributeKeys()
            }
            getAttributes() {
                return this._selection.getAttributes()
            }
            getAttribute(t) {
                return this._selection.getAttribute(t)
            }
            hasAttribute(t) {
                return this._selection.hasAttribute(t)
            }
            refresh() {
                this._selection._updateMarkers();
                this._selection._updateAttributes(false)
            }
            observeMarkers(t) {
                this._selection.observeMarkers(t)
            }
            is(t) {
                return t === "selection" || t == "model:selection" || t == "documentSelection" || t == "model:documentSelection"
            }
            _setFocus(t, e) {
                this._selection.setFocus(t, e)
            }
            _setTo(t, e, n) {
                this._selection.setTo(t, e, n)
            }
            _setAttribute(t, e) {
                this._selection.setAttribute(t, e)
            }
            _removeAttribute(t) {
                this._selection.removeAttribute(t)
            }
            _getStoredAttributes() {
                return this._selection._getStoredAttributes()
            }
            _overrideGravity() {
                return this._selection.overrideGravity()
            }
            _restoreGravity(t) {
                this._selection.restoreGravity(t)
            }
            static _getStoreAttributeKey(t) {
                return Cf + t
            }
            static _isStoreAttributeKey(t) {
                return t.startsWith(Cf)
            }
        }
        _s(_f, ds);
        class vf extends uf {
            constructor(t) {
                super();
                this.markers = new vs({
                    idProperty: "name"
                });
                this._model = t.model;
                this._document = t;
                this._attributePriority = new Map;
                this._selectionRestorePosition = null;
                this._hasChangedRange = false;
                this._overriddenGravityRegister = new Set;
                this._observedMarkers = new Set;
                this.listenTo(this._model, "applyOperation", ((t, e) => {
                    const n = e[0];
                    if (!n.isDocumentOperation || n.type == "marker" || n.type == "rename" || n.type == "noop") {
                        return
                    }
                    if (this._ranges.length == 0 && this._selectionRestorePosition) {
                        this._fixGraveyardSelection(this._selectionRestorePosition)
                    }
                    this._selectionRestorePosition = null;
                    if (this._hasChangedRange) {
                        this._hasChangedRange = false;
                        this.fire("change:range", {
                            directChange: false
                        })
                    }
                }), {
                    priority: "lowest"
                });
                this.on("change:range", (() => {
                    for (const t of this.getRanges()) {
                        if (!this._document._validateSelectionRange(t)) {
                            throw new ss["a"]("document-selection-wrong-position", this, {
                                range: t
                            })
                        }
                    }
                }));
                this.listenTo(this._model.markers, "update", ((t, e, n, o) => {
                    this._updateMarker(e, o)
                }));
                this.listenTo(this._document, "change", ((t, e) => {
                    xf(this._model, e)
                }))
            }
            get isCollapsed() {
                const t = this._ranges.length;
                return t === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed
            }
            get anchor() {
                return super.anchor || this._document._getDefaultRange().start
            }
            get focus() {
                return super.focus || this._document._getDefaultRange().end
            }
            get rangeCount() {
                return this._ranges.length ? this._ranges.length : 1
            }
            get hasOwnRange() {
                return this._ranges.length > 0
            }
            get isGravityOverridden() {
                return !!this._overriddenGravityRegister.size
            }
            destroy() {
                for (let t = 0; t < this._ranges.length; t++) {
                    this._ranges[t].detach()
                }
                this.stopListening()
            }* getRanges() {
                if (this._ranges.length) {
                    yield* super.getRanges()
                } else {
                    yield this._document._getDefaultRange()
                }
            }
            getFirstRange() {
                return super.getFirstRange() || this._document._getDefaultRange()
            }
            getLastRange() {
                return super.getLastRange() || this._document._getDefaultRange()
            }
            setTo(t, e, n) {
                super.setTo(t, e, n);
                this._updateAttributes(true);
                this._updateMarkers()
            }
            setFocus(t, e) {
                super.setFocus(t, e);
                this._updateAttributes(true);
                this._updateMarkers()
            }
            setAttribute(t, e) {
                if (this._setAttribute(t, e)) {
                    const e = [t];
                    this.fire("change:attribute", {
                        attributeKeys: e,
                        directChange: true
                    })
                }
            }
            removeAttribute(t) {
                if (this._removeAttribute(t)) {
                    const e = [t];
                    this.fire("change:attribute", {
                        attributeKeys: e,
                        directChange: true
                    })
                }
            }
            overrideGravity() {
                const t = ns();
                this._overriddenGravityRegister.add(t);
                if (this._overriddenGravityRegister.size === 1) {
                    this._updateAttributes(true)
                }
                return t
            }
            restoreGravity(t) {
                if (!this._overriddenGravityRegister.has(t)) {
                    throw new ss["a"]("document-selection-gravity-wrong-restore", this, {
                        uid: t
                    })
                }
                this._overriddenGravityRegister.delete(t);
                if (!this.isGravityOverridden) {
                    this._updateAttributes(true)
                }
            }
            observeMarkers(t) {
                this._observedMarkers.add(t);
                this._updateMarkers()
            }
            _popRange() {
                this._ranges.pop().detach()
            }
            _pushRange(t) {
                const e = this._prepareRange(t);
                if (e) {
                    this._ranges.push(e)
                }
            }
            _prepareRange(t) {
                this._checkRange(t);
                if (t.root == this._document.graveyard) {
                    return
                }
                const e = kf.fromRange(t);
                e.on("change:range", ((t, n, o) => {
                    this._hasChangedRange = true;
                    if (e.root == this._document.graveyard) {
                        this._selectionRestorePosition = o.deletionPosition;
                        const t = this._ranges.indexOf(e);
                        this._ranges.splice(t, 1);
                        e.detach()
                    }
                }));
                return e
            }
            _updateMarkers() {
                if (!this._observedMarkers.size) {
                    return
                }
                const t = [];
                let e = false;
                for (const e of this._model.markers) {
                    const n = e.name.split(":", 1)[0];
                    if (!this._observedMarkers.has(n)) {
                        continue
                    }
                    const o = e.getRange();
                    for (const n of this.getRanges()) {
                        if (o.containsRange(n, !n.isCollapsed)) {
                            t.push(e)
                        }
                    }
                }
                const n = Array.from(this.markers);
                for (const n of t) {
                    if (!this.markers.has(n)) {
                        this.markers.add(n);
                        e = true
                    }
                }
                for (const n of Array.from(this.markers)) {
                    if (!t.includes(n)) {
                        this.markers.remove(n);
                        e = true
                    }
                }
                if (e) {
                    this.fire("change:marker", {
                        oldMarkers: n,
                        directChange: false
                    })
                }
            }
            _updateMarker(t, e) {
                const n = t.name.split(":", 1)[0];
                if (!this._observedMarkers.has(n)) {
                    return
                }
                let o = false;
                const i = Array.from(this.markers);
                const r = this.markers.has(t);
                if (!e) {
                    if (r) {
                        this.markers.remove(t);
                        o = true
                    }
                } else {
                    let n = false;
                    for (const t of this.getRanges()) {
                        if (e.containsRange(t, !t.isCollapsed)) {
                            n = true;
                            break
                        }
                    }
                    if (n && !r) {
                        this.markers.add(t);
                        o = true
                    } else if (!n && r) {
                        this.markers.remove(t);
                        o = true
                    }
                }
                if (o) {
                    this.fire("change:marker", {
                        oldMarkers: i,
                        directChange: false
                    })
                }
            }
            _updateAttributes(t) {
                const e = Ks(this._getSurroundingAttributes());
                const n = Ks(this.getAttributes());
                if (t) {
                    this._attributePriority = new Map;
                    this._attrs = new Map
                } else {
                    for (const [t, e] of this._attributePriority) {
                        if (e == "low") {
                            this._attrs.delete(t);
                            this._attributePriority.delete(t)
                        }
                    }
                }
                this._setAttributesTo(e);
                const o = [];
                for (const [t, e] of this.getAttributes()) {
                    if (!n.has(t) || n.get(t) !== e) {
                        o.push(t)
                    }
                }
                for (const [t] of n) {
                    if (!this.hasAttribute(t)) {
                        o.push(t)
                    }
                }
                if (o.length > 0) {
                    this.fire("change:attribute", {
                        attributeKeys: o,
                        directChange: false
                    })
                }
            }
            _setAttribute(t, e, n = true) {
                const o = n ? "normal" : "low";
                if (o == "low" && this._attributePriority.get(t) == "normal") {
                    return false
                }
                const i = super.getAttribute(t);
                if (i === e) {
                    return false
                }
                this._attrs.set(t, e);
                this._attributePriority.set(t, o);
                return true
            }
            _removeAttribute(t, e = true) {
                const n = e ? "normal" : "low";
                if (n == "low" && this._attributePriority.get(t) == "normal") {
                    return false
                }
                this._attributePriority.set(t, n);
                if (!super.hasAttribute(t)) {
                    return false
                }
                this._attrs.delete(t);
                return true
            }
            _setAttributesTo(t) {
                const e = new Set;
                for (const [e, n] of this.getAttributes()) {
                    if (t.get(e) === n) {
                        continue
                    }
                    this._removeAttribute(e, false)
                }
                for (const [n, o] of t) {
                    const t = this._setAttribute(n, o, false);
                    if (t) {
                        e.add(n)
                    }
                }
                return e
            }* _getStoredAttributes() {
                const t = this.getFirstPosition().parent;
                if (this.isCollapsed && t.isEmpty) {
                    for (const e of t.getAttributeKeys()) {
                        if (e.startsWith(Cf)) {
                            const n = e.substr(Cf.length);
                            yield [n, t.getAttribute(e)]
                        }
                    }
                }
            }
            _getSurroundingAttributes() {
                const t = this.getFirstPosition();
                const e = this._model.schema;
                let n = null;
                if (!this.isCollapsed) {
                    const t = this.getFirstRange();
                    for (const o of t) {
                        if (o.item.is("element") && e.isObject(o.item)) {
                            break
                        }
                        if (o.type == "text") {
                            n = o.item.getAttributes();
                            break
                        }
                    }
                } else {
                    const o = t.textNode ? t.textNode : t.nodeBefore;
                    const i = t.textNode ? t.textNode : t.nodeAfter;
                    if (!this.isGravityOverridden) {
                        n = yf(o)
                    }
                    if (!n) {
                        n = yf(i)
                    }
                    if (!this.isGravityOverridden && !n) {
                        let t = o;
                        while (t && !e.isInline(t) && !n) {
                            t = t.previousSibling;
                            n = yf(t)
                        }
                    }
                    if (!n) {
                        let t = i;
                        while (t && !e.isInline(t) && !n) {
                            t = t.nextSibling;
                            n = yf(t)
                        }
                    }
                    if (!n) {
                        n = this._getStoredAttributes()
                    }
                }
                return n
            }
            _fixGraveyardSelection(t) {
                const e = this._model.schema.getNearestSelectionRange(t);
                if (e) {
                    this._pushRange(e)
                }
            }
        }

        function yf(t) {
            if (t instanceof Yh || t instanceof Kh) {
                return t.getAttributes()
            }
            return null
        }

        function xf(t, e) {
            const n = t.document.differ;
            for (const o of n.getChanges()) {
                if (o.type != "insert") {
                    continue
                }
                const n = o.position.parent;
                const i = o.length === n.maxOffset;
                if (i) {
                    t.enqueueChange(e, (t => {
                        const e = Array.from(n.getAttributeKeys()).filter((t => t.startsWith(Cf)));
                        for (const o of e) {
                            t.removeAttribute(o, n)
                        }
                    }))
                }
            }
        }
        class Df {
            constructor(t) {
                this._dispatchers = t
            }
            add(t) {
                for (const e of this._dispatchers) {
                    t(e)
                }
                return this
            }
        }
        var Mf = 1,
            Ef = 4;

        function Sf(t) {
            return Ur(t, Mf | Ef)
        }
        var Tf = Sf;
        class If extends Df {
            elementToElement(t) {
                return this.add(Zf(t))
            }
            attributeToElement(t) {
                return this.add(Jf(t))
            }
            attributeToAttribute(t) {
                return this.add(Xf(t))
            }
            markerToElement(t) {
                return this.add(tp(t))
            }
            markerToHighlight(t) {
                return this.add(np(t))
            }
            markerToData(t) {
                return this.add(ep(t))
            }
        }

        function Nf() {
            return (t, e, n) => {
                if (!n.consumable.consume(e.item, "insert")) {
                    return
                }
                const o = n.writer;
                const i = n.mapper.toViewPosition(e.range.start);
                const r = o.createText(e.item.data);
                o.insert(i, r)
            }
        }

        function Pf() {
            return (t, e, n) => {
                const o = n.mapper.toViewPosition(e.position);
                const i = e.position.getShiftedBy(e.length);
                const r = n.mapper.toViewPosition(i, {
                    isPhantom: true
                });
                const s = n.writer.createRange(o, r);
                const a = n.writer.remove(s.getTrimmed());
                for (const t of n.writer.createRangeIn(a).getItems()) {
                    n.mapper.unbindViewElement(t)
                }
            }
        }

        function Bf(t, e) {
            const n = t.createAttributeElement("span", e.attributes);
            if (e.classes) {
                n._addClass(e.classes)
            }
            if (e.priority) {
                n._priority = e.priority
            }
            n._id = e.id;
            return n
        }

        function Lf() {
            return (t, e, n) => {
                const o = e.selection;
                if (o.isCollapsed) {
                    return
                }
                if (!n.consumable.consume(o, "selection")) {
                    return
                }
                const i = [];
                for (const t of o.getRanges()) {
                    const e = n.mapper.toViewRange(t);
                    i.push(e)
                }
                n.writer.setSelection(i, {
                    backward: o.isBackward
                })
            }
        }

        function Of() {
            return (t, e, n) => {
                const o = e.selection;
                if (!o.isCollapsed) {
                    return
                }
                if (!n.consumable.consume(o, "selection")) {
                    return
                }
                const i = n.writer;
                const r = o.getFirstPosition();
                const s = n.mapper.toViewPosition(r);
                const a = i.breakAttributes(s);
                i.setSelection(a)
            }
        }

        function zf() {
            return (t, e, n) => {
                const o = n.writer;
                const i = o.document.selection;
                for (const t of i.getRanges()) {
                    if (t.isCollapsed) {
                        if (t.end.parent.isAttached()) {
                            n.writer.mergeAttributes(t.start)
                        }
                    }
                }
                o.setSelection(null)
            }
        }

        function jf(t) {
            return (e, n, o) => {
                const i = t(n.attributeOldValue, o);
                const r = t(n.attributeNewValue, o);
                if (!i && !r) {
                    return
                }
                if (!o.consumable.consume(n.item, e.name)) {
                    return
                }
                const s = o.writer;
                const a = s.document.selection;
                if (n.item instanceof uf || n.item instanceof _f) {
                    s.wrap(a.getFirstRange(), r)
                } else {
                    let t = o.mapper.toViewRange(n.range);
                    if (n.attributeOldValue !== null && i) {
                        t = s.unwrap(t, i)
                    }
                    if (n.attributeNewValue !== null && r) {
                        s.wrap(t, r)
                    }
                }
            }
        }

        function Ff(t) {
            return (e, n, o) => {
                const i = t(n.item, o);
                if (!i) {
                    return
                }
                if (!o.consumable.consume(n.item, "insert")) {
                    return
                }
                const r = o.mapper.toViewPosition(n.range.start);
                o.mapper.bindElements(n.item, i);
                o.writer.insert(r, i)
            }
        }

        function Rf(t) {
            return (e, n, o) => {
                n.isOpening = true;
                const i = t(n, o);
                n.isOpening = false;
                const r = t(n, o);
                if (!i || !r) {
                    return
                }
                const s = n.markerRange;
                if (s.isCollapsed && !o.consumable.consume(s, e.name)) {
                    return
                }
                for (const t of s) {
                    if (!o.consumable.consume(t.item, e.name)) {
                        return
                    }
                }
                const a = o.mapper;
                const c = o.writer;
                c.insert(a.toViewPosition(s.start), i);
                o.mapper.bindElementToMarker(i, n.markerName);
                if (!s.isCollapsed) {
                    c.insert(a.toViewPosition(s.end), r);
                    o.mapper.bindElementToMarker(r, n.markerName)
                }
                e.stop()
            }
        }

        function Vf() {
            return (t, e, n) => {
                const o = n.mapper.markerNameToElements(e.markerName);
                if (!o) {
                    return
                }
                for (const t of o) {
                    n.mapper.unbindElementFromMarkerName(t, e.markerName);
                    n.writer.clear(n.writer.createRangeOn(t), t)
                }
                n.writer.clearClonedElementsGroup(e.markerName);
                t.stop()
            }
        }

        function Uf(t) {
            return (e, n, o) => {
                const i = t(n.markerName, o);
                if (!i) {
                    return
                }
                const r = n.markerRange;
                if (!o.consumable.consume(r, e.name)) {
                    return
                }
                Gf(r, false, o, n, i);
                Gf(r, true, o, n, i);
                e.stop()
            }
        }

        function Gf(t, e, n, o, i) {
            const r = e ? t.start : t.end;
            const s = n.schema.checkChild(r, "$text");
            if (s) {
                const t = n.mapper.toViewPosition(r);
                Yf(t, e, n, o, i)
            } else {
                let t;
                let s;
                if (e && r.nodeAfter || !e && !r.nodeBefore) {
                    t = r.nodeAfter;
                    s = true
                } else {
                    t = r.nodeBefore;
                    s = false
                }
                const a = n.mapper.toViewElement(t);
                Kf(a, e, s, n, o, i)
            }
        }

        function Kf(t, e, n, o, i, r) {
            const s = `data-${r.group}-${e?"start":"end"}-${n?"before":"after"}`;
            const a = t.hasAttribute(s) ? t.getAttribute(s).split(",") : [];
            a.unshift(r.name);
            o.writer.setAttribute(s, a.join(","), t);
            o.mapper.bindElementToMarker(t, i.markerName)
        }

        function Yf(t, e, n, o, i) {
            const r = `${i.group}-${e?"start":"end"}`;
            const s = i.name ? {
                name: i.name
            } : null;
            const a = n.writer.createUIElement(r, s);
            n.writer.insert(t, a);
            n.mapper.bindElementToMarker(a, o.markerName)
        }

        function Hf(t) {
            return (e, n, o) => {
                const i = t(n.markerName, o);
                if (!i) {
                    return
                }
                const r = o.mapper.markerNameToElements(n.markerName);
                if (!r) {
                    return
                }
                for (const t of r) {
                    o.mapper.unbindElementFromMarkerName(t, n.markerName);
                    if (t.is("containerElement")) {
                        s(`data-${i.group}-start-before`, t);
                        s(`data-${i.group}-start-after`, t);
                        s(`data-${i.group}-end-before`, t);
                        s(`data-${i.group}-end-after`, t)
                    } else {
                        o.writer.clear(o.writer.createRangeOn(t), t)
                    }
                }
                o.writer.clearClonedElementsGroup(n.markerName);
                e.stop();

                function s(t, e) {
                    if (e.hasAttribute(t)) {
                        const n = new Set(e.getAttribute(t).split(","));
                        n.delete(i.name);
                        if (n.size == 0) {
                            o.writer.removeAttribute(t, e)
                        } else {
                            o.writer.setAttribute(t, Array.from(n).join(","), e)
                        }
                    }
                }
            }
        }

        function qf(t) {
            return (e, n, o) => {
                const i = t(n.attributeOldValue, o);
                const r = t(n.attributeNewValue, o);
                if (!i && !r) {
                    return
                }
                if (!o.consumable.consume(n.item, e.name)) {
                    return
                }
                const s = o.mapper.toViewElement(n.item);
                const a = o.writer;
                if (!s) {
                    throw new ss["a"]("conversion-attribute-to-attribute-on-text", [n, o])
                }
                if (n.attributeOldValue !== null && i) {
                    if (i.key == "class") {
                        const t = xs(i.value);
                        for (const e of t) {
                            a.removeClass(e, s)
                        }
                    } else if (i.key == "style") {
                        const t = Object.keys(i.value);
                        for (const e of t) {
                            a.removeStyle(e, s)
                        }
                    } else {
                        a.removeAttribute(i.key, s)
                    }
                }
                if (n.attributeNewValue !== null && r) {
                    if (r.key == "class") {
                        const t = xs(r.value);
                        for (const e of t) {
                            a.addClass(e, s)
                        }
                    } else if (r.key == "style") {
                        const t = Object.keys(r.value);
                        for (const e of t) {
                            a.setStyle(e, r.value[e], s)
                        }
                    } else {
                        a.setAttribute(r.key, r.value, s)
                    }
                }
            }
        }

        function Wf(t) {
            return (e, n, o) => {
                if (!n.item) {
                    return
                }
                if (!(n.item instanceof uf || n.item instanceof _f) && !n.item.is("$textProxy")) {
                    return
                }
                const i = ap(t, n, o);
                if (!i) {
                    return
                }
                if (!o.consumable.consume(n.item, e.name)) {
                    return
                }
                const r = o.writer;
                const s = Bf(r, i);
                const a = r.document.selection;
                if (n.item instanceof uf || n.item instanceof _f) {
                    r.wrap(a.getFirstRange(), s, a)
                } else {
                    const t = o.mapper.toViewRange(n.range);
                    const e = r.wrap(t, s);
                    for (const t of e.getItems()) {
                        if (t.is("attributeElement") && t.isSimilar(s)) {
                            o.mapper.bindElementToMarker(t, n.markerName);
                            break
                        }
                    }
                }
            }
        }

        function Qf(t) {
            return (e, n, o) => {
                if (!n.item) {
                    return
                }
                if (!(n.item instanceof qh)) {
                    return
                }
                const i = ap(t, n, o);
                if (!i) {
                    return
                }
                if (!o.consumable.test(n.item, e.name)) {
                    return
                }
                const r = o.mapper.toViewElement(n.item);
                if (r && r.getCustomProperty("addHighlight")) {
                    o.consumable.consume(n.item, e.name);
                    for (const t of ef._createIn(n.item)) {
                        o.consumable.consume(t.item, e.name)
                    }
                    r.getCustomProperty("addHighlight")(r, i, o.writer);
                    o.mapper.bindElementToMarker(r, n.markerName)
                }
            }
        }

        function $f(t) {
            return (e, n, o) => {
                if (n.markerRange.isCollapsed) {
                    return
                }
                const i = ap(t, n, o);
                if (!i) {
                    return
                }
                const r = Bf(o.writer, i);
                const s = o.mapper.markerNameToElements(n.markerName);
                if (!s) {
                    return
                }
                for (const t of s) {
                    o.mapper.unbindElementFromMarkerName(t, n.markerName);
                    if (t.is("attributeElement")) {
                        o.writer.unwrap(o.writer.createRangeOn(t), r)
                    } else {
                        t.getCustomProperty("removeHighlight")(t, i.id, o.writer)
                    }
                }
                o.writer.clearClonedElementsGroup(n.markerName);
                e.stop()
            }
        }

        function Zf(t) {
            t = Tf(t);
            t.view = op(t.view, "container");
            return e => {
                e.on("insert:" + t.model, Ff(t.view), {
                    priority: t.converterPriority || "normal"
                });
                if (t.triggerBy) {
                    if (t.triggerBy.attributes) {
                        for (const n of t.triggerBy.attributes) {
                            e._mapReconversionTriggerEvent(t.model, `attribute:${n}:${t.model}`)
                        }
                    }
                    if (t.triggerBy.children) {
                        for (const n of t.triggerBy.children) {
                            e._mapReconversionTriggerEvent(t.model, `insert:${n}`);
                            e._mapReconversionTriggerEvent(t.model, `remove:${n}`)
                        }
                    }
                }
            }
        }

        function Jf(t) {
            t = Tf(t);
            const e = t.model.key ? t.model.key : t.model;
            let n = "attribute:" + e;
            if (t.model.name) {
                n += ":" + t.model.name
            }
            if (t.model.values) {
                for (const e of t.model.values) {
                    t.view[e] = op(t.view[e], "attribute")
                }
            } else {
                t.view = op(t.view, "attribute")
            }
            const o = rp(t);
            return e => {
                e.on(n, jf(o), {
                    priority: t.converterPriority || "normal"
                })
            }
        }

        function Xf(t) {
            t = Tf(t);
            const e = t.model.key ? t.model.key : t.model;
            let n = "attribute:" + e;
            if (t.model.name) {
                n += ":" + t.model.name
            }
            if (t.model.values) {
                for (const e of t.model.values) {
                    t.view[e] = sp(t.view[e])
                }
            } else {
                t.view = sp(t.view)
            }
            const o = rp(t);
            return e => {
                e.on(n, qf(o), {
                    priority: t.converterPriority || "normal"
                })
            }
        }

        function tp(t) {
            t = Tf(t);
            t.view = op(t.view, "ui");
            return e => {
                e.on("addMarker:" + t.model, Rf(t.view), {
                    priority: t.converterPriority || "normal"
                });
                e.on("removeMarker:" + t.model, Vf(t.view), {
                    priority: t.converterPriority || "normal"
                })
            }
        }

        function ep(t) {
            t = Tf(t);
            const e = t.model;
            if (!t.view) {
                t.view = n => ({
                    group: e,
                    name: n.substr(t.model.length + 1)
                })
            }
            return n => {
                n.on("addMarker:" + e, Uf(t.view), {
                    priority: t.converterPriority || "normal"
                });
                n.on("removeMarker:" + e, Hf(t.view), {
                    priority: t.converterPriority || "normal"
                })
            }
        }

        function np(t) {
            return e => {
                e.on("addMarker:" + t.model, Wf(t.view), {
                    priority: t.converterPriority || "normal"
                });
                e.on("addMarker:" + t.model, Qf(t.view), {
                    priority: t.converterPriority || "normal"
                });
                e.on("removeMarker:" + t.model, $f(t.view), {
                    priority: t.converterPriority || "normal"
                })
            }
        }

        function op(t, e) {
            if (typeof t == "function") {
                return t
            }
            return (n, o) => ip(t, o, e)
        }

        function ip(t, e, n) {
            if (typeof t == "string") {
                t = {
                    name: t
                }
            }
            let o;
            const i = e.writer;
            const r = Object.assign({}, t.attributes);
            if (n == "container") {
                o = i.createContainerElement(t.name, r)
            } else if (n == "attribute") {
                const e = {
                    priority: t.priority || Al.DEFAULT_PRIORITY
                };
                o = i.createAttributeElement(t.name, r, e)
            } else {
                o = i.createUIElement(t.name, r)
            }
            if (t.styles) {
                const e = Object.keys(t.styles);
                for (const n of e) {
                    i.setStyle(n, t.styles[n], o)
                }
            }
            if (t.classes) {
                const e = t.classes;
                if (typeof e == "string") {
                    i.addClass(e, o)
                } else {
                    for (const t of e) {
                        i.addClass(t, o)
                    }
                }
            }
            return o
        }

        function rp(t) {
            if (t.model.values) {
                return (e, n) => {
                    const o = t.view[e];
                    if (o) {
                        return o(e, n)
                    }
                    return null
                }
            } else {
                return t.view
            }
        }

        function sp(t) {
            if (typeof t == "string") {
                return e => ({
                    key: t,
                    value: e
                })
            } else if (typeof t == "object") {
                if (t.value) {
                    return () => t
                } else {
                    return e => ({
                        key: t.key,
                        value: e
                    })
                }
            } else {
                return t
            }
        }

        function ap(t, e, n) {
            const o = typeof t == "function" ? t(e, n) : t;
            if (!o) {
                return null
            }
            if (!o.priority) {
                o.priority = 10
            }
            if (!o.id) {
                o.id = e.markerName
            }
            return o
        }

        function cp(t) {
            const {
                schema: e,
                document: n
            } = t.model;
            for (const o of n.getRootNames()) {
                const i = n.getRoot(o);
                if (i.isEmpty && !e.checkChild(i, "$text")) {
                    if (e.checkChild(i, "paragraph")) {
                        t.insertElement("paragraph", i);
                        return true
                    }
                }
            }
            return false
        }

        function lp(t, e, n) {
            const o = n.createContext(t);
            if (!n.checkChild(o, "paragraph")) {
                return false
            }
            if (!n.checkChild(o.push("paragraph"), e)) {
                return false
            }
            return true
        }

        function dp(t, e) {
            const n = e.createElement("paragraph");
            e.insert(n, t);
            return e.createPositionAt(n, 0)
        }
        class up extends Df {
            elementToElement(t) {
                return this.add(mp(t))
            }
            elementToAttribute(t) {
                return this.add(gp(t))
            }
            attributeToAttribute(t) {
                return this.add(kp(t))
            }
            elementToMarker(t) {
                Object(ss["c"])("upcast-helpers-element-to-marker-deprecated");
                return this.add(bp(t))
            }
            dataToMarker(t) {
                return this.add(wp(t))
            }
        }

        function hp() {
            return (t, e, n) => {
                if (!e.modelRange && n.consumable.consume(e.viewItem, {
                        name: true
                    })) {
                    const {
                        modelRange: t,
                        modelCursor: o
                    } = n.convertChildren(e.viewItem, e.modelCursor);
                    e.modelRange = t;
                    e.modelCursor = o
                }
            }
        }

        function fp() {
            return (t, e, {
                schema: n,
                consumable: o,
                writer: i
            }) => {
                let r = e.modelCursor;
                if (!o.test(e.viewItem)) {
                    return
                }
                if (!n.checkChild(r, "$text")) {
                    if (!lp(r, "$text", n)) {
                        return
                    }
                    r = dp(r, i)
                }
                o.consume(e.viewItem);
                const s = i.createText(e.viewItem.data);
                i.insert(s, r);
                e.modelRange = i.createRange(r, r.getShiftedBy(s.offsetSize));
                e.modelCursor = e.modelRange.end
            }
        }

        function pp(t, e) {
            return (n, o) => {
                const i = o.newSelection;
                const r = [];
                for (const t of i.getRanges()) {
                    r.push(e.toModelRange(t))
                }
                const s = t.createSelection(r, {
                    backward: i.isBackward
                });
                if (!s.isEqual(t.document.selection)) {
                    t.change((t => {
                        t.setSelection(s)
                    }))
                }
            }
        }

        function mp(t) {
            t = Tf(t);
            const e = _p(t);
            const n = Cp(t.view);
            const o = n ? "element:" + n : "element";
            return n => {
                n.on(o, e, {
                    priority: t.converterPriority || "normal"
                })
            }
        }

        function gp(t) {
            t = Tf(t);
            xp(t);
            const e = Dp(t, false);
            const n = Cp(t.view);
            const o = n ? "element:" + n : "element";
            return n => {
                n.on(o, e, {
                    priority: t.converterPriority || "low"
                })
            }
        }

        function kp(t) {
            t = Tf(t);
            let e = null;
            if (typeof t.view == "string" || t.view.key) {
                e = yp(t)
            }
            xp(t, e);
            const n = Dp(t, true);
            return e => {
                e.on("element", n, {
                    priority: t.converterPriority || "low"
                })
            }
        }

        function bp(t) {
            t = Tf(t);
            Sp(t);
            return mp(t)
        }

        function wp(t) {
            t = Tf(t);
            if (!t.model) {
                t.model = e => e ? t.view + ":" + e : t.view
            }
            const e = _p(Tp(t, "start"));
            const n = _p(Tp(t, "end"));
            return o => {
                o.on("element:" + t.view + "-start", e, {
                    priority: t.converterPriority || "normal"
                });
                o.on("element:" + t.view + "-end", n, {
                    priority: t.converterPriority || "normal"
                });
                const i = is.get("low");
                const r = is.get("highest");
                const s = is.get(t.converterPriority) / r;
                o.on("element", Ap(t), {
                    priority: i + s
                })
            }
        }

        function Ap(t) {
            return (e, n, o) => {
                const i = `data-${t.view}`;
                if (!n.modelRange) {
                    n = Object.assign(n, o.convertChildren(n.viewItem, n.modelCursor))
                }
                if (o.consumable.consume(n.viewItem, {
                        attributes: i + "-end-after"
                    })) {
                    r(n.modelRange.end, n.viewItem.getAttribute(i + "-end-after").split(","))
                }
                if (o.consumable.consume(n.viewItem, {
                        attributes: i + "-start-after"
                    })) {
                    r(n.modelRange.end, n.viewItem.getAttribute(i + "-start-after").split(","))
                }
                if (o.consumable.consume(n.viewItem, {
                        attributes: i + "-end-before"
                    })) {
                    r(n.modelRange.start, n.viewItem.getAttribute(i + "-end-before").split(","))
                }
                if (o.consumable.consume(n.viewItem, {
                        attributes: i + "-start-before"
                    })) {
                    r(n.modelRange.start, n.viewItem.getAttribute(i + "-start-before").split(","))
                }

                function r(e, i) {
                    for (const r of i) {
                        const i = t.model(r, o);
                        const s = o.writer.createElement("$marker", {
                            "data-name": i
                        });
                        o.writer.insert(s, e);
                        if (n.modelCursor.isEqual(e)) {
                            n.modelCursor = n.modelCursor.getShiftedBy(1)
                        } else {
                            n.modelCursor = n.modelCursor._getTransformedByInsertion(e, 1)
                        }
                        n.modelRange = n.modelRange._getTransformedByInsertion(e, 1)[0]
                    }
                }
            }
        }

        function Cp(t) {
            if (typeof t == "string") {
                return t
            }
            if (typeof t == "object" && typeof t.name == "string") {
                return t.name
            }
            return null
        }

        function _p(t) {
            const e = new Ys(t.view);
            return (n, o, i) => {
                const r = e.match(o.viewItem);
                if (!r) {
                    return
                }
                const s = r.match;
                s.name = true;
                if (!i.consumable.test(o.viewItem, s)) {
                    return
                }
                const a = vp(t.model, o.viewItem, i);
                if (!a) {
                    return
                }
                if (!i.safeInsert(a, o.modelCursor)) {
                    return
                }
                i.consumable.consume(o.viewItem, s);
                i.convertChildren(o.viewItem, a);
                i.updateConversionResult(a, o)
            }
        }

        function vp(t, e, n) {
            if (t instanceof Function) {
                return t(e, n)
            } else {
                return n.writer.createElement(t)
            }
        }

        function yp(t) {
            if (typeof t.view == "string") {
                t.view = {
                    key: t.view
                }
            }
            const e = t.view.key;
            let n;
            if (e == "class" || e == "style") {
                const o = e == "class" ? "classes" : "styles";
                n = {
                    [o]: t.view.value
                }
            } else {
                const o = typeof t.view.value == "undefined" ? /[\s\S]*/ : t.view.value;
                n = {
                    attributes: {
                        [e]: o
                    }
                }
            }
            if (t.view.name) {
                n.name = t.view.name
            }
            t.view = n;
            return e
        }

        function xp(t, e = null) {
            const n = e === null ? true : t => t.getAttribute(e);
            const o = typeof t.model != "object" ? t.model : t.model.key;
            const i = typeof t.model != "object" || typeof t.model.value == "undefined" ? n : t.model.value;
            t.model = {
                key: o,
                value: i
            }
        }

        function Dp(t, e) {
            const n = new Ys(t.view);
            return (o, i, r) => {
                const s = n.match(i.viewItem);
                if (!s) {
                    return
                }
                const a = t.model.key;
                const c = typeof t.model.value == "function" ? t.model.value(i.viewItem, r) : t.model.value;
                if (c === null) {
                    return
                }
                if (Mp(t.view, i.viewItem)) {
                    s.match.name = true
                } else {
                    delete s.match.name
                }
                if (!r.consumable.test(i.viewItem, s.match)) {
                    return
                }
                if (!i.modelRange) {
                    i = Object.assign(i, r.convertChildren(i.viewItem, i.modelCursor))
                }
                const l = Ep(i.modelRange, {
                    key: a,
                    value: c
                }, e, r);
                if (l) {
                    r.consumable.consume(i.viewItem, s.match)
                }
            }
        }

        function Mp(t, e) {
            const n = typeof t == "function" ? t(e) : t;
            if (typeof n == "object" && !Cp(n)) {
                return false
            }
            return !n.classes && !n.attributes && !n.styles
        }

        function Ep(t, e, n, o) {
            let i = false;
            for (const r of Array.from(t.getItems({
                    shallow: n
                }))) {
                if (o.schema.checkAttribute(r, e.key)) {
                    o.writer.setAttribute(e.key, e.value, r);
                    i = true
                }
            }
            return i
        }

        function Sp(t) {
            const e = t.model;
            t.model = (t, n) => {
                const o = typeof e == "string" ? e : e(t, n);
                return n.writer.createElement("$marker", {
                    "data-name": o
                })
            }
        }

        function Tp(t, e) {
            const n = {};
            n.view = t.view + "-" + e;
            n.model = (e, n) => {
                const o = e.getAttribute("name");
                const i = t.model(o, n);
                return n.writer.createElement("$marker", {
                    "data-name": i
                })
            };
            return n
        }
        class Ip {
            constructor(t, e) {
                this.model = t;
                this.view = new Uh(e);
                this.mapper = new nf;
                this.downcastDispatcher = new sf({
                    mapper: this.mapper,
                    schema: t.schema
                });
                const n = this.model.document;
                const o = n.selection;
                const i = this.model.markers;
                this.listenTo(this.model, "_beforeChanges", (() => {
                    this.view._disableRendering(true)
                }), {
                    priority: "highest"
                });
                this.listenTo(this.model, "_afterChanges", (() => {
                    this.view._disableRendering(false)
                }), {
                    priority: "lowest"
                });
                this.listenTo(n, "change", (() => {
                    this.view.change((t => {
                        this.downcastDispatcher.convertChanges(n.differ, i, t);
                        this.downcastDispatcher.convertSelection(o, i, t)
                    }))
                }), {
                    priority: "low"
                });
                this.listenTo(this.view.document, "selectionChange", pp(this.model, this.mapper));
                this.downcastDispatcher.on("insert:$text", Nf(), {
                    priority: "lowest"
                });
                this.downcastDispatcher.on("remove", Pf(), {
                    priority: "low"
                });
                this.downcastDispatcher.on("selection", zf(), {
                    priority: "low"
                });
                this.downcastDispatcher.on("selection", Lf(), {
                    priority: "low"
                });
                this.downcastDispatcher.on("selection", Of(), {
                    priority: "low"
                });
                this.view.document.roots.bindTo(this.model.document.roots).using((t => {
                    if (t.rootName == "$graveyard") {
                        return null
                    }
                    const e = new dl(this.view.document, t.name);
                    e.rootName = t.rootName;
                    this.mapper.bindElements(t, e);
                    return e
                }))
            }
            destroy() {
                this.view.destroy();
                this.stopListening()
            }
        }
        _s(Ip, Zc);
        class Np {
            constructor() {
                this._commands = new Map
            }
            add(t, e) {
                this._commands.set(t, e)
            }
            get(t) {
                return this._commands.get(t)
            }
            execute(t, ...e) {
                const n = this.get(t);
                if (!n) {
                    throw new ss["a"]("commandcollection-command-not-found", this, {
                        commandName: t
                    })
                }
                return n.execute(...e)
            }* names() {
                yield* this._commands.keys()
            }* commands() {
                yield* this._commands.values()
            } [Symbol.iterator]() {
                return this._commands[Symbol.iterator]()
            }
            destroy() {
                for (const t of this.commands()) {
                    t.destroy()
                }
            }
        }
        class Pp {
            constructor() {
                this._consumables = new Map
            }
            add(t, e) {
                let n;
                if (t.is("$text") || t.is("documentFragment")) {
                    this._consumables.set(t, true);
                    return
                }
                if (!this._consumables.has(t)) {
                    n = new Bp(t);
                    this._consumables.set(t, n)
                } else {
                    n = this._consumables.get(t)
                }
                n.add(e)
            }
            test(t, e) {
                const n = this._consumables.get(t);
                if (n === undefined) {
                    return null
                }
                if (t.is("$text") || t.is("documentFragment")) {
                    return n
                }
                return n.test(e)
            }
            consume(t, e) {
                if (this.test(t, e)) {
                    if (t.is("$text") || t.is("documentFragment")) {
                        this._consumables.set(t, false)
                    } else {
                        this._consumables.get(t).consume(e)
                    }
                    return true
                }
                return false
            }
            revert(t, e) {
                const n = this._consumables.get(t);
                if (n !== undefined) {
                    if (t.is("$text") || t.is("documentFragment")) {
                        this._consumables.set(t, true)
                    } else {
                        n.revert(e)
                    }
                }
            }
            static consumablesFromElement(t) {
                const e = {
                    element: t,
                    name: true,
                    attributes: [],
                    classes: [],
                    styles: []
                };
                const n = t.getAttributeKeys();
                for (const t of n) {
                    if (t == "style" || t == "class") {
                        continue
                    }
                    e.attributes.push(t)
                }
                const o = t.getClassNames();
                for (const t of o) {
                    e.classes.push(t)
                }
                const i = t.getStyleNames();
                for (const t of i) {
                    e.styles.push(t)
                }
                return e
            }
            static createFrom(t, e) {
                if (!e) {
                    e = new Pp(t)
                }
                if (t.is("$text")) {
                    e.add(t);
                    return e
                }
                if (t.is("element")) {
                    e.add(t, Pp.consumablesFromElement(t))
                }
                if (t.is("documentFragment")) {
                    e.add(t)
                }
                for (const n of t.getChildren()) {
                    e = Pp.createFrom(n, e)
                }
                return e
            }
        }
        class Bp {
            constructor(t) {
                this.element = t;
                this._canConsumeName = null;
                this._consumables = {
                    attributes: new Map,
                    styles: new Map,
                    classes: new Map
                }
            }
            add(t) {
                if (t.name) {
                    this._canConsumeName = true
                }
                for (const e in this._consumables) {
                    if (e in t) {
                        this._add(e, t[e])
                    }
                }
            }
            test(t) {
                if (t.name && !this._canConsumeName) {
                    return this._canConsumeName
                }
                for (const e in this._consumables) {
                    if (e in t) {
                        const n = this._test(e, t[e]);
                        if (n !== true) {
                            return n
                        }
                    }
                }
                return true
            }
            consume(t) {
                if (t.name) {
                    this._canConsumeName = false
                }
                for (const e in this._consumables) {
                    if (e in t) {
                        this._consume(e, t[e])
                    }
                }
            }
            revert(t) {
                if (t.name) {
                    this._canConsumeName = true
                }
                for (const e in this._consumables) {
                    if (e in t) {
                        this._revert(e, t[e])
                    }
                }
            }
            _add(t, e) {
                const n = Qe(e) ? e : [e];
                const o = this._consumables[t];
                for (const e of n) {
                    if (t === "attributes" && (e === "class" || e === "style")) {
                        throw new ss["a"]("viewconsumable-invalid-attribute", this)
                    }
                    o.set(e, true);
                    if (t === "styles") {
                        for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) {
                            o.set(t, true)
                        }
                    }
                }
            }
            _test(t, e) {
                const n = Qe(e) ? e : [e];
                const o = this._consumables[t];
                for (const e of n) {
                    if (t === "attributes" && (e === "class" || e === "style")) {
                        const t = e == "class" ? "classes" : "styles";
                        const n = this._test(t, [...this._consumables[t].keys()]);
                        if (n !== true) {
                            return n
                        }
                    } else {
                        const t = o.get(e);
                        if (t === undefined) {
                            return null
                        }
                        if (!t) {
                            return false
                        }
                    }
                }
                return true
            }
            _consume(t, e) {
                const n = Qe(e) ? e : [e];
                const o = this._consumables[t];
                for (const e of n) {
                    if (t === "attributes" && (e === "class" || e === "style")) {
                        const t = e == "class" ? "classes" : "styles";
                        this._consume(t, [...this._consumables[t].keys()])
                    } else {
                        o.set(e, false);
                        if (t == "styles") {
                            for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) {
                                o.set(t, false)
                            }
                        }
                    }
                }
            }
            _revert(t, e) {
                const n = Qe(e) ? e : [e];
                const o = this._consumables[t];
                for (const e of n) {
                    if (t === "attributes" && (e === "class" || e === "style")) {
                        const t = e == "class" ? "classes" : "styles";
                        this._revert(t, [...this._consumables[t].keys()])
                    } else {
                        const t = o.get(e);
                        if (t === false) {
                            o.set(e, true)
                        }
                    }
                }
            }
        }
        class Lp {
            constructor() {
                this._sourceDefinitions = {};
                this._attributeProperties = {};
                this.decorate("checkChild");
                this.decorate("checkAttribute");
                this.on("checkAttribute", ((t, e) => {
                    e[0] = new Op(e[0])
                }), {
                    priority: "highest"
                });
                this.on("checkChild", ((t, e) => {
                    e[0] = new Op(e[0]);
                    e[1] = this.getDefinition(e[1])
                }), {
                    priority: "highest"
                })
            }
            register(t, e) {
                if (this._sourceDefinitions[t]) {
                    throw new ss["a"]("schema-cannot-register-item-twice", this, {
                        itemName: t
                    })
                }
                this._sourceDefinitions[t] = [Object.assign({}, e)];
                this._clearCache()
            }
            extend(t, e) {
                if (!this._sourceDefinitions[t]) {
                    throw new ss["a"]("schema-cannot-extend-missing-item", this, {
                        itemName: t
                    })
                }
                this._sourceDefinitions[t].push(Object.assign({}, e));
                this._clearCache()
            }
            getDefinitions() {
                if (!this._compiledDefinitions) {
                    this._compile()
                }
                return this._compiledDefinitions
            }
            getDefinition(t) {
                let e;
                if (typeof t == "string") {
                    e = t
                } else if (t.is && (t.is("$text") || t.is("$textProxy"))) {
                    e = "$text"
                } else {
                    e = t.name
                }
                return this.getDefinitions()[e]
            }
            isRegistered(t) {
                return !!this.getDefinition(t)
            }
            isBlock(t) {
                const e = this.getDefinition(t);
                return !!(e && e.isBlock)
            }
            isLimit(t) {
                const e = this.getDefinition(t);
                if (!e) {
                    return false
                }
                return !!(e.isLimit || e.isObject)
            }
            isObject(t) {
                const e = this.getDefinition(t);
                if (!e) {
                    return false
                }
                return !!(e.isObject || e.isLimit && e.isSelectable && e.isContent)
            }
            isInline(t) {
                const e = this.getDefinition(t);
                return !!(e && e.isInline)
            }
            isSelectable(t) {
                const e = this.getDefinition(t);
                if (!e) {
                    return false
                }
                return !!(e.isSelectable || e.isObject)
            }
            isContent(t) {
                const e = this.getDefinition(t);
                if (!e) {
                    return false
                }
                return !!(e.isContent || e.isObject)
            }
            checkChild(t, e) {
                if (!e) {
                    return false
                }
                return this._checkContextMatch(e, t)
            }
            checkAttribute(t, e) {
                const n = this.getDefinition(t.last);
                if (!n) {
                    return false
                }
                return n.allowAttributes.includes(e)
            }
            checkMerge(t, e = null) {
                if (t instanceof Zh) {
                    const e = t.nodeBefore;
                    const n = t.nodeAfter;
                    if (!(e instanceof qh)) {
                        throw new ss["a"]("schema-check-merge-no-element-before", this)
                    }
                    if (!(n instanceof qh)) {
                        throw new ss["a"]("schema-check-merge-no-element-after", this)
                    }
                    return this.checkMerge(e, n)
                }
                for (const n of e.getChildren()) {
                    if (!this.checkChild(t, n)) {
                        return false
                    }
                }
                return true
            }
            addChildCheck(t) {
                this.on("checkChild", ((e, [n, o]) => {
                    if (!o) {
                        return
                    }
                    const i = t(n, o);
                    if (typeof i == "boolean") {
                        e.stop();
                        e.return = i
                    }
                }), {
                    priority: "high"
                })
            }
            addAttributeCheck(t) {
                this.on("checkAttribute", ((e, [n, o]) => {
                    const i = t(n, o);
                    if (typeof i == "boolean") {
                        e.stop();
                        e.return = i
                    }
                }), {
                    priority: "high"
                })
            }
            setAttributeProperties(t, e) {
                this._attributeProperties[t] = Object.assign(this.getAttributeProperties(t), e)
            }
            getAttributeProperties(t) {
                return this._attributeProperties[t] || {}
            }
            getLimitElement(t) {
                let e;
                if (t instanceof Zh) {
                    e = t.parent
                } else {
                    const n = t instanceof ef ? [t] : Array.from(t.getRanges());
                    e = n.reduce(((t, e) => {
                        const n = e.getCommonAncestor();
                        if (!t) {
                            return n
                        }
                        return t.getCommonAncestor(n, {
                            includeSelf: true
                        })
                    }), null)
                }
                while (!this.isLimit(e)) {
                    if (e.parent) {
                        e = e.parent
                    } else {
                        break
                    }
                }
                return e
            }
            checkAttributeInSelection(t, e) {
                if (t.isCollapsed) {
                    const n = t.getFirstPosition();
                    const o = [...n.getAncestors(), new Kh("", t.getAttributes())];
                    return this.checkAttribute(o, e)
                } else {
                    const n = t.getRanges();
                    for (const t of n) {
                        for (const n of t) {
                            if (this.checkAttribute(n.item, e)) {
                                return true
                            }
                        }
                    }
                }
                return false
            }* getValidRanges(t, e) {
                t = Zp(t);
                for (const n of t) {
                    yield* this._getValidRangesForRange(n, e)
                }
            }
            getNearestSelectionRange(t, e = "both") {
                if (this.checkChild(t, "$text")) {
                    return new ef(t)
                }
                let n, o;
                const i = t.getAncestors().reverse().find((t => this.isLimit(t))) || t.root;
                if (e == "both" || e == "backward") {
                    n = new Qh({
                        boundaries: ef._createIn(i),
                        startPosition: t,
                        direction: "backward"
                    })
                }
                if (e == "both" || e == "forward") {
                    o = new Qh({
                        boundaries: ef._createIn(i),
                        startPosition: t
                    })
                }
                for (const t of $p(n, o)) {
                    const e = t.walker == n ? "elementEnd" : "elementStart";
                    const o = t.value;
                    if (o.type == e && this.isObject(o.item)) {
                        return ef._createOn(o.item)
                    }
                    if (this.checkChild(o.nextPosition, "$text")) {
                        return new ef(o.nextPosition)
                    }
                }
                return null
            }
            findAllowedParent(t, e) {
                let n = t.parent;
                while (n) {
                    if (this.checkChild(n, e)) {
                        return n
                    }
                    if (this.isLimit(n)) {
                        return null
                    }
                    n = n.parent
                }
                return null
            }
            removeDisallowedAttributes(t, e) {
                for (const n of t) {
                    if (n.is("$text")) {
                        Jp(this, n, e)
                    } else {
                        const t = ef._createIn(n);
                        const o = t.getPositions();
                        for (const t of o) {
                            const n = t.nodeBefore || t.parent;
                            Jp(this, n, e)
                        }
                    }
                }
            }
            createContext(t) {
                return new Op(t)
            }
            _clearCache() {
                this._compiledDefinitions = null
            }
            _compile() {
                const t = {};
                const e = this._sourceDefinitions;
                const n = Object.keys(e);
                for (const o of n) {
                    t[o] = zp(e[o], o)
                }
                for (const e of n) {
                    jp(t, e)
                }
                for (const e of n) {
                    Fp(t, e)
                }
                for (const e of n) {
                    Rp(t, e);
                    Vp(t, e)
                }
                for (const e of n) {
                    Up(t, e);
                    Gp(t, e)
                }
                this._compiledDefinitions = t
            }
            _checkContextMatch(t, e, n = e.length - 1) {
                const o = e.getItem(n);
                if (t.allowIn.includes(o.name)) {
                    if (n == 0) {
                        return true
                    } else {
                        const t = this.getDefinition(o);
                        return this._checkContextMatch(t, e, n - 1)
                    }
                } else {
                    return false
                }
            }* _getValidRangesForRange(t, e) {
                let n = t.start;
                let o = t.start;
                for (const i of t.getItems({
                        shallow: true
                    })) {
                    if (i.is("element")) {
                        yield* this._getValidRangesForRange(ef._createIn(i), e)
                    }
                    if (!this.checkAttribute(i, e)) {
                        if (!n.isEqual(o)) {
                            yield new ef(n, o)
                        }
                        n = Zh._createAfter(i)
                    }
                    o = Zh._createAfter(i)
                }
                if (!n.isEqual(o)) {
                    yield new ef(n, o)
                }
            }
        }
        _s(Lp, Zc);
        class Op {
            constructor(t) {
                if (t instanceof Op) {
                    return t
                }
                if (typeof t == "string") {
                    t = [t]
                } else if (!Array.isArray(t)) {
                    t = t.getAncestors({
                        includeSelf: true
                    })
                }
                if (t[0] && typeof t[0] != "string" && t[0].is("documentFragment")) {
                    t.shift()
                }
                this._items = t.map(Qp)
            }
            get length() {
                return this._items.length
            }
            get last() {
                return this._items[this._items.length - 1]
            } [Symbol.iterator]() {
                return this._items[Symbol.iterator]()
            }
            push(t) {
                const e = new Op([t]);
                e._items = [...this._items, ...e._items];
                return e
            }
            getItem(t) {
                return this._items[t]
            }* getNames() {
                yield* this._items.map((t => t.name))
            }
            endsWith(t) {
                return Array.from(this.getNames()).join(" ").endsWith(t)
            }
            startsWith(t) {
                return Array.from(this.getNames()).join(" ").startsWith(t)
            }
        }

        function zp(t, e) {
            const n = {
                name: e,
                allowIn: [],
                allowContentOf: [],
                allowWhere: [],
                allowAttributes: [],
                allowAttributesOf: [],
                inheritTypesFrom: []
            };
            Kp(t, n);
            Yp(t, n, "allowIn");
            Yp(t, n, "allowContentOf");
            Yp(t, n, "allowWhere");
            Yp(t, n, "allowAttributes");
            Yp(t, n, "allowAttributesOf");
            Yp(t, n, "inheritTypesFrom");
            Hp(t, n);
            return n
        }

        function jp(t, e) {
            for (const n of t[e].allowContentOf) {
                if (t[n]) {
                    const o = qp(t, n);
                    o.forEach((t => {
                        t.allowIn.push(e)
                    }))
                }
            }
            delete t[e].allowContentOf
        }

        function Fp(t, e) {
            for (const n of t[e].allowWhere) {
                const o = t[n];
                if (o) {
                    const n = o.allowIn;
                    t[e].allowIn.push(...n)
                }
            }
            delete t[e].allowWhere
        }

        function Rp(t, e) {
            for (const n of t[e].allowAttributesOf) {
                const o = t[n];
                if (o) {
                    const n = o.allowAttributes;
                    t[e].allowAttributes.push(...n)
                }
            }
            delete t[e].allowAttributesOf
        }

        function Vp(t, e) {
            const n = t[e];
            for (const e of n.inheritTypesFrom) {
                const o = t[e];
                if (o) {
                    const t = Object.keys(o).filter((t => t.startsWith("is")));
                    for (const e of t) {
                        if (!(e in n)) {
                            n[e] = o[e]
                        }
                    }
                }
            }
            delete n.inheritTypesFrom
        }

        function Up(t, e) {
            const n = t[e];
            const o = n.allowIn.filter((e => t[e]));
            n.allowIn = Array.from(new Set(o))
        }

        function Gp(t, e) {
            const n = t[e];
            n.allowAttributes = Array.from(new Set(n.allowAttributes))
        }

        function Kp(t, e) {
            for (const n of t) {
                const t = Object.keys(n).filter((t => t.startsWith("is")));
                for (const o of t) {
                    e[o] = n[o]
                }
            }
        }

        function Yp(t, e, n) {
            for (const o of t) {
                if (typeof o[n] == "string") {
                    e[n].push(o[n])
                } else if (Array.isArray(o[n])) {
                    e[n].push(...o[n])
                }
            }
        }

        function Hp(t, e) {
            for (const n of t) {
                const t = n.inheritAllFrom;
                if (t) {
                    e.allowContentOf.push(t);
                    e.allowWhere.push(t);
                    e.allowAttributesOf.push(t);
                    e.inheritTypesFrom.push(t)
                }
            }
        }

        function qp(t, e) {
            const n = t[e];
            return Wp(t).filter((t => t.allowIn.includes(n.name)))
        }

        function Wp(t) {
            return Object.keys(t).map((e => t[e]))
        }

        function Qp(t) {
            if (typeof t == "string") {
                return {
                    name: t,
                    * getAttributeKeys() {},
                    getAttribute() {}
                }
            } else {
                return {
                    name: t.is("element") ? t.name : "$text",
                    * getAttributeKeys() {
                        yield* t.getAttributeKeys()
                    },
                    getAttribute(e) {
                        return t.getAttribute(e)
                    }
                }
            }
        }

        function* $p(t, e) {
            let n = false;
            while (!n) {
                n = true;
                if (t) {
                    const e = t.next();
                    if (!e.done) {
                        n = false;
                        yield {
                            walker: t,
                            value: e.value
                        }
                    }
                }
                if (e) {
                    const t = e.next();
                    if (!t.done) {
                        n = false;
                        yield {
                            walker: e,
                            value: t.value
                        }
                    }
                }
            }
        }

        function* Zp(t) {
            for (const e of t) {
                yield* e.getMinimalFlatRanges()
            }
        }

        function Jp(t, e, n) {
            for (const o of e.getAttributeKeys()) {
                if (!t.checkAttribute(e, o)) {
                    n.removeAttribute(o, e)
                }
            }
        }
        class Xp {
            constructor(t = {}) {
                this._splitParts = new Map;
                this._cursorParents = new Map;
                this._modelCursor = null;
                this.conversionApi = Object.assign({}, t);
                this.conversionApi.convertItem = this._convertItem.bind(this);
                this.conversionApi.convertChildren = this._convertChildren.bind(this);
                this.conversionApi.safeInsert = this._safeInsert.bind(this);
                this.conversionApi.updateConversionResult = this._updateConversionResult.bind(this);
                this.conversionApi.splitToAllowedParent = this._splitToAllowedParent.bind(this);
                this.conversionApi.getSplitParts = this._getSplitParts.bind(this)
            }
            convert(t, e, n = ["$root"]) {
                this.fire("viewCleanup", t);
                this._modelCursor = em(n, e);
                this.conversionApi.writer = e;
                this.conversionApi.consumable = Pp.createFrom(t);
                this.conversionApi.store = {};
                const {
                    modelRange: o
                } = this._convertItem(t, this._modelCursor);
                const i = e.createDocumentFragment();
                if (o) {
                    this._removeEmptyElements();
                    for (const t of Array.from(this._modelCursor.parent.getChildren())) {
                        e.append(t, i)
                    }
                    i.markers = tm(i, e)
                }
                this._modelCursor = null;
                this._splitParts.clear();
                this._cursorParents.clear();
                this.conversionApi.writer = null;
                this.conversionApi.store = null;
                return i
            }
            _convertItem(t, e) {
                const n = Object.assign({
                    viewItem: t,
                    modelCursor: e,
                    modelRange: null
                });
                if (t.is("element")) {
                    this.fire("element:" + t.name, n, this.conversionApi)
                } else if (t.is("$text")) {
                    this.fire("text", n, this.conversionApi)
                } else {
                    this.fire("documentFragment", n, this.conversionApi)
                }
                if (n.modelRange && !(n.modelRange instanceof ef)) {
                    throw new ss["a"]("view-conversion-dispatcher-incorrect-result", this)
                }
                return {
                    modelRange: n.modelRange,
                    modelCursor: n.modelCursor
                }
            }
            _convertChildren(t, e) {
                let n = e.is("position") ? e : Zh._createAt(e, 0);
                const o = new ef(n);
                for (const e of Array.from(t.getChildren())) {
                    const t = this._convertItem(e, n);
                    if (t.modelRange instanceof ef) {
                        o.end = t.modelRange.end;
                        n = t.modelCursor
                    }
                }
                return {
                    modelRange: o,
                    modelCursor: n
                }
            }
            _safeInsert(t, e) {
                const n = this._splitToAllowedParent(t, e);
                if (!n) {
                    return false
                }
                this.conversionApi.writer.insert(t, n.position);
                return true
            }
            _updateConversionResult(t, e) {
                const n = this._getSplitParts(t);
                const o = this.conversionApi.writer;
                if (!e.modelRange) {
                    e.modelRange = o.createRange(o.createPositionBefore(t), o.createPositionAfter(n[n.length - 1]))
                }
                const i = this._cursorParents.get(t);
                if (i) {
                    e.modelCursor = o.createPositionAt(i, 0)
                } else {
                    e.modelCursor = e.modelRange.end
                }
            }
            _splitToAllowedParent(t, e) {
                const {
                    schema: n,
                    writer: o
                } = this.conversionApi;
                let i = n.findAllowedParent(e, t);
                if (i) {
                    if (i === e.parent) {
                        return {
                            position: e
                        }
                    }
                    if (this._modelCursor.parent.getAncestors().includes(i)) {
                        i = null
                    }
                }
                if (!i) {
                    if (!lp(e, t, n)) {
                        return null
                    }
                    return {
                        position: dp(e, o)
                    }
                }
                const r = this.conversionApi.writer.split(e, i);
                const s = [];
                for (const t of r.range.getWalker()) {
                    if (t.type == "elementEnd") {
                        s.push(t.item)
                    } else {
                        const e = s.pop();
                        const n = t.item;
                        this._registerSplitPair(e, n)
                    }
                }
                const a = r.range.end.parent;
                this._cursorParents.set(t, a);
                return {
                    position: r.position,
                    cursorParent: a
                }
            }
            _registerSplitPair(t, e) {
                if (!this._splitParts.has(t)) {
                    this._splitParts.set(t, [t])
                }
                const n = this._splitParts.get(t);
                this._splitParts.set(e, n);
                n.push(e)
            }
            _getSplitParts(t) {
                let e;
                if (!this._splitParts.has(t)) {
                    e = [t]
                } else {
                    e = this._splitParts.get(t)
                }
                return e
            }
            _removeEmptyElements() {
                let t = false;
                for (const e of this._splitParts.keys()) {
                    if (e.isEmpty) {
                        this.conversionApi.writer.remove(e);
                        this._splitParts.delete(e);
                        t = true
                    }
                }
                if (t) {
                    this._removeEmptyElements()
                }
            }
        }
        _s(Xp, ds);

        function tm(t, e) {
            const n = new Set;
            const o = new Map;
            const i = ef._createIn(t).getItems();
            for (const t of i) {
                if (t.name == "$marker") {
                    n.add(t)
                }
            }
            for (const t of n) {
                const n = t.getAttribute("data-name");
                const i = e.createPositionBefore(t);
                if (!o.has(n)) {
                    o.set(n, new ef(i.clone()))
                } else {
                    o.get(n).end = i.clone()
                }
                e.remove(t)
            }
            return o
        }

        function em(t, e) {
            let n;
            for (const o of new Op(t)) {
                const t = {};
                for (const e of o.getAttributeKeys()) {
                    t[e] = o.getAttribute(e)
                }
                const i = e.createElement(o.name, t);
                if (n) {
                    e.append(i, n)
                }
                n = Zh._createAt(i, 0)
            }
            return n
        }
        class nm {
            constructor(t, e) {
                this.model = t;
                this.stylesProcessor = e;
                this.processor = undefined;
                this.mapper = new nf;
                this.downcastDispatcher = new sf({
                    mapper: this.mapper,
                    schema: t.schema
                });
                this.downcastDispatcher.on("insert:$text", Nf(), {
                    priority: "lowest"
                });
                this.upcastDispatcher = new Xp({
                    schema: t.schema
                });
                this.viewDocument = new bl(e);
                this._viewWriter = new Xl(this.viewDocument);
                this.upcastDispatcher.on("text", fp(), {
                    priority: "lowest"
                });
                this.upcastDispatcher.on("element", hp(), {
                    priority: "lowest"
                });
                this.upcastDispatcher.on("documentFragment", hp(), {
                    priority: "lowest"
                });
                this.decorate("init");
                this.decorate("set");
                this.on("init", (() => {
                    this.fire("ready")
                }), {
                    priority: "lowest"
                });
                this.on("ready", (() => {
                    this.model.enqueueChange("transparent", cp)
                }), {
                    priority: "lowest"
                })
            }
            get(t = {}) {
                const {
                    rootName: e = "main",
                    trim: n = "empty"
                } = t;
                if (!this._checkIfRootsExists([e])) {
                    throw new ss["a"]("datacontroller-get-non-existent-root", this)
                }
                const o = this.model.document.getRoot(e);
                if (n === "empty" && !this.model.hasContent(o, {
                        ignoreWhitespaces: true
                    })) {
                    return ""
                }
                return this.stringify(o, t)
            }
            stringify(t, e) {
                const n = this.toView(t, e);
                return this.processor.toData(n)
            }
            toView(t, e) {
                const n = this.viewDocument;
                const o = this._viewWriter;
                this.mapper.clearBindings();
                const i = ef._createIn(t);
                const r = new Zl(n);
                this.mapper.bindElements(t, r);
                this.downcastDispatcher.conversionApi.options = e;
                this.downcastDispatcher.convertInsert(i, o);
                if (!t.is("documentFragment")) {
                    const e = om(t);
                    for (const [t, n] of e) {
                        this.downcastDispatcher.convertMarkerAdd(t, n, o)
                    }
                }
                delete this.downcastDispatcher.conversionApi.options;
                return r
            }
            init(t) {
                if (this.model.document.version) {
                    throw new ss["a"]("datacontroller-init-document-not-empty", this)
                }
                let e = {};
                if (typeof t === "string") {
                    e.main = t
                } else {
                    e = t
                }
                if (!this._checkIfRootsExists(Object.keys(e))) {
                    throw new ss["a"]("datacontroller-init-non-existent-root", this)
                }
                this.model.enqueueChange("transparent", (t => {
                    for (const n of Object.keys(e)) {
                        const o = this.model.document.getRoot(n);
                        t.insert(this.parse(e[n], o), o, 0)
                    }
                }));
                return Promise.resolve()
            }
            set(t) {
                let e = {};
                if (typeof t === "string") {
                    e.main = t
                } else {
                    e = t
                }
                if (!this._checkIfRootsExists(Object.keys(e))) {
                    throw new ss["a"]("datacontroller-set-non-existent-root", this)
                }
                this.model.enqueueChange("transparent", (t => {
                    t.setSelection(null);
                    t.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
                    for (const n of Object.keys(e)) {
                        const o = this.model.document.getRoot(n);
                        t.remove(t.createRangeIn(o));
                        t.insert(this.parse(e[n], o), o, 0)
                    }
                }))
            }
            parse(t, e = "$root") {
                const n = this.processor.toView(t);
                return this.toModel(n, e)
            }
            toModel(t, e = "$root") {
                return this.model.change((n => this.upcastDispatcher.convert(t, n, e)))
            }
            addStyleProcessorRules(t) {
                t(this.stylesProcessor)
            }
            destroy() {
                this.stopListening()
            }
            _checkIfRootsExists(t) {
                for (const e of t) {
                    if (!this.model.document.getRootNames().includes(e)) {
                        return false
                    }
                }
                return true
            }
        }
        _s(nm, Zc);

        function om(t) {
            const e = [];
            const n = t.root.document;
            if (!n) {
                return []
            }
            const o = ef._createIn(t);
            for (const t of n.model.markers) {
                const n = o.getIntersection(t.getRange());
                if (n) {
                    e.push([t.name, n])
                }
            }
            return e
        }
        class im {
            constructor(t, e) {
                this._helpers = new Map;
                this._downcast = xs(t);
                this._createConversionHelpers({
                    name: "downcast",
                    dispatchers: this._downcast,
                    isDowncast: true
                });
                this._upcast = xs(e);
                this._createConversionHelpers({
                    name: "upcast",
                    dispatchers: this._upcast,
                    isDowncast: false
                })
            }
            addAlias(t, e) {
                const n = this._downcast.includes(e);
                const o = this._upcast.includes(e);
                if (!o && !n) {
                    throw new ss["a"]("conversion-add-alias-dispatcher-not-registered", this)
                }
                this._createConversionHelpers({
                    name: t,
                    dispatchers: [e],
                    isDowncast: n
                })
            }
            for (t) {
                if (!this._helpers.has(t)) {
                    throw new ss["a"]("conversion-for-unknown-group", this)
                }
                return this._helpers.get(t)
            }
            elementToElement(t) {
                this.for("downcast").elementToElement(t);
                for (const {
                        model: e,
                        view: n
                    } of rm(t)) {
                    this.for("upcast").elementToElement({
                        model: e,
                        view: n,
                        converterPriority: t.converterPriority
                    })
                }
            }
            attributeToElement(t) {
                this.for("downcast").attributeToElement(t);
                for (const {
                        model: e,
                        view: n
                    } of rm(t)) {
                    this.for("upcast").elementToAttribute({
                        view: n,
                        model: e,
                        converterPriority: t.converterPriority
                    })
                }
            }
            attributeToAttribute(t) {
                this.for("downcast").attributeToAttribute(t);
                for (const {
                        model: e,
                        view: n
                    } of rm(t)) {
                    this.for("upcast").attributeToAttribute({
                        view: n,
                        model: e
                    })
                }
            }
            _createConversionHelpers({
                name: t,
                dispatchers: e,
                isDowncast: n
            }) {
                if (this._helpers.has(t)) {
                    throw new ss["a"]("conversion-group-exists", this)
                }
                const o = n ? new If(e) : new up(e);
                this._helpers.set(t, o)
            }
        }

        function* rm(t) {
            if (t.model.values) {
                for (const e of t.model.values) {
                    const n = {
                        key: t.model.key,
                        value: e
                    };
                    const o = t.view[e];
                    const i = t.upcastAlso ? t.upcastAlso[e] : undefined;
                    yield* sm(n, o, i)
                }
            } else {
                yield* sm(t.model, t.view, t.upcastAlso)
            }
        }

        function* sm(t, e, n) {
            yield {
                model: t,
                view: e
            };
            if (n) {
                for (const e of xs(n)) {
                    yield {
                        model: t,
                        view: e
                    }
                }
            }
        }
        class am {
            constructor(t = "default") {
                this.operations = [];
                this.type = t
            }
            get baseVersion() {
                for (const t of this.operations) {
                    if (t.baseVersion !== null) {
                        return t.baseVersion
                    }
                }
                return null
            }
            addOperation(t) {
                t.batch = this;
                this.operations.push(t);
                return t
            }
        }
        class cm {
            constructor(t) {
                this.baseVersion = t;
                this.isDocumentOperation = this.baseVersion !== null;
                this.batch = null
            }
            _validate() {}
            toJSON() {
                const t = Object.assign({}, this);
                t.__className = this.constructor.className;
                delete t.batch;
                delete t.isDocumentOperation;
                return t
            }
            static get className() {
                return "Operation"
            }
            static fromJSON(t) {
                return new this(t.baseVersion)
            }
        }
        class lm {
            constructor(t) {
                this.markers = new Map;
                this._children = new Hh;
                if (t) {
                    this._insertChild(0, t)
                }
            } [Symbol.iterator]() {
                return this.getChildren()
            }
            get childCount() {
                return this._children.length
            }
            get maxOffset() {
                return this._children.maxOffset
            }
            get isEmpty() {
                return this.childCount === 0
            }
            get root() {
                return this
            }
            get parent() {
                return null
            }
            is(t) {
                return t === "documentFragment" || t === "model:documentFragment"
            }
            getChild(t) {
                return this._children.getNode(t)
            }
            getChildren() {
                return this._children[Symbol.iterator]()
            }
            getChildIndex(t) {
                return this._children.getNodeIndex(t)
            }
            getChildStartOffset(t) {
                return this._children.getNodeStartOffset(t)
            }
            getPath() {
                return []
            }
            getNodeByPath(t) {
                let e = this;
                for (const n of t) {
                    e = e.getChild(e.offsetToIndex(n))
                }
                return e
            }
            offsetToIndex(t) {
                return this._children.offsetToIndex(t)
            }
            toJSON() {
                const t = [];
                for (const e of this._children) {
                    t.push(e.toJSON())
                }
                return t
            }
            static fromJSON(t) {
                const e = [];
                for (const n of t) {
                    if (n.name) {
                        e.push(qh.fromJSON(n))
                    } else {
                        e.push(Kh.fromJSON(n))
                    }
                }
                return new lm(e)
            }
            _appendChild(t) {
                this._insertChild(this.childCount, t)
            }
            _insertChild(t, e) {
                const n = dm(e);
                for (const t of n) {
                    if (t.parent !== null) {
                        t._remove()
                    }
                    t.parent = this
                }
                this._children._insertNodes(t, n)
            }
            _removeChildren(t, e = 1) {
                const n = this._children._removeNodes(t, e);
                for (const t of n) {
                    t.parent = null
                }
                return n
            }
        }

        function dm(t) {
            if (typeof t == "string") {
                return [new Kh(t)]
            }
            if (!Cs(t)) {
                t = [t]
            }
            return Array.from(t).map((t => {
                if (typeof t == "string") {
                    return new Kh(t)
                }
                if (t instanceof Yh) {
                    return new Kh(t.data, t.getAttributes())
                }
                return t
            }))
        }

        function um(t, e) {
            e = mm(e);
            const n = e.reduce(((t, e) => t + e.offsetSize), 0);
            const o = t.parent;
            km(t);
            const i = t.index;
            o._insertChild(i, e);
            gm(o, i + e.length);
            gm(o, i);
            return new ef(t, t.getShiftedBy(n))
        }

        function hm(t) {
            if (!t.isFlat) {
                throw new ss["a"]("operation-utils-remove-range-not-flat", this)
            }
            const e = t.start.parent;
            km(t.start);
            km(t.end);
            const n = e._removeChildren(t.start.index, t.end.index - t.start.index);
            gm(e, t.start.index);
            return n
        }

        function fm(t, e) {
            if (!t.isFlat) {
                throw new ss["a"]("operation-utils-move-range-not-flat", this)
            }
            const n = hm(t);
            e = e._getTransformedByDeletion(t.start, t.end.offset - t.start.offset);
            return um(e, n)
        }

        function pm(t, e, n) {
            km(t.start);
            km(t.end);
            for (const o of t.getItems({
                    shallow: true
                })) {
                const t = o.is("$textProxy") ? o.textNode : o;
                if (n !== null) {
                    t._setAttribute(e, n)
                } else {
                    t._removeAttribute(e)
                }
                gm(t.parent, t.index)
            }
            gm(t.end.parent, t.end.index)
        }

        function mm(t) {
            const e = [];
            if (!(t instanceof Array)) {
                t = [t]
            }
            for (let n = 0; n < t.length; n++) {
                if (typeof t[n] == "string") {
                    e.push(new Kh(t[n]))
                } else if (t[n] instanceof Yh) {
                    e.push(new Kh(t[n].data, t[n].getAttributes()))
                } else if (t[n] instanceof lm || t[n] instanceof Hh) {
                    for (const o of t[n]) {
                        e.push(o)
                    }
                } else if (t[n] instanceof Gh) {
                    e.push(t[n])
                }
            }
            for (let t = 1; t < e.length; t++) {
                const n = e[t];
                const o = e[t - 1];
                if (n instanceof Kh && o instanceof Kh && bm(n, o)) {
                    e.splice(t - 1, 2, new Kh(o.data + n.data, o.getAttributes()));
                    t--
                }
            }
            return e
        }

        function gm(t, e) {
            const n = t.getChild(e - 1);
            const o = t.getChild(e);
            if (n && o && n.is("$text") && o.is("$text") && bm(n, o)) {
                const i = new Kh(n.data + o.data, n.getAttributes());
                t._removeChildren(e - 1, 2);
                t._insertChild(e - 1, i)
            }
        }

        function km(t) {
            const e = t.textNode;
            const n = t.parent;
            if (e) {
                const o = t.offset - e.startOffset;
                const i = e.index;
                n._removeChildren(i, 1);
                const r = new Kh(e.data.substr(0, o), e.getAttributes());
                const s = new Kh(e.data.substr(o), e.getAttributes());
                n._insertChild(i, [r, s])
            }
        }

        function bm(t, e) {
            const n = t.getAttributes();
            const o = e.getAttributes();
            for (const t of n) {
                if (t[1] !== e.getAttribute(t[0])) {
                    return false
                }
                o.next()
            }
            return o.next().done
        }

        function wm(t, e) {
            return Zu(t, e)
        }
        var Am = wm;
        class Cm extends cm {
            constructor(t, e, n, o, i) {
                super(i);
                this.range = t.clone();
                this.key = e;
                this.oldValue = n === undefined ? null : n;
                this.newValue = o === undefined ? null : o
            }
            get type() {
                if (this.oldValue === null) {
                    return "addAttribute"
                } else if (this.newValue === null) {
                    return "removeAttribute"
                } else {
                    return "changeAttribute"
                }
            }
            clone() {
                return new Cm(this.range, this.key, this.oldValue, this.newValue, this.baseVersion)
            }
            getReversed() {
                return new Cm(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1)
            }
            toJSON() {
                const t = super.toJSON();
                t.range = this.range.toJSON();
                return t
            }
            _validate() {
                if (!this.range.isFlat) {
                    throw new ss["a"]("attribute-operation-range-not-flat", this)
                }
                for (const t of this.range.getItems({
                        shallow: true
                    })) {
                    if (this.oldValue !== null && !Am(t.getAttribute(this.key), this.oldValue)) {
                        throw new ss["a"]("attribute-operation-wrong-old-value", this, {
                            item: t,
                            key: this.key,
                            value: this.oldValue
                        })
                    }
                    if (this.oldValue === null && this.newValue !== null && t.hasAttribute(this.key)) {
                        throw new ss["a"]("attribute-operation-attribute-exists", this, {
                            node: t,
                            key: this.key
                        })
                    }
                }
            }
            _execute() {
                if (!Am(this.oldValue, this.newValue)) {
                    pm(this.range, this.key, this.newValue)
                }
            }
            static get className() {
                return "AttributeOperation"
            }
            static fromJSON(t, e) {
                return new Cm(ef.fromJSON(t.range, e), t.key, t.oldValue, t.newValue, t.baseVersion)
            }
        }
        class _m extends cm {
            constructor(t, e) {
                super(null);
                this.sourcePosition = t.clone();
                this.howMany = e
            }
            get type() {
                return "detach"
            }
            toJSON() {
                const t = super.toJSON();
                t.sourcePosition = this.sourcePosition.toJSON();
                return t
            }
            _validate() {
                if (this.sourcePosition.root.document) {
                    throw new ss["a"]("detach-operation-on-document-node", this)
                }
            }
            _execute() {
                hm(ef._createFromPositionAndShift(this.sourcePosition, this.howMany))
            }
            static get className() {
                return "DetachOperation"
            }
        }
        class vm extends cm {
            constructor(t, e, n, o) {
                super(o);
                this.sourcePosition = t.clone();
                this.sourcePosition.stickiness = "toNext";
                this.howMany = e;
                this.targetPosition = n.clone();
                this.targetPosition.stickiness = "toNone"
            }
            get type() {
                if (this.targetPosition.root.rootName == "$graveyard") {
                    return "remove"
                } else if (this.sourcePosition.root.rootName == "$graveyard") {
                    return "reinsert"
                }
                return "move"
            }
            clone() {
                return new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion)
            }
            getMovedRangeStart() {
                return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany)
            }
            getReversed() {
                const t = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
                return new this.constructor(this.getMovedRangeStart(), this.howMany, t, this.baseVersion + 1)
            }
            _validate() {
                const t = this.sourcePosition.parent;
                const e = this.targetPosition.parent;
                const n = this.sourcePosition.offset;
                const o = this.targetPosition.offset;
                if (n + this.howMany > t.maxOffset) {
                    throw new ss["a"]("move-operation-nodes-do-not-exist", this)
                } else if (t === e && n < o && o < n + this.howMany) {
                    throw new ss["a"]("move-operation-range-into-itself", this)
                } else if (this.sourcePosition.root == this.targetPosition.root) {
                    if (Os(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") {
                        const t = this.sourcePosition.path.length - 1;
                        if (this.targetPosition.path[t] >= n && this.targetPosition.path[t] < n + this.howMany) {
                            throw new ss["a"]("move-operation-node-into-itself", this)
                        }
                    }
                }
            }
            _execute() {
                fm(ef._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition)
            }
            toJSON() {
                const t = super.toJSON();
                t.sourcePosition = this.sourcePosition.toJSON();
                t.targetPosition = this.targetPosition.toJSON();
                return t
            }
            static get className() {
                return "MoveOperation"
            }
            static fromJSON(t, e) {
                const n = Zh.fromJSON(t.sourcePosition, e);
                const o = Zh.fromJSON(t.targetPosition, e);
                return new this(n, t.howMany, o, t.baseVersion)
            }
        }
        class ym extends cm {
            constructor(t, e, n) {
                super(n);
                this.position = t.clone();
                this.position.stickiness = "toNone";
                this.nodes = new Hh(mm(e));
                this.shouldReceiveAttributes = false
            }
            get type() {
                return "insert"
            }
            get howMany() {
                return this.nodes.maxOffset
            }
            clone() {
                const t = new Hh([...this.nodes].map((t => t._clone(true))));
                const e = new ym(this.position, t, this.baseVersion);
                e.shouldReceiveAttributes = this.shouldReceiveAttributes;
                return e
            }
            getReversed() {
                const t = this.position.root.document.graveyard;
                const e = new Zh(t, [0]);
                return new vm(this.position, this.nodes.maxOffset, e, this.baseVersion + 1)
            }
            _validate() {
                const t = this.position.parent;
                if (!t || t.maxOffset < this.position.offset) {
                    throw new ss["a"]("insert-operation-position-invalid", this)
                }
            }
            _execute() {
                const t = this.nodes;
                this.nodes = new Hh([...t].map((t => t._clone(true))));
                um(this.position, t)
            }
            toJSON() {
                const t = super.toJSON();
                t.position = this.position.toJSON();
                t.nodes = this.nodes.toJSON();
                return t
            }
            static get className() {
                return "InsertOperation"
            }
            static fromJSON(t, e) {
                const n = [];
                for (const e of t.nodes) {
                    if (e.name) {
                        n.push(qh.fromJSON(e))
                    } else {
                        n.push(Kh.fromJSON(e))
                    }
                }
                const o = new ym(Zh.fromJSON(t.position, e), n, t.baseVersion);
                o.shouldReceiveAttributes = t.shouldReceiveAttributes;
                return o
            }
        }
        class xm extends cm {
            constructor(t, e, n, o, i, r) {
                super(r);
                this.name = t;
                this.oldRange = e ? e.clone() : null;
                this.newRange = n ? n.clone() : null;
                this.affectsData = i;
                this._markers = o
            }
            get type() {
                return "marker"
            }
            clone() {
                return new xm(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion)
            }
            getReversed() {
                return new xm(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1)
            }
            _execute() {
                const t = this.newRange ? "_set" : "_remove";
                this._markers[t](this.name, this.newRange, true, this.affectsData)
            }
            toJSON() {
                const t = super.toJSON();
                if (this.oldRange) {
                    t.oldRange = this.oldRange.toJSON()
                }
                if (this.newRange) {
                    t.newRange = this.newRange.toJSON()
                }
                delete t._markers;
                return t
            }
            static get className() {
                return "MarkerOperation"
            }
            static fromJSON(t, e) {
                return new xm(t.name, t.oldRange ? ef.fromJSON(t.oldRange, e) : null, t.newRange ? ef.fromJSON(t.newRange, e) : null, e.model.markers, t.affectsData, t.baseVersion)
            }
        }
        class Dm extends cm {
            constructor(t, e, n, o) {
                super(o);
                this.position = t;
                this.position.stickiness = "toNext";
                this.oldName = e;
                this.newName = n
            }
            get type() {
                return "rename"
            }
            clone() {
                return new Dm(this.position.clone(), this.oldName, this.newName, this.baseVersion)
            }
            getReversed() {
                return new Dm(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1)
            }
            _validate() {
                const t = this.position.nodeAfter;
                if (!(t instanceof qh)) {
                    throw new ss["a"]("rename-operation-wrong-position", this)
                } else if (t.name !== this.oldName) {
                    throw new ss["a"]("rename-operation-wrong-name", this)
                }
            }
            _execute() {
                const t = this.position.nodeAfter;
                t.name = this.newName
            }
            toJSON() {
                const t = super.toJSON();
                t.position = this.position.toJSON();
                return t
            }
            static get className() {
                return "RenameOperation"
            }
            static fromJSON(t, e) {
                return new Dm(Zh.fromJSON(t.position, e), t.oldName, t.newName, t.baseVersion)
            }
        }
        class Mm extends cm {
            constructor(t, e, n, o, i) {
                super(i);
                this.root = t;
                this.key = e;
                this.oldValue = n;
                this.newValue = o
            }
            get type() {
                if (this.oldValue === null) {
                    return "addRootAttribute"
                } else if (this.newValue === null) {
                    return "removeRootAttribute"
                } else {
                    return "changeRootAttribute"
                }
            }
            clone() {
                return new Mm(this.root, this.key, this.oldValue, this.newValue, this.baseVersion)
            }
            getReversed() {
                return new Mm(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1)
            }
            _validate() {
                if (this.root != this.root.root || this.root.is("documentFragment")) {
                    throw new ss["a"]("rootattribute-operation-not-a-root", this, {
                        root: this.root,
                        key: this.key
                    })
                }
                if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) {
                    throw new ss["a"]("rootattribute-operation-wrong-old-value", this, {
                        root: this.root,
                        key: this.key
                    })
                }
                if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key)) {
                    throw new ss["a"]("rootattribute-operation-attribute-exists", this, {
                        root: this.root,
                        key: this.key
                    })
                }
            }
            _execute() {
                if (this.newValue !== null) {
                    this.root._setAttribute(this.key, this.newValue)
                } else {
                    this.root._removeAttribute(this.key)
                }
            }
            toJSON() {
                const t = super.toJSON();
                t.root = this.root.toJSON();
                return t
            }
            static get className() {
                return "RootAttributeOperation"
            }
            static fromJSON(t, e) {
                if (!e.getRoot(t.root)) {
                    throw new ss["a"]("rootattribute-operation-fromjson-no-root", this, {
                        rootName: t.root
                    })
                }
                return new Mm(e.getRoot(t.root), t.key, t.oldValue, t.newValue, t.baseVersion)
            }
        }
        class Em extends cm {
            constructor(t, e, n, o, i) {
                super(i);
                this.sourcePosition = t.clone();
                this.sourcePosition.stickiness = "toPrevious";
                this.howMany = e;
                this.targetPosition = n.clone();
                this.targetPosition.stickiness = "toNext";
                this.graveyardPosition = o.clone()
            }
            get type() {
                return "merge"
            }
            get deletionPosition() {
                return new Zh(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1))
            }
            get movedRange() {
                const t = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
                return new ef(this.sourcePosition, t)
            }
            clone() {
                return new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion)
            }
            getReversed() {
                const t = this.targetPosition._getTransformedByMergeOperation(this);
                const e = this.sourcePosition.path.slice(0, -1);
                const n = new Zh(this.sourcePosition.root, e)._getTransformedByMergeOperation(this);
                const o = new Sm(t, this.howMany, this.graveyardPosition, this.baseVersion + 1);
                o.insertionPosition = n;
                return o
            }
            _validate() {
                const t = this.sourcePosition.parent;
                const e = this.targetPosition.parent;
                if (!t.parent) {
                    throw new ss["a"]("merge-operation-source-position-invalid", this)
                } else if (!e.parent) {
                    throw new ss["a"]("merge-operation-target-position-invalid", this)
                } else if (this.howMany != t.maxOffset) {
                    throw new ss["a"]("merge-operation-how-many-invalid", this)
                }
            }
            _execute() {
                const t = this.sourcePosition.parent;
                const e = ef._createIn(t);
                fm(e, this.targetPosition);
                fm(ef._createOn(t), this.graveyardPosition)
            }
            toJSON() {
                const t = super.toJSON();
                t.sourcePosition = t.sourcePosition.toJSON();
                t.targetPosition = t.targetPosition.toJSON();
                t.graveyardPosition = t.graveyardPosition.toJSON();
                return t
            }
            static get className() {
                return "MergeOperation"
            }
            static fromJSON(t, e) {
                const n = Zh.fromJSON(t.sourcePosition, e);
                const o = Zh.fromJSON(t.targetPosition, e);
                const i = Zh.fromJSON(t.graveyardPosition, e);
                return new this(n, t.howMany, o, i, t.baseVersion)
            }
        }
        class Sm extends cm {
            constructor(t, e, n, o) {
                super(o);
                this.splitPosition = t.clone();
                this.splitPosition.stickiness = "toNext";
                this.howMany = e;
                this.insertionPosition = Sm.getInsertionPosition(t);
                this.insertionPosition.stickiness = "toNone";
                this.graveyardPosition = n ? n.clone() : null;
                if (this.graveyardPosition) {
                    this.graveyardPosition.stickiness = "toNext"
                }
            }
            get type() {
                return "split"
            }
            get moveTargetPosition() {
                const t = this.insertionPosition.path.slice();
                t.push(0);
                return new Zh(this.insertionPosition.root, t)
            }
            get movedRange() {
                const t = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
                return new ef(this.splitPosition, t)
            }
            clone() {
                const t = new this.constructor(this.splitPosition, this.howMany, this.graveyardPosition, this.baseVersion);
                t.insertionPosition = this.insertionPosition;
                return t
            }
            getReversed() {
                const t = this.splitPosition.root.document.graveyard;
                const e = new Zh(t, [0]);
                return new Em(this.moveTargetPosition, this.howMany, this.splitPosition, e, this.baseVersion + 1)
            }
            _validate() {
                const t = this.splitPosition.parent;
                const e = this.splitPosition.offset;
                if (!t || t.maxOffset < e) {
                    throw new ss["a"]("split-operation-position-invalid", this)
                } else if (!t.parent) {
                    throw new ss["a"]("split-operation-split-in-root", this)
                } else if (this.howMany != t.maxOffset - this.splitPosition.offset) {
                    throw new ss["a"]("split-operation-how-many-invalid", this)
                } else if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) {
                    throw new ss["a"]("split-operation-graveyard-position-invalid", this)
                }
            }
            _execute() {
                const t = this.splitPosition.parent;
                if (this.graveyardPosition) {
                    fm(ef._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition)
                } else {
                    const e = t._clone();
                    um(this.insertionPosition, e)
                }
                const e = new ef(Zh._createAt(t, this.splitPosition.offset), Zh._createAt(t, t.maxOffset));
                fm(e, this.moveTargetPosition)
            }
            toJSON() {
                const t = super.toJSON();
                t.splitPosition = this.splitPosition.toJSON();
                t.insertionPosition = this.insertionPosition.toJSON();
                if (this.graveyardPosition) {
                    t.graveyardPosition = this.graveyardPosition.toJSON()
                }
                return t
            }
            static get className() {
                return "SplitOperation"
            }
            static getInsertionPosition(t) {
                const e = t.path.slice(0, -1);
                e[e.length - 1]++;
                return new Zh(t.root, e)
            }
            static fromJSON(t, e) {
                const n = Zh.fromJSON(t.splitPosition, e);
                const o = Zh.fromJSON(t.insertionPosition, e);
                const i = t.graveyardPosition ? Zh.fromJSON(t.graveyardPosition, e) : null;
                const r = new this(n, t.howMany, i, t.baseVersion);
                r.insertionPosition = o;
                return r
            }
        }
        class Tm extends qh {
            constructor(t, e, n = "main") {
                super(e);
                this._document = t;
                this.rootName = n
            }
            get document() {
                return this._document
            }
            is(t, e) {
                if (!e) {
                    return t === "rootElement" || t === "model:rootElement" || t === "element" || t === "model:element" || t === "node" || t === "model:node"
                }
                return e === this.name && (t === "rootElement" || t === "model:rootElement" || t === "element" || t === "model:element")
            }
            toJSON() {
                return this.rootName
            }
        }
        class Im {
            constructor(t, e) {
                this.model = t;
                this.batch = e
            }
            createText(t, e) {
                return new Kh(t, e)
            }
            createElement(t, e) {
                return new qh(t, e)
            }
            createDocumentFragment() {
                return new lm
            }
            cloneElement(t, e = true) {
                return t._clone(e)
            }
            insert(t, e, n = 0) {
                this._assertWriterUsedCorrectly();
                if (t instanceof Kh && t.data == "") {
                    return
                }
                const o = Zh._createAt(e, n);
                if (t.parent) {
                    if (Om(t.root, o.root)) {
                        this.move(ef._createOn(t), o);
                        return
                    } else {
                        if (t.root.document) {
                            throw new ss["a"]("model-writer-insert-forbidden-move", this)
                        } else {
                            this.remove(t)
                        }
                    }
                }
                const i = o.root.document ? o.root.document.version : null;
                const r = new ym(o, t, i);
                if (t instanceof Kh) {
                    r.shouldReceiveAttributes = true
                }
                this.batch.addOperation(r);
                this.model.applyOperation(r);
                if (t instanceof lm) {
                    for (const [e, n] of t.markers) {
                        const t = Zh._createAt(n.root, 0);
                        const i = new ef(n.start._getCombined(t, o), n.end._getCombined(t, o));
                        const r = {
                            range: i,
                            usingOperation: true,
                            affectsData: true
                        };
                        if (this.model.markers.has(e)) {
                            this.updateMarker(e, r)
                        } else {
                            this.addMarker(e, r)
                        }
                    }
                }
            }
            insertText(t, e, n, o) {
                if (e instanceof lm || e instanceof qh || e instanceof Zh) {
                    this.insert(this.createText(t), e, n)
                } else {
                    this.insert(this.createText(t, e), n, o)
                }
            }
            insertElement(t, e, n, o) {
                if (e instanceof lm || e instanceof qh || e instanceof Zh) {
                    this.insert(this.createElement(t), e, n)
                } else {
                    this.insert(this.createElement(t, e), n, o)
                }
            }
            append(t, e) {
                this.insert(t, e, "end")
            }
            appendText(t, e, n) {
                if (e instanceof lm || e instanceof qh) {
                    this.insert(this.createText(t), e, "end")
                } else {
                    this.insert(this.createText(t, e), n, "end")
                }
            }
            appendElement(t, e, n) {
                if (e instanceof lm || e instanceof qh) {
                    this.insert(this.createElement(t), e, "end")
                } else {
                    this.insert(this.createElement(t, e), n, "end")
                }
            }
            setAttribute(t, e, n) {
                this._assertWriterUsedCorrectly();
                if (n instanceof ef) {
                    const o = n.getMinimalFlatRanges();
                    for (const n of o) {
                        Nm(this, t, e, n)
                    }
                } else {
                    Pm(this, t, e, n)
                }
            }
            setAttributes(t, e) {
                for (const [n, o] of Ks(t)) {
                    this.setAttribute(n, o, e)
                }
            }
            removeAttribute(t, e) {
                this._assertWriterUsedCorrectly();
                if (e instanceof ef) {
                    const n = e.getMinimalFlatRanges();
                    for (const e of n) {
                        Nm(this, t, null, e)
                    }
                } else {
                    Pm(this, t, null, e)
                }
            }
            clearAttributes(t) {
                this._assertWriterUsedCorrectly();
                const e = t => {
                    for (const e of t.getAttributeKeys()) {
                        this.removeAttribute(e, t)
                    }
                };
                if (!(t instanceof ef)) {
                    e(t)
                } else {
                    for (const n of t.getItems()) {
                        e(n)
                    }
                }
            }
            move(t, e, n) {
                this._assertWriterUsedCorrectly();
                if (!(t instanceof ef)) {
                    throw new ss["a"]("writer-move-invalid-range", this)
                }
                if (!t.isFlat) {
                    throw new ss["a"]("writer-move-range-not-flat", this)
                }
                const o = Zh._createAt(e, n);
                if (o.isEqual(t.start)) {
                    return
                }
                this._addOperationForAffectedMarkers("move", t);
                if (!Om(t.root, o.root)) {
                    throw new ss["a"]("writer-move-different-document", this)
                }
                const i = t.root.document ? t.root.document.version : null;
                const r = new vm(t.start, t.end.offset - t.start.offset, o, i);
                this.batch.addOperation(r);
                this.model.applyOperation(r)
            }
            remove(t) {
                this._assertWriterUsedCorrectly();
                const e = t instanceof ef ? t : ef._createOn(t);
                const n = e.getMinimalFlatRanges().reverse();
                for (const t of n) {
                    this._addOperationForAffectedMarkers("move", t);
                    Lm(t.start, t.end.offset - t.start.offset, this.batch, this.model)
                }
            }
            merge(t) {
                this._assertWriterUsedCorrectly();
                const e = t.nodeBefore;
                const n = t.nodeAfter;
                this._addOperationForAffectedMarkers("merge", t);
                if (!(e instanceof qh)) {
                    throw new ss["a"]("writer-merge-no-element-before", this)
                }
                if (!(n instanceof qh)) {
                    throw new ss["a"]("writer-merge-no-element-after", this)
                }
                if (!t.root.document) {
                    this._mergeDetached(t)
                } else {
                    this._merge(t)
                }
            }
            createPositionFromPath(t, e, n) {
                return this.model.createPositionFromPath(t, e, n)
            }
            createPositionAt(t, e) {
                return this.model.createPositionAt(t, e)
            }
            createPositionAfter(t) {
                return this.model.createPositionAfter(t)
            }
            createPositionBefore(t) {
                return this.model.createPositionBefore(t)
            }
            createRange(t, e) {
                return this.model.createRange(t, e)
            }
            createRangeIn(t) {
                return this.model.createRangeIn(t)
            }
            createRangeOn(t) {
                return this.model.createRangeOn(t)
            }
            createSelection(t, e, n) {
                return this.model.createSelection(t, e, n)
            }
            _mergeDetached(t) {
                const e = t.nodeBefore;
                const n = t.nodeAfter;
                this.move(ef._createIn(n), Zh._createAt(e, "end"));
                this.remove(n)
            }
            _merge(t) {
                const e = Zh._createAt(t.nodeBefore, "end");
                const n = Zh._createAt(t.nodeAfter, 0);
                const o = t.root.document.graveyard;
                const i = new Zh(o, [0]);
                const r = t.root.document.version;
                const s = new Em(n, t.nodeAfter.maxOffset, e, i, r);
                this.batch.addOperation(s);
                this.model.applyOperation(s)
            }
            rename(t, e) {
                this._assertWriterUsedCorrectly();
                if (!(t instanceof qh)) {
                    throw new ss["a"]("writer-rename-not-element-instance", this)
                }
                const n = t.root.document ? t.root.document.version : null;
                const o = new Dm(Zh._createBefore(t), t.name, e, n);
                this.batch.addOperation(o);
                this.model.applyOperation(o)
            }
            split(t, e) {
                this._assertWriterUsedCorrectly();
                let n = t.parent;
                if (!n.parent) {
                    throw new ss["a"]("writer-split-element-no-parent", this)
                }
                if (!e) {
                    e = n.parent
                }
                if (!t.parent.getAncestors({
                        includeSelf: true
                    }).includes(e)) {
                    throw new ss["a"]("writer-split-invalid-limit-element", this)
                }
                let o, i;
                do {
                    const e = n.root.document ? n.root.document.version : null;
                    const r = n.maxOffset - t.offset;
                    const s = new Sm(t, r, null, e);
                    this.batch.addOperation(s);
                    this.model.applyOperation(s);
                    if (!o && !i) {
                        o = n;
                        i = t.parent.nextSibling
                    }
                    t = this.createPositionAfter(t.parent);
                    n = t.parent
                } while (n !== e);
                return {
                    position: t,
                    range: new ef(Zh._createAt(o, "end"), Zh._createAt(i, 0))
                }
            }
            wrap(t, e) {
                this._assertWriterUsedCorrectly();
                if (!t.isFlat) {
                    throw new ss["a"]("writer-wrap-range-not-flat", this)
                }
                const n = e instanceof qh ? e : new qh(e);
                if (n.childCount > 0) {
                    throw new ss["a"]("writer-wrap-element-not-empty", this)
                }
                if (n.parent !== null) {
                    throw new ss["a"]("writer-wrap-element-attached", this)
                }
                this.insert(n, t.start);
                const o = new ef(t.start.getShiftedBy(1), t.end.getShiftedBy(1));
                this.move(o, Zh._createAt(n, 0))
            }
            unwrap(t) {
                this._assertWriterUsedCorrectly();
                if (t.parent === null) {
                    throw new ss["a"]("writer-unwrap-element-no-parent", this)
                }
                this.move(ef._createIn(t), this.createPositionAfter(t));
                this.remove(t)
            }
            addMarker(t, e) {
                this._assertWriterUsedCorrectly();
                if (!e || typeof e.usingOperation != "boolean") {
                    throw new ss["a"]("writer-addmarker-no-usingoperation", this)
                }
                const n = e.usingOperation;
                const o = e.range;
                const i = e.affectsData === undefined ? false : e.affectsData;
                if (this.model.markers.has(t)) {
                    throw new ss["a"]("writer-addmarker-marker-exists", this)
                }
                if (!o) {
                    throw new ss["a"]("writer-addmarker-no-range", this)
                }
                if (!n) {
                    return this.model.markers._set(t, o, n, i)
                }
                Bm(this, t, null, o, i);
                return this.model.markers.get(t)
            }
            updateMarker(t, e) {
                this._assertWriterUsedCorrectly();
                const n = typeof t == "string" ? t : t.name;
                const o = this.model.markers.get(n);
                if (!o) {
                    throw new ss["a"]("writer-updatemarker-marker-not-exists", this)
                }
                if (!e) {
                    this.model.markers._refresh(o);
                    return
                }
                const i = typeof e.usingOperation == "boolean";
                const r = typeof e.affectsData == "boolean";
                const s = r ? e.affectsData : o.affectsData;
                if (!i && !e.range && !r) {
                    throw new ss["a"]("writer-updatemarker-wrong-options", this)
                }
                const a = o.getRange();
                const c = e.range ? e.range : a;
                if (i && e.usingOperation !== o.managedUsingOperations) {
                    if (e.usingOperation) {
                        Bm(this, n, null, c, s)
                    } else {
                        Bm(this, n, a, null, s);
                        this.model.markers._set(n, c, undefined, s)
                    }
                    return
                }
                if (o.managedUsingOperations) {
                    Bm(this, n, a, c, s)
                } else {
                    this.model.markers._set(n, c, undefined, s)
                }
            }
            removeMarker(t) {
                this._assertWriterUsedCorrectly();
                const e = typeof t == "string" ? t : t.name;
                if (!this.model.markers.has(e)) {
                    throw new ss["a"]("writer-removemarker-no-marker", this)
                }
                const n = this.model.markers.get(e);
                if (!n.managedUsingOperations) {
                    this.model.markers._remove(e);
                    return
                }
                const o = n.getRange();
                Bm(this, e, o, null, n.affectsData)
            }
            setSelection(t, e, n) {
                this._assertWriterUsedCorrectly();
                this.model.document.selection._setTo(t, e, n)
            }
            setSelectionFocus(t, e) {
                this._assertWriterUsedCorrectly();
                this.model.document.selection._setFocus(t, e)
            }
            setSelectionAttribute(t, e) {
                this._assertWriterUsedCorrectly();
                if (typeof t === "string") {
                    this._setSelectionAttribute(t, e)
                } else {
                    for (const [e, n] of Ks(t)) {
                        this._setSelectionAttribute(e, n)
                    }
                }
            }
            removeSelectionAttribute(t) {
                this._assertWriterUsedCorrectly();
                if (typeof t === "string") {
                    this._removeSelectionAttribute(t)
                } else {
                    for (const e of t) {
                        this._removeSelectionAttribute(e)
                    }
                }
            }
            overrideSelectionGravity() {
                return this.model.document.selection._overrideGravity()
            }
            restoreSelectionGravity(t) {
                this.model.document.selection._restoreGravity(t)
            }
            _setSelectionAttribute(t, e) {
                const n = this.model.document.selection;
                if (n.isCollapsed && n.anchor.parent.isEmpty) {
                    const o = _f._getStoreAttributeKey(t);
                    this.setAttribute(o, e, n.anchor.parent)
                }
                n._setAttribute(t, e)
            }
            _removeSelectionAttribute(t) {
                const e = this.model.document.selection;
                if (e.isCollapsed && e.anchor.parent.isEmpty) {
                    const n = _f._getStoreAttributeKey(t);
                    this.removeAttribute(n, e.anchor.parent)
                }
                e._removeAttribute(t)
            }
            _assertWriterUsedCorrectly() {
                if (this.model._currentWriter !== this) {
                    throw new ss["a"]("writer-incorrect-use", this)
                }
            }
            _addOperationForAffectedMarkers(t, e) {
                for (const n of this.model.markers) {
                    if (!n.managedUsingOperations) {
                        continue
                    }
                    const o = n.getRange();
                    let i = false;
                    if (t === "move") {
                        i = e.containsPosition(o.start) || e.start.isEqual(o.start) || e.containsPosition(o.end) || e.end.isEqual(o.end)
                    } else {
                        const t = e.nodeBefore;
                        const n = e.nodeAfter;
                        const r = o.start.parent == t && o.start.isAtEnd;
                        const s = o.end.parent == n && o.end.offset == 0;
                        const a = o.end.nodeAfter == n;
                        const c = o.start.nodeAfter == n;
                        i = r || s || a || c
                    }
                    if (i) {
                        this.updateMarker(n.name, {
                            range: o
                        })
                    }
                }
            }
        }

        function Nm(t, e, n, o) {
            const i = t.model;
            const r = i.document;
            let s = o.start;
            let a;
            let c;
            let l;
            for (const t of o.getWalker({
                    shallow: true
                })) {
                l = t.item.getAttribute(e);
                if (a && c != l) {
                    if (c != n) {
                        d()
                    }
                    s = a
                }
                a = t.nextPosition;
                c = l
            }
            if (a instanceof Zh && a != s && c != n) {
                d()
            }

            function d() {
                const o = new ef(s, a);
                const l = o.root.document ? r.version : null;
                const d = new Cm(o, e, c, n, l);
                t.batch.addOperation(d);
                i.applyOperation(d)
            }
        }

        function Pm(t, e, n, o) {
            const i = t.model;
            const r = i.document;
            const s = o.getAttribute(e);
            let a, c;
            if (s != n) {
                const l = o.root === o;
                if (l) {
                    const t = o.document ? r.version : null;
                    c = new Mm(o, e, s, n, t)
                } else {
                    a = new ef(Zh._createBefore(o), t.createPositionAfter(o));
                    const i = a.root.document ? r.version : null;
                    c = new Cm(a, e, s, n, i)
                }
                t.batch.addOperation(c);
                i.applyOperation(c)
            }
        }

        function Bm(t, e, n, o, i) {
            const r = t.model;
            const s = r.document;
            const a = new xm(e, n, o, r.markers, i, s.version);
            t.batch.addOperation(a);
            r.applyOperation(a)
        }

        function Lm(t, e, n, o) {
            let i;
            if (t.root.document) {
                const n = o.document;
                const r = new Zh(n.graveyard, [0]);
                i = new vm(t, e, r, n.version)
            } else {
                i = new _m(t, e)
            }
            n.addOperation(i);
            o.applyOperation(i)
        }

        function Om(t, e) {
            if (t === e) {
                return true
            }
            if (t instanceof Tm && e instanceof Tm) {
                return true
            }
            return false
        }
        class zm {
            constructor(t) {
                this._markerCollection = t;
                this._changesInElement = new Map;
                this._elementSnapshots = new Map;
                this._changedMarkers = new Map;
                this._changeCount = 0;
                this._cachedChanges = null;
                this._cachedChangesWithGraveyard = null
            }
            get isEmpty() {
                return this._changesInElement.size == 0 && this._changedMarkers.size == 0
            }
            refreshItem(t) {
                if (this._isInInsertedElement(t.parent)) {
                    return
                }
                this._markRemove(t.parent, t.startOffset, t.offsetSize);
                this._markInsert(t.parent, t.startOffset, t.offsetSize);
                const e = ef._createOn(t);
                for (const t of this._markerCollection.getMarkersIntersectingRange(e)) {
                    const e = t.getRange();
                    this.bufferMarkerChange(t.name, e, e, t.affectsData)
                }
                this._cachedChanges = null
            }
            bufferOperation(t) {
                switch (t.type) {
                    case "insert": {
                        if (this._isInInsertedElement(t.position.parent)) {
                            return
                        }
                        this._markInsert(t.position.parent, t.position.offset, t.nodes.maxOffset);
                        break
                    }
                    case "addAttribute":
                    case "removeAttribute":
                    case "changeAttribute": {
                        for (const e of t.range.getItems({
                                shallow: true
                            })) {
                            if (this._isInInsertedElement(e.parent)) {
                                continue
                            }
                            this._markAttribute(e)
                        }
                        break
                    }
                    case "remove":
                    case "move":
                    case "reinsert": {
                        if (t.sourcePosition.isEqual(t.targetPosition) || t.sourcePosition.getShiftedBy(t.howMany).isEqual(t.targetPosition)) {
                            return
                        }
                        const e = this._isInInsertedElement(t.sourcePosition.parent);
                        const n = this._isInInsertedElement(t.targetPosition.parent);
                        if (!e) {
                            this._markRemove(t.sourcePosition.parent, t.sourcePosition.offset, t.howMany)
                        }
                        if (!n) {
                            this._markInsert(t.targetPosition.parent, t.getMovedRangeStart().offset, t.howMany)
                        }
                        break
                    }
                    case "rename": {
                        if (this._isInInsertedElement(t.position.parent)) {
                            return
                        }
                        this._markRemove(t.position.parent, t.position.offset, 1);
                        this._markInsert(t.position.parent, t.position.offset, 1);
                        const e = ef._createFromPositionAndShift(t.position, 1);
                        for (const t of this._markerCollection.getMarkersIntersectingRange(e)) {
                            const e = t.getRange();
                            this.bufferMarkerChange(t.name, e, e, t.affectsData)
                        }
                        break
                    }
                    case "split": {
                        const e = t.splitPosition.parent;
                        if (!this._isInInsertedElement(e)) {
                            this._markRemove(e, t.splitPosition.offset, t.howMany)
                        }
                        if (!this._isInInsertedElement(t.insertionPosition.parent)) {
                            this._markInsert(t.insertionPosition.parent, t.insertionPosition.offset, 1)
                        }
                        if (t.graveyardPosition) {
                            this._markRemove(t.graveyardPosition.parent, t.graveyardPosition.offset, 1)
                        }
                        break
                    }
                    case "merge": {
                        const e = t.sourcePosition.parent;
                        if (!this._isInInsertedElement(e.parent)) {
                            this._markRemove(e.parent, e.startOffset, 1)
                        }
                        const n = t.graveyardPosition.parent;
                        this._markInsert(n, t.graveyardPosition.offset, 1);
                        const o = t.targetPosition.parent;
                        if (!this._isInInsertedElement(o)) {
                            this._markInsert(o, t.targetPosition.offset, e.maxOffset)
                        }
                        break
                    }
                }
                this._cachedChanges = null
            }
            bufferMarkerChange(t, e, n, o) {
                const i = this._changedMarkers.get(t);
                if (!i) {
                    this._changedMarkers.set(t, {
                        oldRange: e,
                        newRange: n,
                        affectsData: o
                    })
                } else {
                    i.newRange = n;
                    i.affectsData = o;
                    if (i.oldRange == null && i.newRange == null) {
                        this._changedMarkers.delete(t)
                    }
                }
            }
            getMarkersToRemove() {
                const t = [];
                for (const [e, n] of this._changedMarkers) {
                    if (n.oldRange != null) {
                        t.push({
                            name: e,
                            range: n.oldRange
                        })
                    }
                }
                return t
            }
            getMarkersToAdd() {
                const t = [];
                for (const [e, n] of this._changedMarkers) {
                    if (n.newRange != null) {
                        t.push({
                            name: e,
                            range: n.newRange
                        })
                    }
                }
                return t
            }
            getChangedMarkers() {
                return Array.from(this._changedMarkers).map((t => ({
                    name: t[0],
                    data: {
                        oldRange: t[1].oldRange,
                        newRange: t[1].newRange
                    }
                })))
            }
            hasDataChanges() {
                for (const [, t] of this._changedMarkers) {
                    if (t.affectsData) {
                        return true
                    }
                }
                return this._changesInElement.size > 0
            }
            getChanges(t = {
                includeChangesInGraveyard: false
            }) {
                if (this._cachedChanges) {
                    if (t.includeChangesInGraveyard) {
                        return this._cachedChangesWithGraveyard.slice()
                    } else {
                        return this._cachedChanges.slice()
                    }
                }
                const e = [];
                for (const t of this._changesInElement.keys()) {
                    const n = this._changesInElement.get(t).sort(((t, e) => {
                        if (t.offset === e.offset) {
                            if (t.type != e.type) {
                                return t.type == "remove" ? -1 : 1
                            }
                            return 0
                        }
                        return t.offset < e.offset ? -1 : 1
                    }));
                    const o = this._elementSnapshots.get(t);
                    const i = jm(t.getChildren());
                    const r = Fm(o.length, n);
                    let s = 0;
                    let a = 0;
                    for (const n of r) {
                        if (n === "i") {
                            e.push(this._getInsertDiff(t, s, i[s].name));
                            s++
                        } else if (n === "r") {
                            e.push(this._getRemoveDiff(t, s, o[a].name));
                            a++
                        } else if (n === "a") {
                            const n = i[s].attributes;
                            const r = o[a].attributes;
                            let c;
                            if (i[s].name == "$text") {
                                c = new ef(Zh._createAt(t, s), Zh._createAt(t, s + 1))
                            } else {
                                const e = t.offsetToIndex(s);
                                c = new ef(Zh._createAt(t, s), Zh._createAt(t.getChild(e), 0))
                            }
                            e.push(...this._getAttributesDiff(c, r, n));
                            s++;
                            a++
                        } else {
                            s++;
                            a++
                        }
                    }
                }
                e.sort(((t, e) => {
                    if (t.position.root != e.position.root) {
                        return t.position.root.rootName < e.position.root.rootName ? -1 : 1
                    }
                    if (t.position.isEqual(e.position)) {
                        return t.changeCount - e.changeCount
                    }
                    return t.position.isBefore(e.position) ? -1 : 1
                }));
                for (let t = 1; t < e.length; t++) {
                    const n = e[t - 1];
                    const o = e[t];
                    const i = n.type == "remove" && o.type == "remove" && n.name == "$text" && o.name == "$text" && n.position.isEqual(o.position);
                    const r = n.type == "insert" && o.type == "insert" && n.name == "$text" && o.name == "$text" && n.position.parent == o.position.parent && n.position.offset + n.length == o.position.offset;
                    const s = n.type == "attribute" && o.type == "attribute" && n.position.parent == o.position.parent && n.range.isFlat && o.range.isFlat && n.position.offset + n.length == o.position.offset && n.attributeKey == o.attributeKey && n.attributeOldValue == o.attributeOldValue && n.attributeNewValue == o.attributeNewValue;
                    if (i || r || s) {
                        e[t - 1].length++;
                        if (s) {
                            e[t - 1].range.end = e[t - 1].range.end.getShiftedBy(1)
                        }
                        e.splice(t, 1);
                        t--
                    }
                }
                for (const t of e) {
                    delete t.changeCount;
                    if (t.type == "attribute") {
                        delete t.position;
                        delete t.length
                    }
                }
                this._changeCount = 0;
                this._cachedChangesWithGraveyard = e.slice();
                this._cachedChanges = e.slice().filter(Rm);
                if (t.includeChangesInGraveyard) {
                    return this._cachedChangesWithGraveyard
                } else {
                    return this._cachedChanges
                }
            }
            reset() {
                this._changesInElement.clear();
                this._elementSnapshots.clear();
                this._changedMarkers.clear();
                this._cachedChanges = null
            }
            _markInsert(t, e, n) {
                const o = {
                    type: "insert",
                    offset: e,
                    howMany: n,
                    count: this._changeCount++
                };
                this._markChange(t, o)
            }
            _markRemove(t, e, n) {
                const o = {
                    type: "remove",
                    offset: e,
                    howMany: n,
                    count: this._changeCount++
                };
                this._markChange(t, o);
                this._removeAllNestedChanges(t, e, n)
            }
            _markAttribute(t) {
                const e = {
                    type: "attribute",
                    offset: t.startOffset,
                    howMany: t.offsetSize,
                    count: this._changeCount++
                };
                this._markChange(t.parent, e)
            }
            _markChange(t, e) {
                this._makeSnapshot(t);
                const n = this._getChangesForElement(t);
                this._handleChange(e, n);
                n.push(e);
                for (let t = 0; t < n.length; t++) {
                    if (n[t].howMany < 1) {
                        n.splice(t, 1);
                        t--
                    }
                }
            }
            _getChangesForElement(t) {
                let e;
                if (this._changesInElement.has(t)) {
                    e = this._changesInElement.get(t)
                } else {
                    e = [];
                    this._changesInElement.set(t, e)
                }
                return e
            }
            _makeSnapshot(t) {
                if (!this._elementSnapshots.has(t)) {
                    this._elementSnapshots.set(t, jm(t.getChildren()))
                }
            }
            _handleChange(t, e) {
                t.nodesToHandle = t.howMany;
                for (const n of e) {
                    const o = t.offset + t.howMany;
                    const i = n.offset + n.howMany;
                    if (t.type == "insert") {
                        if (n.type == "insert") {
                            if (t.offset <= n.offset) {
                                n.offset += t.howMany
                            } else if (t.offset < i) {
                                n.howMany += t.nodesToHandle;
                                t.nodesToHandle = 0
                            }
                        }
                        if (n.type == "remove") {
                            if (t.offset < n.offset) {
                                n.offset += t.howMany
                            }
                        }
                        if (n.type == "attribute") {
                            if (t.offset <= n.offset) {
                                n.offset += t.howMany
                            } else if (t.offset < i) {
                                const i = n.howMany;
                                n.howMany = t.offset - n.offset;
                                e.unshift({
                                    type: "attribute",
                                    offset: o,
                                    howMany: i - n.howMany,
                                    count: this._changeCount++
                                })
                            }
                        }
                    }
                    if (t.type == "remove") {
                        if (n.type == "insert") {
                            if (o <= n.offset) {
                                n.offset -= t.howMany
                            } else if (o <= i) {
                                if (t.offset < n.offset) {
                                    const e = o - n.offset;
                                    n.offset = t.offset;
                                    n.howMany -= e;
                                    t.nodesToHandle -= e
                                } else {
                                    n.howMany -= t.nodesToHandle;
                                    t.nodesToHandle = 0
                                }
                            } else {
                                if (t.offset <= n.offset) {
                                    t.nodesToHandle -= n.howMany;
                                    n.howMany = 0
                                } else if (t.offset < i) {
                                    const e = i - t.offset;
                                    n.howMany -= e;
                                    t.nodesToHandle -= e
                                }
                            }
                        }
                        if (n.type == "remove") {
                            if (o <= n.offset) {
                                n.offset -= t.howMany
                            } else if (t.offset < n.offset) {
                                t.nodesToHandle += n.howMany;
                                n.howMany = 0
                            }
                        }
                        if (n.type == "attribute") {
                            if (o <= n.offset) {
                                n.offset -= t.howMany
                            } else if (t.offset < n.offset) {
                                const e = o - n.offset;
                                n.offset = t.offset;
                                n.howMany -= e
                            } else if (t.offset < i) {
                                if (o <= i) {
                                    const o = n.howMany;
                                    n.howMany = t.offset - n.offset;
                                    const i = o - n.howMany - t.nodesToHandle;
                                    e.unshift({
                                        type: "attribute",
                                        offset: t.offset,
                                        howMany: i,
                                        count: this._changeCount++
                                    })
                                } else {
                                    n.howMany -= i - t.offset
                                }
                            }
                        }
                    }
                    if (t.type == "attribute") {
                        if (n.type == "insert") {
                            if (t.offset < n.offset && o > n.offset) {
                                if (o > i) {
                                    const t = {
                                        type: "attribute",
                                        offset: i,
                                        howMany: o - i,
                                        count: this._changeCount++
                                    };
                                    this._handleChange(t, e);
                                    e.push(t)
                                }
                                t.nodesToHandle = n.offset - t.offset;
                                t.howMany = t.nodesToHandle
                            } else if (t.offset >= n.offset && t.offset < i) {
                                if (o > i) {
                                    t.nodesToHandle = o - i;
                                    t.offset = i
                                } else {
                                    t.nodesToHandle = 0
                                }
                            }
                        }
                        if (n.type == "remove") {
                            if (t.offset < n.offset && o > n.offset) {
                                const i = {
                                    type: "attribute",
                                    offset: n.offset,
                                    howMany: o - n.offset,
                                    count: this._changeCount++
                                };
                                this._handleChange(i, e);
                                e.push(i);
                                t.nodesToHandle = n.offset - t.offset;
                                t.howMany = t.nodesToHandle
                            }
                        }
                        if (n.type == "attribute") {
                            if (t.offset >= n.offset && o <= i) {
                                t.nodesToHandle = 0;
                                t.howMany = 0;
                                t.offset = 0
                            } else if (t.offset <= n.offset && o >= i) {
                                n.howMany = 0
                            }
                        }
                    }
                }
                t.howMany = t.nodesToHandle;
                delete t.nodesToHandle
            }
            _getInsertDiff(t, e, n) {
                return {
                    type: "insert",
                    position: Zh._createAt(t, e),
                    name: n,
                    length: 1,
                    changeCount: this._changeCount++
                }
            }
            _getRemoveDiff(t, e, n) {
                return {
                    type: "remove",
                    position: Zh._createAt(t, e),
                    name: n,
                    length: 1,
                    changeCount: this._changeCount++
                }
            }
            _getAttributesDiff(t, e, n) {
                const o = [];
                n = new Map(n);
                for (const [i, r] of e) {
                    const e = n.has(i) ? n.get(i) : null;
                    if (e !== r) {
                        o.push({
                            type: "attribute",
                            position: t.start,
                            range: t.clone(),
                            length: 1,
                            attributeKey: i,
                            attributeOldValue: r,
                            attributeNewValue: e,
                            changeCount: this._changeCount++
                        })
                    }
                    n.delete(i)
                }
                for (const [e, i] of n) {
                    o.push({
                        type: "attribute",
                        position: t.start,
                        range: t.clone(),
                        length: 1,
                        attributeKey: e,
                        attributeOldValue: null,
                        attributeNewValue: i,
                        changeCount: this._changeCount++
                    })
                }
                return o
            }
            _isInInsertedElement(t) {
                const e = t.parent;
                if (!e) {
                    return false
                }
                const n = this._changesInElement.get(e);
                const o = t.startOffset;
                if (n) {
                    for (const t of n) {
                        if (t.type == "insert" && o >= t.offset && o < t.offset + t.howMany) {
                            return true
                        }
                    }
                }
                return this._isInInsertedElement(e)
            }
            _removeAllNestedChanges(t, e, n) {
                const o = new ef(Zh._createAt(t, e), Zh._createAt(t, e + n));
                for (const t of o.getItems({
                        shallow: true
                    })) {
                    if (t.is("element")) {
                        this._elementSnapshots.delete(t);
                        this._changesInElement.delete(t);
                        this._removeAllNestedChanges(t, 0, t.maxOffset)
                    }
                }
            }
        }

        function jm(t) {
            const e = [];
            for (const n of t) {
                if (n.is("$text")) {
                    for (let t = 0; t < n.data.length; t++) {
                        e.push({
                            name: "$text",
                            attributes: new Map(n.getAttributes())
                        })
                    }
                } else {
                    e.push({
                        name: n.name,
                        attributes: new Map(n.getAttributes())
                    })
                }
            }
            return e
        }

        function Fm(t, e) {
            const n = [];
            let o = 0;
            let i = 0;
            for (const t of e) {
                if (t.offset > o) {
                    for (let e = 0; e < t.offset - o; e++) {
                        n.push("e")
                    }
                    i += t.offset - o
                }
                if (t.type == "insert") {
                    for (let e = 0; e < t.howMany; e++) {
                        n.push("i")
                    }
                    o = t.offset + t.howMany
                } else if (t.type == "remove") {
                    for (let e = 0; e < t.howMany; e++) {
                        n.push("r")
                    }
                    o = t.offset;
                    i += t.howMany
                } else {
                    n.push(..."a".repeat(t.howMany).split(""));
                    o = t.offset + t.howMany;
                    i += t.howMany
                }
            }
            if (i < t) {
                for (let e = 0; e < t - i - o; e++) {
                    n.push("e")
                }
            }
            return n
        }

        function Rm(t) {
            const e = t.position && t.position.root.rootName == "$graveyard";
            const n = t.range && t.range.root.rootName == "$graveyard";
            return !e && !n
        }
        class Vm {
            constructor() {
                this._operations = [];
                this._undoPairs = new Map;
                this._undoneOperations = new Set
            }
            addOperation(t) {
                if (this._operations.includes(t)) {
                    return
                }
                this._operations.push(t)
            }
            getOperations(t = Number.NEGATIVE_INFINITY, e = Number.POSITIVE_INFINITY) {
                const n = [];
                for (const o of this._operations) {
                    if (o.baseVersion >= t && o.baseVersion < e) {
                        n.push(o)
                    }
                }
                return n
            }
            getOperation(t) {
                for (const e of this._operations) {
                    if (e.baseVersion == t) {
                        return e
                    }
                }
            }
            setOperationAsUndone(t, e) {
                this._undoPairs.set(e, t);
                this._undoneOperations.add(t)
            }
            isUndoingOperation(t) {
                return this._undoPairs.has(t)
            }
            isUndoneOperation(t) {
                return this._undoneOperations.has(t)
            }
            getUndoneOperation(t) {
                return this._undoPairs.get(t)
            }
        }

        function Um(t) {
            return !!t && t.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(t)
        }

        function Gm(t) {
            return !!t && t.length == 1 && /[\ud800-\udbff]/.test(t)
        }

        function Km(t) {
            return !!t && t.length == 1 && /[\udc00-\udfff]/.test(t)
        }

        function Ym(t, e) {
            return Gm(t.charAt(e - 1)) && Km(t.charAt(e))
        }

        function Hm(t, e) {
            return Um(t.charAt(e))
        }
        const qm = "$graveyard";
        class Wm {
            constructor(t) {
                this.model = t;
                this.version = 0;
                this.history = new Vm(this);
                this.selection = new _f(this);
                this.roots = new vs({
                    idProperty: "rootName"
                });
                this.differ = new zm(t.markers);
                this._postFixers = new Set;
                this._hasSelectionChangedFromTheLastChangeBlock = false;
                this.createRoot("$root", qm);
                this.listenTo(t, "applyOperation", ((t, e) => {
                    const n = e[0];
                    if (n.isDocumentOperation && n.baseVersion !== this.version) {
                        throw new ss["a"]("model-document-applyoperation-wrong-version", this, {
                            operation: n
                        })
                    }
                }), {
                    priority: "highest"
                });
                this.listenTo(t, "applyOperation", ((t, e) => {
                    const n = e[0];
                    if (n.isDocumentOperation) {
                        this.differ.bufferOperation(n)
                    }
                }), {
                    priority: "high"
                });
                this.listenTo(t, "applyOperation", ((t, e) => {
                    const n = e[0];
                    if (n.isDocumentOperation) {
                        this.version++;
                        this.history.addOperation(n)
                    }
                }), {
                    priority: "low"
                });
                this.listenTo(this.selection, "change", (() => {
                    this._hasSelectionChangedFromTheLastChangeBlock = true
                }));
                this.listenTo(t.markers, "update", ((t, e, n, o) => {
                    this.differ.bufferMarkerChange(e.name, n, o, e.affectsData);
                    if (n === null) {
                        e.on("change", ((t, n) => {
                            this.differ.bufferMarkerChange(e.name, n, e.getRange(), e.affectsData)
                        }))
                    }
                }))
            }
            get graveyard() {
                return this.getRoot(qm)
            }
            createRoot(t = "$root", e = "main") {
                if (this.roots.get(e)) {
                    throw new ss["a"]("model-document-createroot-name-exists", this, {
                        name: e
                    })
                }
                const n = new Tm(this, t, e);
                this.roots.add(n);
                return n
            }
            destroy() {
                this.selection.destroy();
                this.stopListening()
            }
            getRoot(t = "main") {
                return this.roots.get(t)
            }
            getRootNames() {
                return Array.from(this.roots, (t => t.rootName)).filter((t => t != qm))
            }
            registerPostFixer(t) {
                this._postFixers.add(t)
            }
            toJSON() {
                const t = Fs(this);
                t.selection = "[engine.model.DocumentSelection]";
                t.model = "[engine.model.Model]";
                return t
            }
            _handleChangeBlock(t) {
                if (this._hasDocumentChangedFromTheLastChangeBlock()) {
                    this._callPostFixers(t);
                    this.selection.refresh();
                    if (this.differ.hasDataChanges()) {
                        this.fire("change:data", t.batch)
                    } else {
                        this.fire("change", t.batch)
                    }
                    this.selection.refresh();
                    this.differ.reset()
                }
                this._hasSelectionChangedFromTheLastChangeBlock = false
            }
            _hasDocumentChangedFromTheLastChangeBlock() {
                return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock
            }
            _getDefaultRoot() {
                for (const t of this.roots) {
                    if (t !== this.graveyard) {
                        return t
                    }
                }
                return this.graveyard
            }
            _getDefaultRange() {
                const t = this._getDefaultRoot();
                const e = this.model;
                const n = e.schema;
                const o = e.createPositionFromPath(t, [0]);
                const i = n.getNearestSelectionRange(o);
                return i || e.createRange(o)
            }
            _validateSelectionRange(t) {
                return Qm(t.start) && Qm(t.end)
            }
            _callPostFixers(t) {
                let e = false;
                do {
                    for (const n of this._postFixers) {
                        this.selection.refresh();
                        e = n(t);
                        if (e) {
                            break
                        }
                    }
                } while (e)
            }
        }
        _s(Wm, ds);

        function Qm(t) {
            const e = t.textNode;
            if (e) {
                const n = e.data;
                const o = t.offset - e.startOffset;
                return !Ym(n, o) && !Hm(n, o)
            }
            return true
        }
        class $m {
            constructor() {
                this._markers = new Map
            } [Symbol.iterator]() {
                return this._markers.values()
            }
            has(t) {
                return this._markers.has(t)
            }
            get(t) {
                return this._markers.get(t) || null
            }
            _set(t, e, n = false, o = false) {
                const i = t instanceof Zm ? t.name : t;
                if (i.includes(",")) {
                    throw new ss["a"]("markercollection-incorrect-marker-name", this)
                }
                const r = this._markers.get(i);
                if (r) {
                    const t = r.getRange();
                    let s = false;
                    if (!t.isEqual(e)) {
                        r._attachLiveRange(kf.fromRange(e));
                        s = true
                    }
                    if (n != r.managedUsingOperations) {
                        r._managedUsingOperations = n;
                        s = true
                    }
                    if (typeof o === "boolean" && o != r.affectsData) {
                        r._affectsData = o;
                        s = true
                    }
                    if (s) {
                        this.fire("update:" + i, r, t, e)
                    }
                    return r
                }
                const s = kf.fromRange(e);
                const a = new Zm(i, s, n, o);
                this._markers.set(i, a);
                this.fire("update:" + i, a, null, e);
                return a
            }
            _remove(t) {
                const e = t instanceof Zm ? t.name : t;
                const n = this._markers.get(e);
                if (n) {
                    this._markers.delete(e);
                    this.fire("update:" + e, n, n.getRange(), null);
                    this._destroyMarker(n);
                    return true
                }
                return false
            }
            _refresh(t) {
                const e = t instanceof Zm ? t.name : t;
                const n = this._markers.get(e);
                if (!n) {
                    throw new ss["a"]("markercollection-refresh-marker-not-exists", this)
                }
                const o = n.getRange();
                this.fire("update:" + e, n, o, o, n.managedUsingOperations, n.affectsData)
            }* getMarkersAtPosition(t) {
                for (const e of this) {
                    if (e.getRange().containsPosition(t)) {
                        yield e
                    }
                }
            }* getMarkersIntersectingRange(t) {
                for (const e of this) {
                    if (e.getRange().getIntersection(t) !== null) {
                        yield e
                    }
                }
            }
            destroy() {
                for (const t of this._markers.values()) {
                    this._destroyMarker(t)
                }
                this._markers = null;
                this.stopListening()
            }* getMarkersGroup(t) {
                for (const e of this._markers.values()) {
                    if (e.name.startsWith(t + ":")) {
                        yield e
                    }
                }
            }
            _destroyMarker(t) {
                t.stopListening();
                t._detachLiveRange()
            }
        }
        _s($m, ds);
        class Zm {
            constructor(t, e, n, o) {
                this.name = t;
                this._liveRange = this._attachLiveRange(e);
                this._managedUsingOperations = n;
                this._affectsData = o
            }
            get managedUsingOperations() {
                if (!this._liveRange) {
                    throw new ss["a"]("marker-destroyed", this)
                }
                return this._managedUsingOperations
            }
            get affectsData() {
                if (!this._liveRange) {
                    throw new ss["a"]("marker-destroyed", this)
                }
                return this._affectsData
            }
            getStart() {
                if (!this._liveRange) {
                    throw new ss["a"]("marker-destroyed", this)
                }
                return this._liveRange.start.clone()
            }
            getEnd() {
                if (!this._liveRange) {
                    throw new ss["a"]("marker-destroyed", this)
                }
                return this._liveRange.end.clone()
            }
            getRange() {
                if (!this._liveRange) {
                    throw new ss["a"]("marker-destroyed", this)
                }
                return this._liveRange.toRange()
            }
            is(t) {
                return t === "marker" || t === "model:marker"
            }
            _attachLiveRange(t) {
                if (this._liveRange) {
                    this._detachLiveRange()
                }
                t.delegate("change:range").to(this);
                t.delegate("change:content").to(this);
                this._liveRange = t;
                return t
            }
            _detachLiveRange() {
                this._liveRange.stopDelegating("change:range", this);
                this._liveRange.stopDelegating("change:content", this);
                this._liveRange.detach();
                this._liveRange = null
            }
        }
        _s(Zm, ds);
        class Jm extends cm {
            get type() {
                return "noop"
            }
            clone() {
                return new Jm(this.baseVersion)
            }
            getReversed() {
                return new Jm(this.baseVersion + 1)
            }
            _execute() {}
            static get className() {
                return "NoOperation"
            }
        }
        const Xm = {};
        Xm[Cm.className] = Cm;
        Xm[ym.className] = ym;
        Xm[xm.className] = xm;
        Xm[vm.className] = vm;
        Xm[Jm.className] = Jm;
        Xm[cm.className] = cm;
        Xm[Dm.className] = Dm;
        Xm[Mm.className] = Mm;
        Xm[Sm.className] = Sm;
        Xm[Em.className] = Em;
        class tg {
            static fromJSON(t, e) {
                return Xm[t.__className].fromJSON(t, e)
            }
        }
        class eg extends Zh {
            constructor(t, e, n = "toNone") {
                super(t, e, n);
                if (!this.root.is("rootElement")) {
                    throw new ss["a"]("model-liveposition-root-not-rootelement", t)
                }
                ng.call(this)
            }
            detach() {
                this.stopListening()
            }
            is(t) {
                return t === "livePosition" || t === "model:livePosition" || t == "position" || t === "model:position"
            }
            toPosition() {
                return new Zh(this.root, this.path.slice(), this.stickiness)
            }
            static fromPosition(t, e) {
                return new this(t.root, t.path.slice(), e ? e : t.stickiness)
            }
        }

        function ng() {
            this.listenTo(this.root.document.model, "applyOperation", ((t, e) => {
                const n = e[0];
                if (!n.isDocumentOperation) {
                    return
                }
                og.call(this, n)
            }), {
                priority: "low"
            })
        }

        function og(t) {
            const e = this.getTransformedByOperation(t);
            if (!this.isEqual(e)) {
                const t = this.toPosition();
                this.path = e.path;
                this.root = e.root;
                this.fire("change", t)
            }
        }
        _s(eg, ds);

        function ig(t, e, n, o) {
            return t.change((i => {
                let r;
                if (!n) {
                    r = t.document.selection
                } else if (n instanceof uf || n instanceof _f) {
                    r = n
                } else {
                    r = i.createSelection(n, o)
                }
                if (!r.isCollapsed) {
                    t.deleteContent(r, {
                        doNotAutoparagraph: true
                    })
                }
                const s = new rg(t, i, r.anchor);
                let a;
                if (e.is("documentFragment")) {
                    a = e.getChildren()
                } else {
                    a = [e]
                }
                s.handleNodes(a, {
                    isFirst: true,
                    isLast: true
                });
                const c = s.getSelectionRange();
                if (c) {
                    if (r instanceof _f) {
                        i.setSelection(c)
                    } else {
                        r.setTo(c)
                    }
                } else {}
                const l = s.getAffectedRange() || t.createRange(r.anchor);
                s.destroy();
                return l
            }))
        }
        class rg {
            constructor(t, e, n) {
                this.model = t;
                this.writer = e;
                this.position = n;
                this.canMergeWith = new Set([this.position.parent]);
                this.schema = t.schema;
                this._filterAttributesOf = [];
                this._affectedStart = null;
                this._affectedEnd = null
            }
            handleNodes(t, e) {
                t = Array.from(t);
                for (let n = 0; n < t.length; n++) {
                    const o = t[n];
                    this._handleNode(o, {
                        isFirst: n === 0 && e.isFirst,
                        isLast: n === t.length - 1 && e.isLast
                    })
                }
                this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer);
                this._filterAttributesOf = []
            }
            getSelectionRange() {
                if (this.nodeToSelect) {
                    return ef._createOn(this.nodeToSelect)
                }
                return this.model.schema.getNearestSelectionRange(this.position)
            }
            getAffectedRange() {
                if (!this._affectedStart) {
                    return null
                }
                return new ef(this._affectedStart, this._affectedEnd)
            }
            destroy() {
                if (this._affectedStart) {
                    this._affectedStart.detach()
                }
                if (this._affectedEnd) {
                    this._affectedEnd.detach()
                }
            }
            _handleNode(t, e) {
                if (this.schema.isObject(t)) {
                    this._handleObject(t, e);
                    return
                }
                const n = this._checkAndSplitToAllowedPosition(t, e);
                if (!n) {
                    this._handleDisallowedNode(t, e);
                    return
                }
                this._insert(t);
                this._mergeSiblingsOf(t, e)
            }
            _handleObject(t, e) {
                if (this._checkAndSplitToAllowedPosition(t)) {
                    this._insert(t)
                } else {
                    this._tryAutoparagraphing(t, e)
                }
            }
            _handleDisallowedNode(t, e) {
                if (t.is("element")) {
                    this.handleNodes(t.getChildren(), e)
                } else {
                    this._tryAutoparagraphing(t, e)
                }
            }
            _insert(t) {
                if (!this.schema.checkChild(this.position, t)) {
                    throw new ss["a"]("insertcontent-wrong-position", this, {
                        node: t,
                        position: this.position
                    })
                }
                const e = eg.fromPosition(this.position, "toNext");
                this._setAffectedBoundaries(this.position);
                this.writer.insert(t, this.position);
                this.position = e.toPosition();
                e.detach();
                if (this.schema.isObject(t) && !this.schema.checkChild(this.position, "$text")) {
                    this.nodeToSelect = t
                } else {
                    this.nodeToSelect = null
                }
                this._filterAttributesOf.push(t)
            }
            _setAffectedBoundaries(t) {
                if (!this._affectedStart) {
                    this._affectedStart = eg.fromPosition(t, "toPrevious")
                }
                if (!this._affectedEnd || this._affectedEnd.isBefore(t)) {
                    if (this._affectedEnd) {
                        this._affectedEnd.detach()
                    }
                    this._affectedEnd = eg.fromPosition(t, "toNext")
                }
            }
            _mergeSiblingsOf(t, e) {
                if (!(t instanceof qh)) {
                    return
                }
                const n = this._canMergeLeft(t, e);
                const o = this._canMergeRight(t, e);
                const i = eg._createBefore(t);
                i.stickiness = "toNext";
                const r = eg._createAfter(t);
                r.stickiness = "toNext";
                if (n) {
                    const t = eg.fromPosition(this.position);
                    t.stickiness = "toNext";
                    if (this._affectedStart.isEqual(i)) {
                        this._affectedStart.detach();
                        this._affectedStart = eg._createAt(i.nodeBefore, "end", "toPrevious")
                    }
                    this.writer.merge(i);
                    if (i.isEqual(this._affectedEnd) && e.isLast) {
                        this._affectedEnd.detach();
                        this._affectedEnd = eg._createAt(i.nodeBefore, "end", "toNext")
                    }
                    this.position = t.toPosition();
                    t.detach()
                }
                if (o) {
                    if (!this.position.isEqual(r)) {
                        throw new ss["a"]("insertcontent-invalid-insertion-position", this)
                    }
                    this.position = Zh._createAt(r.nodeBefore, "end");
                    const t = eg.fromPosition(this.position, "toPrevious");
                    if (this._affectedEnd.isEqual(r)) {
                        this._affectedEnd.detach();
                        this._affectedEnd = eg._createAt(r.nodeBefore, "end", "toNext")
                    }
                    this.writer.merge(r);
                    if (r.getShiftedBy(-1).isEqual(this._affectedStart) && e.isFirst) {
                        this._affectedStart.detach();
                        this._affectedStart = eg._createAt(r.nodeBefore, 0, "toPrevious")
                    }
                    this.position = t.toPosition();
                    t.detach()
                }
                if (n || o) {
                    this._filterAttributesOf.push(this.position.parent)
                }
                i.detach();
                r.detach()
            }
            _canMergeLeft(t, e) {
                const n = t.previousSibling;
                return e.isFirst && n instanceof qh && this.canMergeWith.has(n) && this.model.schema.checkMerge(n, t)
            }
            _canMergeRight(t, e) {
                const n = t.nextSibling;
                return e.isLast && n instanceof qh && this.canMergeWith.has(n) && this.model.schema.checkMerge(t, n)
            }
            _tryAutoparagraphing(t, e) {
                const n = this.writer.createElement("paragraph");
                if (this._getAllowedIn(n, this.position.parent) && this.schema.checkChild(n, t)) {
                    n._appendChild(t);
                    this._handleNode(n, e)
                }
            }
            _checkAndSplitToAllowedPosition(t) {
                const e = this._getAllowedIn(t, this.position.parent);
                if (!e) {
                    return false
                }
                while (e != this.position.parent) {
                    if (this.schema.isLimit(this.position.parent)) {
                        return false
                    }
                    if (this.position.isAtStart) {
                        const t = this.position.parent;
                        this.position = this.writer.createPositionBefore(t);
                        if (t.isEmpty && t.parent === e) {
                            this.writer.remove(t)
                        }
                    } else if (this.position.isAtEnd) {
                        this.position = this.writer.createPositionAfter(this.position.parent)
                    } else {
                        const t = this.writer.createPositionAfter(this.position.parent);
                        this._setAffectedBoundaries(this.position);
                        this.writer.split(this.position);
                        this.position = t;
                        this.canMergeWith.add(this.position.nodeAfter)
                    }
                }
                return true
            }
            _getAllowedIn(t, e) {
                if (this.schema.checkChild(e, t)) {
                    return e
                }
                if (e.parent) {
                    return this._getAllowedIn(t, e.parent)
                }
                return null
            }
        }

        function sg(t, e, n = {}) {
            if (e.isCollapsed) {
                return
            }
            const o = e.getFirstRange();
            if (o.root.rootName == "$graveyard") {
                return
            }
            const i = t.schema;
            t.change((t => {
                if (!n.doNotResetEntireContent && wg(i, e)) {
                    bg(t, e, i);
                    return
                }
                const [r, s] = ag(o);
                if (!r.isTouching(s)) {
                    t.remove(t.createRange(r, s))
                }
                if (!n.leaveUnmerged) {
                    lg(t, r, s);
                    i.removeDisallowedAttributes(r.parent.getChildren(), t)
                }
                Ag(t, e, r);
                if (!n.doNotAutoparagraph && mg(i, r)) {
                    kg(t, r, e)
                }
                r.detach();
                s.detach()
            }))
        }

        function ag(t) {
            const e = t.root.document.model;
            const n = t.start;
            let o = t.end;
            if (e.hasContent(t, {
                    ignoreMarkers: true
                })) {
                const n = cg(o);
                if (n && o.isTouching(e.createPositionAt(n, 0))) {
                    const n = e.createSelection(t);
                    e.modifySelection(n, {
                        direction: "backward"
                    });
                    o = n.getLastPosition()
                }
            }
            return [eg.fromPosition(n, "toPrevious"), eg.fromPosition(o, "toNext")]
        }

        function cg(t) {
            const e = t.parent;
            const n = e.root.document.model.schema;
            const o = e.getAncestors({
                parentFirst: true,
                includeSelf: true
            });
            for (const t of o) {
                if (n.isLimit(t)) {
                    return null
                }
                if (n.isBlock(t)) {
                    return t
                }
            }
        }

        function lg(t, e, n) {
            const o = t.model;
            if (!fg(t.model.schema, e, n)) {
                return
            }
            const [i, r] = pg(e, n);
            if (!i || !r) {
                return
            }
            if (!o.hasContent(i, {
                    ignoreMarkers: true
                }) && o.hasContent(r, {
                    ignoreMarkers: true
                })) {
                ug(t, e, n, i.parent)
            } else {
                dg(t, e, n, i.parent)
            }
        }

        function dg(t, e, n, o) {
            const i = e.parent;
            const r = n.parent;
            if (i == o || r == o) {
                return
            }
            e = t.createPositionAfter(i);
            n = t.createPositionBefore(r);
            if (!n.isEqual(e)) {
                t.insert(r, e)
            }
            t.merge(e);
            while (n.parent.isEmpty) {
                const e = n.parent;
                n = t.createPositionBefore(e);
                t.remove(e)
            }
            if (!fg(t.model.schema, e, n)) {
                return
            }
            dg(t, e, n, o)
        }

        function ug(t, e, n, o) {
            const i = e.parent;
            const r = n.parent;
            if (i == o || r == o) {
                return
            }
            e = t.createPositionAfter(i);
            n = t.createPositionBefore(r);
            if (!n.isEqual(e)) {
                t.insert(i, n)
            }
            while (e.parent.isEmpty) {
                const n = e.parent;
                e = t.createPositionBefore(n);
                t.remove(n)
            }
            n = t.createPositionBefore(r);
            hg(t, n);
            if (!fg(t.model.schema, e, n)) {
                return
            }
            ug(t, e, n, o)
        }

        function hg(t, e) {
            const n = e.nodeBefore;
            const o = e.nodeAfter;
            if (n.name != o.name) {
                t.rename(n, o.name)
            }
            t.clearAttributes(n);
            t.setAttributes(Object.fromEntries(o.getAttributes()), n);
            t.merge(e)
        }

        function fg(t, e, n) {
            const o = e.parent;
            const i = n.parent;
            if (o == i) {
                return false
            }
            if (t.isLimit(o) || t.isLimit(i)) {
                return false
            }
            return gg(e, n, t)
        }

        function pg(t, e) {
            const n = t.getAncestors();
            const o = e.getAncestors();
            let i = 0;
            while (n[i] && n[i] == o[i]) {
                i++
            }
            return [n[i], o[i]]
        }

        function mg(t, e) {
            const n = t.checkChild(e, "$text");
            const o = t.checkChild(e, "paragraph");
            return !n && o
        }

        function gg(t, e, n) {
            const o = new ef(t, e);
            for (const t of o.getWalker()) {
                if (n.isLimit(t.item)) {
                    return false
                }
            }
            return true
        }

        function kg(t, e, n) {
            const o = t.createElement("paragraph");
            t.insert(o, e);
            Ag(t, n, t.createPositionAt(o, 0))
        }

        function bg(t, e) {
            const n = t.model.schema.getLimitElement(e);
            t.remove(t.createRangeIn(n));
            kg(t, t.createPositionAt(n, 0), e)
        }

        function wg(t, e) {
            const n = t.getLimitElement(e);
            if (!e.containsEntireContent(n)) {
                return false
            }
            const o = e.getFirstRange();
            if (o.start.parent == o.end.parent) {
                return false
            }
            return t.checkChild(n, "paragraph")
        }

        function Ag(t, e, n) {
            if (e instanceof _f) {
                t.setSelection(n)
            } else {
                e.setTo(n)
            }
        }
        const Cg = ' ,.?!:;"-()';

        function _g(t, e, n = {}) {
            const o = t.schema;
            const i = n.direction != "backward";
            const r = n.unit ? n.unit : "character";
            const s = e.focus;
            const a = new Qh({
                boundaries: Dg(s, i),
                singleCharacters: true,
                direction: i ? "forward" : "backward"
            });
            const c = {
                walker: a,
                schema: o,
                isForward: i,
                unit: r
            };
            let l;
            while (l = a.next()) {
                if (l.done) {
                    return
                }
                const n = vg(c, l.value);
                if (n) {
                    if (e instanceof _f) {
                        t.change((t => {
                            t.setSelectionFocus(n)
                        }))
                    } else {
                        e.setFocus(n)
                    }
                    return
                }
            }
        }

        function vg(t, e) {
            const {
                isForward: n,
                walker: o,
                unit: i,
                schema: r
            } = t;
            const {
                type: s,
                item: a,
                nextPosition: c
            } = e;
            if (s == "text") {
                if (t.unit === "word") {
                    return xg(o, n)
                }
                return yg(o, i, n)
            }
            if (s == (n ? "elementStart" : "elementEnd")) {
                if (r.isSelectable(a)) {
                    return Zh._createAt(a, n ? "after" : "before")
                }
                if (r.checkChild(c, "$text")) {
                    return c
                }
            } else {
                if (r.isLimit(a)) {
                    o.skip((() => true));
                    return
                }
                if (r.checkChild(c, "$text")) {
                    return c
                }
            }
        }

        function yg(t, e) {
            const n = t.position.textNode;
            if (n) {
                const o = n.data;
                let i = t.position.offset - n.startOffset;
                while (Ym(o, i) || e == "character" && Hm(o, i)) {
                    t.next();
                    i = t.position.offset - n.startOffset
                }
            }
            return t.position
        }

        function xg(t, e) {
            let n = t.position.textNode;
            if (n) {
                let o = t.position.offset - n.startOffset;
                while (!Mg(n.data, o, e) && !Eg(n, o, e)) {
                    t.next();
                    const i = e ? t.position.nodeAfter : t.position.nodeBefore;
                    if (i && i.is("$text")) {
                        const o = i.data.charAt(e ? 0 : i.data.length - 1);
                        if (!Cg.includes(o)) {
                            t.next();
                            n = t.position.textNode
                        }
                    }
                    o = t.position.offset - n.startOffset
                }
            }
            return t.position
        }

        function Dg(t, e) {
            const n = t.root;
            const o = Zh._createAt(n, e ? "end" : 0);
            if (e) {
                return new ef(t, o)
            } else {
                return new ef(o, t)
            }
        }

        function Mg(t, e, n) {
            const o = e + (n ? 0 : -1);
            return Cg.includes(t.charAt(o))
        }

        function Eg(t, e, n) {
            return e === (n ? t.endOffset : 0)
        }

        function Sg(t, e) {
            return t.change((t => {
                const n = t.createDocumentFragment();
                const o = e.getFirstRange();
                if (!o || o.isCollapsed) {
                    return n
                }
                const i = o.start.root;
                const r = o.start.getCommonPath(o.end);
                const s = i.getNodeByPath(r);
                let a;
                if (o.start.parent == o.end.parent) {
                    a = o
                } else {
                    a = t.createRange(t.createPositionAt(s, o.start.path[r.length]), t.createPositionAt(s, o.end.path[r.length] + 1))
                }
                const c = a.end.offset - a.start.offset;
                for (const e of a.getItems({
                        shallow: true
                    })) {
                    if (e.is("$textProxy")) {
                        t.appendText(e.data, e.getAttributes(), n)
                    } else {
                        t.append(t.cloneElement(e, true), n)
                    }
                }
                if (a != o) {
                    const e = o._getTransformedByMove(a.start, t.createPositionAt(n, 0), c)[0];
                    const i = t.createRange(t.createPositionAt(n, 0), e.start);
                    const r = t.createRange(e.end, t.createPositionAt(n, "end"));
                    Tg(r, t);
                    Tg(i, t)
                }
                return n
            }))
        }

        function Tg(t, e) {
            const n = [];
            Array.from(t.getItems({
                direction: "backward"
            })).map((t => e.createRangeOn(t))).filter((e => {
                const n = (e.start.isAfter(t.start) || e.start.isEqual(t.start)) && (e.end.isBefore(t.end) || e.end.isEqual(t.end));
                return n
            })).forEach((t => {
                n.push(t.start.parent);
                e.remove(t)
            }));
            n.forEach((t => {
                let n = t;
                while (n.parent && n.isEmpty) {
                    const t = e.createRangeOn(n);
                    n = n.parent;
                    e.remove(t)
                }
            }))
        }

        function Ig(t) {
            t.document.registerPostFixer((e => Ng(e, t)))
        }

        function Ng(t, e) {
            const n = e.document.selection;
            const o = e.schema;
            const i = [];
            let r = false;
            for (const t of n.getRanges()) {
                const e = Pg(t, o);
                if (e && !e.isEqual(t)) {
                    i.push(e);
                    r = true
                } else {
                    i.push(t)
                }
            }
            if (r) {
                t.setSelection(jg(i), {
                    backward: n.isBackward
                })
            }
        }

        function Pg(t, e) {
            if (t.isCollapsed) {
                return Bg(t, e)
            }
            return Lg(t, e)
        }

        function Bg(t, e) {
            const n = t.start;
            const o = e.getNearestSelectionRange(n);
            if (!o) {
                return null
            }
            if (!o.isCollapsed) {
                return o
            }
            const i = o.start;
            if (n.isEqual(i)) {
                return null
            }
            return new ef(i)
        }

        function Lg(t, e) {
            const {
                start: n,
                end: o
            } = t;
            const i = e.checkChild(n, "$text");
            const r = e.checkChild(o, "$text");
            const s = e.getLimitElement(n);
            const a = e.getLimitElement(o);
            if (s === a) {
                if (i && r) {
                    return null
                }
                if (zg(n, o, e)) {
                    const t = n.nodeAfter && e.isSelectable(n.nodeAfter);
                    const i = t ? null : e.getNearestSelectionRange(n, "forward");
                    const r = o.nodeBefore && e.isSelectable(o.nodeBefore);
                    const s = r ? null : e.getNearestSelectionRange(o, "backward");
                    const a = i ? i.start : n;
                    const c = s ? s.end : o;
                    return new ef(a, c)
                }
            }
            const c = s && !s.is("rootElement");
            const l = a && !a.is("rootElement");
            if (c || l) {
                const t = n.nodeAfter && o.nodeBefore && n.nodeAfter.parent === o.nodeBefore.parent;
                const i = c && (!t || !Fg(n.nodeAfter, e));
                const r = l && (!t || !Fg(o.nodeBefore, e));
                let d = n;
                let u = o;
                if (i) {
                    d = Zh._createBefore(Og(s, e))
                }
                if (r) {
                    u = Zh._createAfter(Og(a, e))
                }
                return new ef(d, u)
            }
            return null
        }

        function Og(t, e) {
            let n = t;
            let o = n;
            while (e.isLimit(o) && o.parent) {
                n = o;
                o = o.parent
            }
            return n
        }

        function zg(t, e, n) {
            const o = t.nodeAfter && !n.isLimit(t.nodeAfter) || n.checkChild(t, "$text");
            const i = e.nodeBefore && !n.isLimit(e.nodeBefore) || n.checkChild(e, "$text");
            return o || i
        }

        function jg(t) {
            const e = [];
            e.push(t.shift());
            for (const n of t) {
                const t = e.pop();
                if (n.isEqual(t)) {
                    e.push(t)
                } else if (n.isIntersecting(t)) {
                    const o = t.start.isAfter(n.start) ? n.start : t.start;
                    const i = t.end.isAfter(n.end) ? t.end : n.end;
                    const r = new ef(o, i);
                    e.push(r)
                } else {
                    e.push(t);
                    e.push(n)
                }
            }
            return e
        }

        function Fg(t, e) {
            return t && e.isSelectable(t)
        }
        class Rg {
            constructor() {
                this.markers = new $m;
                this.document = new Wm(this);
                this.schema = new Lp;
                this._pendingChanges = [];
                this._currentWriter = null;
                ["insertContent", "deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((t => this.decorate(t)));
                this.on("applyOperation", ((t, e) => {
                    const n = e[0];
                    n._validate()
                }), {
                    priority: "highest"
                });
                this.schema.register("$root", {
                    isLimit: true
                });
                this.schema.register("$block", {
                    allowIn: "$root",
                    isBlock: true
                });
                this.schema.register("$text", {
                    allowIn: "$block",
                    isInline: true,
                    isContent: true
                });
                this.schema.register("$clipboardHolder", {
                    allowContentOf: "$root",
                    isLimit: true
                });
                this.schema.extend("$text", {
                    allowIn: "$clipboardHolder"
                });
                this.schema.register("$marker");
                this.schema.addChildCheck(((t, e) => {
                    if (e.name === "$marker") {
                        return true
                    }
                }));
                Ig(this);
                this.document.registerPostFixer(cp)
            }
            change(t) {
                try {
                    if (this._pendingChanges.length === 0) {
                        this._pendingChanges.push({
                            batch: new am,
                            callback: t
                        });
                        return this._runPendingChanges()[0]
                    } else {
                        return t(this._currentWriter)
                    }
                } catch (t) {
                    ss["a"].rethrowUnexpectedError(t, this)
                }
            }
            enqueueChange(t, e) {
                try {
                    if (typeof t === "string") {
                        t = new am(t)
                    } else if (typeof t == "function") {
                        e = t;
                        t = new am
                    }
                    this._pendingChanges.push({
                        batch: t,
                        callback: e
                    });
                    if (this._pendingChanges.length == 1) {
                        this._runPendingChanges()
                    }
                } catch (t) {
                    ss["a"].rethrowUnexpectedError(t, this)
                }
            }
            applyOperation(t) {
                t._execute()
            }
            insertContent(t, e, n) {
                return ig(this, t, e, n)
            }
            deleteContent(t, e) {
                sg(this, t, e)
            }
            modifySelection(t, e) {
                _g(this, t, e)
            }
            getSelectedContent(t) {
                return Sg(this, t)
            }
            hasContent(t, e = {}) {
                const n = t instanceof qh ? ef._createIn(t) : t;
                if (n.isCollapsed) {
                    return false
                }
                const {
                    ignoreWhitespaces: o = false,
                    ignoreMarkers: i = false
                } = e;
                if (!i) {
                    for (const t of this.markers.getMarkersIntersectingRange(n)) {
                        if (t.affectsData) {
                            return true
                        }
                    }
                }
                for (const t of n.getItems()) {
                    if (this.schema.isContent(t)) {
                        if (t.is("$textProxy")) {
                            if (!o) {
                                return true
                            } else if (t.data.search(/\S/) !== -1) {
                                return true
                            }
                        } else {
                            return true
                        }
                    }
                }
                return false
            }
            createPositionFromPath(t, e, n) {
                return new Zh(t, e, n)
            }
            createPositionAt(t, e) {
                return Zh._createAt(t, e)
            }
            createPositionAfter(t) {
                return Zh._createAfter(t)
            }
            createPositionBefore(t) {
                return Zh._createBefore(t)
            }
            createRange(t, e) {
                return new ef(t, e)
            }
            createRangeIn(t) {
                return ef._createIn(t)
            }
            createRangeOn(t) {
                return ef._createOn(t)
            }
            createSelection(t, e, n) {
                return new uf(t, e, n)
            }
            createBatch(t) {
                return new am(t)
            }
            createOperationFromJSON(t) {
                return tg.fromJSON(t, this.document)
            }
            destroy() {
                this.document.destroy();
                this.stopListening()
            }
            _runPendingChanges() {
                const t = [];
                this.fire("_beforeChanges");
                while (this._pendingChanges.length) {
                    const e = this._pendingChanges[0].batch;
                    this._currentWriter = new Im(this, e);
                    const n = this._pendingChanges[0].callback(this._currentWriter);
                    t.push(n);
                    this.document._handleChangeBlock(this._currentWriter);
                    this._pendingChanges.shift();
                    this._currentWriter = null
                }
                this.fire("_afterChanges");
                return t
            }
        }
        _s(Rg, Zc);
        class Vg {
            constructor() {
                this._listener = Object.create(Zd)
            }
            listenTo(t) {
                this._listener.listenTo(t, "keydown", ((t, e) => {
                    this._listener.fire("_keydown:" + zl(e), e)
                }))
            }
            set(t, e, n = {}) {
                const o = jl(t);
                const i = n.priority;
                this._listener.listenTo(this._listener, "_keydown:" + o, ((t, n) => {
                    e(n, (() => {
                        n.preventDefault();
                        n.stopPropagation();
                        t.stop()
                    }));
                    t.return = true
                }), {
                    priority: i
                })
            }
            press(t) {
                return !!this._listener.fire("_keydown:" + zl(t), t)
            }
            destroy() {
                this._listener.stopListening()
            }
        }
        class Ug extends Vg {
            constructor(t) {
                super();
                this.editor = t
            }
            set(t, e, n = {}) {
                if (typeof e == "string") {
                    const t = e;
                    e = (e, n) => {
                        this.editor.execute(t);
                        n()
                    }
                }
                super.set(t, e, n)
            }
        }
        class Gg {
            constructor(t = {}) {
                this._context = t.context || new Ls({
                    language: t.language
                });
                this._context._addEditor(this, !t.context);
                const e = Array.from(this.constructor.builtinPlugins || []);
                this.config = new Qr(t, this.constructor.defaultConfig);
                this.config.define("plugins", e);
                this.config.define(this._context._getEditorConfig());
                this.plugins = new ys(this, e, this._context.plugins);
                this.locale = this._context.locale;
                this.t = this.locale.t;
                this.commands = new Np;
                this.set("state", "initializing");
                this.once("ready", (() => this.state = "ready"), {
                    priority: "high"
                });
                this.once("destroy", (() => this.state = "destroyed"), {
                    priority: "high"
                });
                this.set("isReadOnly", false);
                this.model = new Rg;
                const n = new Lc;
                this.data = new nm(this.model, n);
                this.editing = new Ip(this.model, n);
                this.editing.view.document.bind("isReadOnly").to(this);
                this.conversion = new im([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher);
                this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher);
                this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher);
                this.keystrokes = new Ug(this);
                this.keystrokes.listenTo(this.editing.view.document)
            }
            initPlugins() {
                const t = this.config;
                const e = t.get("plugins");
                const n = t.get("removePlugins") || [];
                const o = t.get("extraPlugins") || [];
                return this.plugins.init(e.concat(o), n)
            }
            destroy() {
                let t = Promise.resolve();
                if (this.state == "initializing") {
                    t = new Promise((t => this.once("ready", t)))
                }
                return t.then((() => {
                    this.fire("destroy");
                    this.stopListening();
                    this.commands.destroy()
                })).then((() => this.plugins.destroy())).then((() => {
                    this.model.destroy();
                    this.data.destroy();
                    this.editing.destroy();
                    this.keystrokes.destroy()
                })).then((() => this._context._removeEditor(this)))
            }
            execute(...t) {
                try {
                    return this.commands.execute(...t)
                } catch (t) {
                    ss["a"].rethrowUnexpectedError(t, this)
                }
            }
            focus() {
                this.editing.view.focus()
            }
        }
        _s(Gg, Zc);
        const Kg = {
            setData(t) {
                this.data.set(t)
            },
            getData(t) {
                return this.data.get(t)
            }
        };
        var Yg = Kg;

        function Hg(t, e) {
            if (t instanceof HTMLTextAreaElement) {
                t.value = e
            }
            t.innerHTML = e
        }
        const qg = {
            updateSourceElement() {
                if (!this.sourceElement) {
                    throw new ss["a"]("editor-missing-sourceelement", this)
                }
                Hg(this.sourceElement, this.data.get())
            }
        };
        var Wg = qg;

        function Qg(t) {
            if (!pt(t.updateSourceElement)) {
                throw new ss["a"]("attachtoform-missing-elementapi-interface", t)
            }
            const e = t.sourceElement;
            if (e && e.tagName.toLowerCase() === "textarea" && e.form) {
                let n;
                const o = e.form;
                const i = () => t.updateSourceElement();
                if (pt(o.submit)) {
                    n = o.submit;
                    o.submit = () => {
                        i();
                        n.apply(o)
                    }
                }
                o.addEventListener("submit", i);
                t.on("destroy", (() => {
                    o.removeEventListener("submit", i);
                    if (n) {
                        o.submit = n
                    }
                }))
            }
        }
        class $g {
            getHtml(t) {
                const e = document.implementation.createHTMLDocument("");
                const n = e.createElement("div");
                n.appendChild(t);
                return n.innerHTML
            }
        }
        class Zg {
            constructor(t) {
                this._domParser = new DOMParser;
                this._domConverter = new Kd(t, {
                    blockFillerMode: "nbsp"
                });
                this._htmlWriter = new $g
            }
            toData(t) {
                const e = this._domConverter.viewToDom(t, document);
                return this._htmlWriter.getHtml(e)
            }
            toView(t) {
                const e = this._toDom(t);
                return this._domConverter.domToView(e)
            }
            registerRawContentMatcher(t) {
                this._domConverter.registerRawContentMatcher(t)
            }
            _toDom(t) {
                const e = this._domParser.parseFromString(t, "text/html");
                const n = e.createDocumentFragment();
                const o = e.body.childNodes;
                while (o.length > 0) {
                    n.appendChild(o[0])
                }
                return n
            }
        }
        class Jg {
            constructor(t) {
                this.editor = t;
                this._components = new Map
            }* names() {
                for (const t of this._components.values()) {
                    yield t.originalName
                }
            }
            add(t, e) {
                this._components.set(Xg(t), {
                    callback: e,
                    originalName: t
                })
            }
            create(t) {
                if (!this.has(t)) {
                    throw new ss["a"]("componentfactory-item-missing", this, {
                        name: t
                    })
                }
                return this._components.get(Xg(t)).callback(this.editor.locale)
            }
            has(t) {
                return this._components.has(Xg(t))
            }
        }

        function Xg(t) {
            return String(t).toLowerCase()
        }
        class tk {
            constructor() {
                this.set("isFocused", false);
                this.set("focusedElement", null);
                this._elements = new Set;
                this._nextEventLoopTimeout = null
            }
            add(t) {
                if (this._elements.has(t)) {
                    throw new ss["a"]("focustracker-add-element-already-exist", this)
                }
                this.listenTo(t, "focus", (() => this._focus(t)), {
                    useCapture: true
                });
                this.listenTo(t, "blur", (() => this._blur()), {
                    useCapture: true
                });
                this._elements.add(t)
            }
            remove(t) {
                if (t === this.focusedElement) {
                    this._blur(t)
                }
                if (this._elements.has(t)) {
                    this.stopListening(t);
                    this._elements.delete(t)
                }
            }
            destroy() {
                this.stopListening()
            }
            _focus(t) {
                clearTimeout(this._nextEventLoopTimeout);
                this.focusedElement = t;
                this.isFocused = true
            }
            _blur() {
                clearTimeout(this._nextEventLoopTimeout);
                this._nextEventLoopTimeout = setTimeout((() => {
                    this.focusedElement = null;
                    this.isFocused = false
                }), 0)
            }
        }
        _s(tk, Zd);
        _s(tk, Zc);
        class ek {
            constructor(t) {
                this.editor = t;
                this.componentFactory = new Jg(t);
                this.focusTracker = new tk;
                this._editableElementsMap = new Map;
                this.listenTo(t.editing.view.document, "layoutChanged", (() => this.update()))
            }
            get element() {
                return null
            }
            update() {
                this.fire("update")
            }
            destroy() {
                this.stopListening();
                this.focusTracker.destroy();
                for (const t of this._editableElementsMap.values()) {
                    t.ckeditorInstance = null
                }
                this._editableElementsMap = new Map
            }
            setEditableElement(t, e) {
                this._editableElementsMap.set(t, e);
                if (!e.ckeditorInstance) {
                    e.ckeditorInstance = this.editor
                }
            }
            getEditableElement(t = "main") {
                return this._editableElementsMap.get(t)
            }
            getEditableElementsNames() {
                return this._editableElementsMap.keys()
            }
            get _editableElements() {
                console.warn("editor-ui-deprecated-editable-elements: " + "The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", {
                    editorUI: this
                });
                return this._editableElementsMap
            }
        }
        _s(ek, ds);

        function nk({
            origin: t,
            originKeystrokeHandler: e,
            originFocusTracker: n,
            toolbar: o,
            beforeFocus: i,
            afterBlur: r
        }) {
            n.add(o.element);
            e.set("Alt+F10", ((t, e) => {
                if (n.isFocused && !o.focusTracker.isFocused) {
                    if (i) {
                        i()
                    }
                    o.focus();
                    e()
                }
            }));
            o.keystrokes.set("Esc", ((e, n) => {
                if (o.focusTracker.isFocused) {
                    t.focus();
                    if (r) {
                        r()
                    }
                    n()
                }
            }))
        }

        function ok(t) {
            if (Array.isArray(t)) {
                return {
                    items: t
                }
            }
            if (!t) {
                return {
                    items: []
                }
            }
            return Object.assign({
                items: []
            }, t)
        }
        var ik = n(1);
        var rk = n.n(ik);
        var sk = n(12);
        var ak = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        ak.insert = "head";
        ak.singleton = true;
        var ck = rk()(sk["a"], ak);
        var lk = sk["a"].locals || {};
        const dk = new WeakMap;

        function uk(t) {
            const {
                view: e,
                element: n,
                text: o,
                isDirectHost: i = true
            } = t;
            const r = e.document;
            if (!dk.has(r)) {
                dk.set(r, new Map);
                r.registerPostFixer((t => gk(r, t)))
            }
            dk.get(r).set(n, {
                text: o,
                isDirectHost: i
            });
            e.change((t => gk(r, t)))
        }

        function hk(t, e) {
            const n = e.document;
            t.change((t => {
                if (!dk.has(n)) {
                    return
                }
                const o = dk.get(n);
                const i = o.get(e);
                t.removeAttribute("data-placeholder", i.hostElement);
                pk(t, i.hostElement);
                o.delete(e)
            }))
        }

        function fk(t, e) {
            if (!e.hasClass("ck-placeholder")) {
                t.addClass("ck-placeholder", e);
                return true
            }
            return false
        }

        function pk(t, e) {
            if (e.hasClass("ck-placeholder")) {
                t.removeClass("ck-placeholder", e);
                return true
            }
            return false
        }

        function mk(t) {
            if (!t.isAttached()) {
                return false
            }
            const e = !Array.from(t.getChildren()).some((t => !t.is("uiElement")));
            const n = t.document;
            if (!n.isFocused && e) {
                return true
            }
            const o = n.selection;
            const i = o.anchor;
            if (e && i && i.parent !== t) {
                return true
            }
            return false
        }

        function gk(t, e) {
            const n = dk.get(t);
            let o = false;
            for (const [t, i] of n) {
                if (kk(e, t, i)) {
                    o = true
                }
            }
            return o
        }

        function kk(t, e, n) {
            const {
                text: o,
                isDirectHost: i
            } = n;
            const r = i ? e : bk(e);
            let s = false;
            if (!r) {
                return false
            }
            n.hostElement = r;
            if (r.getAttribute("data-placeholder") !== o) {
                t.setAttribute("data-placeholder", o, r);
                s = true
            }
            if (mk(r)) {
                if (fk(t, r)) {
                    s = true
                }
            } else if (pk(t, r)) {
                s = true
            }
            return s
        }

        function bk(t) {
            if (t.childCount === 1) {
                const e = t.getChild(0);
                if (e.is("element") && !e.is("uiElement")) {
                    return e
                }
            }
            return null
        }
        class wk {
            constructor() {
                this._replacedElements = []
            }
            replace(t, e) {
                this._replacedElements.push({
                    element: t,
                    newElement: e
                });
                t.style.display = "none";
                if (e) {
                    t.parentNode.insertBefore(e, t.nextSibling)
                }
            }
            restore() {
                this._replacedElements.forEach((({
                    element: t,
                    newElement: e
                }) => {
                    t.style.display = "";
                    if (e) {
                        e.remove()
                    }
                }));
                this._replacedElements = []
            }
        }
        class Ak extends ek {
            constructor(t, e) {
                super(t);
                this.view = e;
                this._toolbarConfig = ok(t.config.get("toolbar"));
                this._elementReplacer = new wk
            }
            get element() {
                return this.view.element
            }
            init(t) {
                const e = this.editor;
                const n = this.view;
                const o = e.editing.view;
                const i = n.editable;
                const r = o.document.getRoot();
                i.name = r.rootName;
                n.render();
                const s = i.element;
                this.setEditableElement(i.name, s);
                this.focusTracker.add(s);
                n.editable.bind("isFocused").to(this.focusTracker);
                o.attachDomRoot(s);
                if (t) {
                    this._elementReplacer.replace(t, this.element)
                }
                this._initPlaceholder();
                this._initToolbar();
                this.fire("ready")
            }
            destroy() {
                const t = this.view;
                const e = this.editor.editing.view;
                this._elementReplacer.restore();
                e.detachDomRoot(t.editable.name);
                t.destroy();
                super.destroy()
            }
            _initToolbar() {
                const t = this.editor;
                const e = this.view;
                const n = t.editing.view;
                e.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused");
                e.stickyPanel.limiterElement = e.element;
                if (this._toolbarConfig.viewportTopOffset) {
                    e.stickyPanel.viewportTopOffset = this._toolbarConfig.viewportTopOffset
                }
                e.toolbar.fillFromConfig(this._toolbarConfig.items, this.componentFactory);
                nk({
                    origin: n,
                    originFocusTracker: this.focusTracker,
                    originKeystrokeHandler: t.keystrokes,
                    toolbar: e.toolbar
                })
            }
            _initPlaceholder() {
                const t = this.editor;
                const e = t.editing.view;
                const n = e.document.getRoot();
                const o = t.sourceElement;
                const i = t.config.get("placeholder") || o && o.tagName.toLowerCase() === "textarea" && o.getAttribute("placeholder");
                if (i) {
                    uk({
                        view: e,
                        element: n,
                        text: i,
                        isDirectHost: false
                    })
                }
            }
        }
        class Ck extends vs {
            constructor(t = []) {
                super(t, {
                    idProperty: "viewUid"
                });
                this.on("add", ((t, e, n) => {
                    this._renderViewIntoCollectionParent(e, n)
                }));
                this.on("remove", ((t, e) => {
                    if (e.element && this._parentElement) {
                        e.element.remove()
                    }
                }));
                this._parentElement = null
            }
            destroy() {
                this.map((t => t.destroy()))
            }
            setParent(t) {
                this._parentElement = t;
                for (const t of this) {
                    this._renderViewIntoCollectionParent(t)
                }
            }
            delegate(...t) {
                if (!t.length || !_k(t)) {
                    throw new ss["a"]("ui-viewcollection-delegate-wrong-events", this)
                }
                return {
                    to: e => {
                        for (const n of this) {
                            for (const o of t) {
                                n.delegate(o).to(e)
                            }
                        }
                        this.on("add", ((n, o) => {
                            for (const n of t) {
                                o.delegate(n).to(e)
                            }
                        }));
                        this.on("remove", ((n, o) => {
                            for (const n of t) {
                                o.stopDelegating(n, e)
                            }
                        }))
                    }
                }
            }
            _renderViewIntoCollectionParent(t, e) {
                if (!t.isRendered) {
                    t.render()
                }
                if (t.element && this._parentElement) {
                    this._parentElement.insertBefore(t.element, this._parentElement.children[e])
                }
            }
        }

        function _k(t) {
            return t.every((t => typeof t == "string"))
        }
        const vk = "http://www.w3.org/1999/xhtml";
        class yk {
            constructor(t) {
                Object.assign(this, Lk(Bk(t)));
                this._isRendered = false;
                this._revertData = null
            }
            render() {
                const t = this._renderNode({
                    intoFragment: true
                });
                this._isRendered = true;
                return t
            }
            apply(t) {
                this._revertData = Wk();
                this._renderNode({
                    node: t,
                    isApplying: true,
                    revertData: this._revertData
                });
                return t
            }
            revert(t) {
                if (!this._revertData) {
                    throw new ss["a"]("ui-template-revert-not-applied", [this, t])
                }
                this._revertTemplateFromNode(t, this._revertData)
            }* getViews() {
                function* t(e) {
                    if (e.children) {
                        for (const n of e.children) {
                            if (Yk(n)) {
                                yield n
                            } else if (Hk(n)) {
                                yield* t(n)
                            }
                        }
                    }
                }
                yield* t(this)
            }
            static bind(t, e) {
                return {
                    to(n, o) {
                        return new Dk({
                            eventNameOrFunction: n,
                            attribute: n,
                            observable: t,
                            emitter: e,
                            callback: o
                        })
                    },
                    if (n, o, i) {
                        return new Mk({
                            observable: t,
                            emitter: e,
                            attribute: n,
                            valueIfTrue: o,
                            callback: i
                        })
                    }
                }
            }
            static extend(t, e) {
                if (t._isRendered) {
                    throw new ss["a"]("template-extend-render", [this, t])
                }
                Gk(t, Lk(Bk(e)))
            }
            _renderNode(t) {
                let e;
                if (t.node) {
                    e = this.tag && this.text
                } else {
                    e = this.tag ? this.text : !this.text
                }
                if (e) {
                    throw new ss["a"]("ui-template-wrong-syntax", this)
                }
                if (this.text) {
                    return this._renderText(t)
                } else {
                    return this._renderElement(t)
                }
            }
            _renderElement(t) {
                let e = t.node;
                if (!e) {
                    e = t.node = document.createElementNS(this.ns || vk, this.tag)
                }
                this._renderAttributes(t);
                this._renderElementChildren(t);
                this._setUpListeners(t);
                return e
            }
            _renderText(t) {
                let e = t.node;
                if (e) {
                    t.revertData.text = e.textContent
                } else {
                    e = t.node = document.createTextNode("")
                }
                if (Ek(this.text)) {
                    this._bindToObservable({
                        schema: this.text,
                        updater: Ik(e),
                        data: t
                    })
                } else {
                    e.textContent = this.text.join("")
                }
                return e
            }
            _renderAttributes(t) {
                let e, n, o, i;
                if (!this.attributes) {
                    return
                }
                const r = t.node;
                const s = t.revertData;
                for (e in this.attributes) {
                    o = r.getAttribute(e);
                    n = this.attributes[e];
                    if (s) {
                        s.attributes[e] = o
                    }
                    i = ct(n[0]) && n[0].ns ? n[0].ns : null;
                    if (Ek(n)) {
                        const a = i ? n[0].value : n;
                        if (s && Qk(e)) {
                            a.unshift(o)
                        }
                        this._bindToObservable({
                            schema: a,
                            updater: Nk(r, e, i),
                            data: t
                        })
                    } else if (e == "style" && typeof n[0] !== "string") {
                        this._renderStyleAttribute(n[0], t)
                    } else {
                        if (s && o && Qk(e)) {
                            n.unshift(o)
                        }
                        n = n.map((t => t ? t.value || t : t)).reduce(((t, e) => t.concat(e)), []).reduce(Vk, "");
                        if (!Kk(n)) {
                            r.setAttributeNS(i, e, n)
                        }
                    }
                }
            }
            _renderStyleAttribute(t, e) {
                const n = e.node;
                for (const o in t) {
                    const i = t[o];
                    if (Ek(i)) {
                        this._bindToObservable({
                            schema: [i],
                            updater: Pk(n, o),
                            data: e
                        })
                    } else {
                        n.style[o] = i
                    }
                }
            }
            _renderElementChildren(t) {
                const e = t.node;
                const n = t.intoFragment ? document.createDocumentFragment() : e;
                const o = t.isApplying;
                let i = 0;
                for (const r of this.children) {
                    if (qk(r)) {
                        if (!o) {
                            r.setParent(e);
                            for (const t of r) {
                                n.appendChild(t.element)
                            }
                        }
                    } else if (Yk(r)) {
                        if (!o) {
                            if (!r.isRendered) {
                                r.render()
                            }
                            n.appendChild(r.element)
                        }
                    } else if (Td(r)) {
                        n.appendChild(r)
                    } else {
                        if (o) {
                            const e = t.revertData;
                            const o = Wk();
                            e.children.push(o);
                            r._renderNode({
                                node: n.childNodes[i++],
                                isApplying: true,
                                revertData: o
                            })
                        } else {
                            n.appendChild(r.render())
                        }
                    }
                }
                if (t.intoFragment) {
                    e.appendChild(n)
                }
            }
            _setUpListeners(t) {
                if (!this.eventListeners) {
                    return
                }
                for (const e in this.eventListeners) {
                    const n = this.eventListeners[e].map((n => {
                        const [o, i] = e.split("@");
                        return n.activateDomEventListener(o, i, t)
                    }));
                    if (t.revertData) {
                        t.revertData.bindings.push(n)
                    }
                }
            }
            _bindToObservable({
                schema: t,
                updater: e,
                data: n
            }) {
                const o = n.revertData;
                Tk(t, e, n);
                const i = t.filter((t => !Kk(t))).filter((t => t.observable)).map((o => o.activateAttributeListener(t, e, n)));
                if (o) {
                    o.bindings.push(i)
                }
            }
            _revertTemplateFromNode(t, e) {
                for (const t of e.bindings) {
                    for (const e of t) {
                        e()
                    }
                }
                if (e.text) {
                    t.textContent = e.text;
                    return
                }
                for (const n in e.attributes) {
                    const o = e.attributes[n];
                    if (o === null) {
                        t.removeAttribute(n)
                    } else {
                        t.setAttribute(n, o)
                    }
                }
                for (let n = 0; n < e.children.length; ++n) {
                    this._revertTemplateFromNode(t.childNodes[n], e.children[n])
                }
            }
        }
        _s(yk, ds);
        class xk {
            constructor(t) {
                Object.assign(this, t)
            }
            getValue(t) {
                const e = this.observable[this.attribute];
                return this.callback ? this.callback(e, t) : e
            }
            activateAttributeListener(t, e, n) {
                const o = () => Tk(t, e, n);
                this.emitter.listenTo(this.observable, "change:" + this.attribute, o);
                return () => {
                    this.emitter.stopListening(this.observable, "change:" + this.attribute, o)
                }
            }
        }
        class Dk extends xk {
            activateDomEventListener(t, e, n) {
                const o = (t, n) => {
                    if (!e || n.target.matches(e)) {
                        if (typeof this.eventNameOrFunction == "function") {
                            this.eventNameOrFunction(n)
                        } else {
                            this.observable.fire(this.eventNameOrFunction, n)
                        }
                    }
                };
                this.emitter.listenTo(n.node, t, o);
                return () => {
                    this.emitter.stopListening(n.node, t, o)
                }
            }
        }
        class Mk extends xk {
            getValue(t) {
                const e = super.getValue(t);
                return Kk(e) ? false : this.valueIfTrue || true
            }
        }

        function Ek(t) {
            if (!t) {
                return false
            }
            if (t.value) {
                t = t.value
            }
            if (Array.isArray(t)) {
                return t.some(Ek)
            } else if (t instanceof xk) {
                return true
            }
            return false
        }

        function Sk(t, e) {
            return t.map((t => {
                if (t instanceof xk) {
                    return t.getValue(e)
                }
                return t
            }))
        }

        function Tk(t, e, {
            node: n
        }) {
            let o = Sk(t, n);
            if (t.length == 1 && t[0] instanceof Mk) {
                o = o[0]
            } else {
                o = o.reduce(Vk, "")
            }
            if (Kk(o)) {
                e.remove()
            } else {
                e.set(o)
            }
        }

        function Ik(t) {
            return {
                set(e) {
                    t.textContent = e
                },
                remove() {
                    t.textContent = ""
                }
            }
        }

        function Nk(t, e, n) {
            return {
                set(o) {
                    t.setAttributeNS(n, e, o)
                },
                remove() {
                    t.removeAttributeNS(n, e)
                }
            }
        }

        function Pk(t, e) {
            return {
                set(n) {
                    t.style[e] = n
                },
                remove() {
                    t.style[e] = null
                }
            }
        }

        function Bk(t) {
            const e = Hr(t, (t => {
                if (t && (t instanceof xk || Hk(t) || Yk(t) || qk(t))) {
                    return t
                }
            }));
            return e
        }

        function Lk(t) {
            if (typeof t == "string") {
                t = jk(t)
            } else if (t.text) {
                Fk(t)
            }
            if (t.on) {
                t.eventListeners = zk(t.on);
                delete t.on
            }
            if (!t.text) {
                if (t.attributes) {
                    Ok(t.attributes)
                }
                const e = [];
                if (t.children) {
                    if (qk(t.children)) {
                        e.push(t.children)
                    } else {
                        for (const n of t.children) {
                            if (Hk(n) || Yk(n) || Td(n)) {
                                e.push(n)
                            } else {
                                e.push(new yk(n))
                            }
                        }
                    }
                }
                t.children = e
            }
            return t
        }

        function Ok(t) {
            for (const e in t) {
                if (t[e].value) {
                    t[e].value = xs(t[e].value)
                }
                Rk(t, e)
            }
        }

        function zk(t) {
            for (const e in t) {
                Rk(t, e)
            }
            return t
        }

        function jk(t) {
            return {
                text: [t]
            }
        }

        function Fk(t) {
            t.text = xs(t.text)
        }

        function Rk(t, e) {
            t[e] = xs(t[e])
        }

        function Vk(t, e) {
            if (Kk(e)) {
                return t
            } else if (Kk(t)) {
                return e
            } else {
                return `${t} ${e}`
            }
        }

        function Uk(t, e) {
            for (const n in e) {
                if (t[n]) {
                    t[n].push(...e[n])
                } else {
                    t[n] = e[n]
                }
            }
        }

        function Gk(t, e) {
            if (e.attributes) {
                if (!t.attributes) {
                    t.attributes = {}
                }
                Uk(t.attributes, e.attributes)
            }
            if (e.eventListeners) {
                if (!t.eventListeners) {
                    t.eventListeners = {}
                }
                Uk(t.eventListeners, e.eventListeners)
            }
            if (e.text) {
                t.text.push(...e.text)
            }
            if (e.children && e.children.length) {
                if (t.children.length != e.children.length) {
                    throw new ss["a"]("ui-template-extend-children-mismatch", t)
                }
                let n = 0;
                for (const o of e.children) {
                    Gk(t.children[n++], o)
                }
            }
        }

        function Kk(t) {
            return !t && t !== 0
        }

        function Yk(t) {
            return t instanceof tb
        }

        function Hk(t) {
            return t instanceof yk
        }

        function qk(t) {
            return t instanceof Ck
        }

        function Wk() {
            return {
                children: [],
                bindings: [],
                attributes: {}
            }
        }

        function Qk(t) {
            return t == "class" || t == "style"
        }
        var $k = n(13);
        var Zk = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        Zk.insert = "head";
        Zk.singleton = true;
        var Jk = rk()($k["a"], Zk);
        var Xk = $k["a"].locals || {};
        class tb {
            constructor(t) {
                this.element = null;
                this.isRendered = false;
                this.locale = t;
                this.t = t && t.t;
                this._viewCollections = new vs;
                this._unboundChildren = this.createCollection();
                this._viewCollections.on("add", ((e, n) => {
                    n.locale = t
                }));
                this.decorate("render")
            }
            get bindTemplate() {
                if (this._bindTemplate) {
                    return this._bindTemplate
                }
                return this._bindTemplate = yk.bind(this, this)
            }
            createCollection(t) {
                const e = new Ck(t);
                this._viewCollections.add(e);
                return e
            }
            registerChild(t) {
                if (!Cs(t)) {
                    t = [t]
                }
                for (const e of t) {
                    this._unboundChildren.add(e)
                }
            }
            deregisterChild(t) {
                if (!Cs(t)) {
                    t = [t]
                }
                for (const e of t) {
                    this._unboundChildren.remove(e)
                }
            }
            setTemplate(t) {
                this.template = new yk(t)
            }
            extendTemplate(t) {
                yk.extend(this.template, t)
            }
            render() {
                if (this.isRendered) {
                    throw new ss["a"]("ui-view-render-already-rendered", this)
                }
                if (this.template) {
                    this.element = this.template.render();
                    this.registerChild(this.template.getViews())
                }
                this.isRendered = true
            }
            destroy() {
                this.stopListening();
                this._viewCollections.map((t => t.destroy()));
                if (this.template && this.template._revertData) {
                    this.template.revert(this.element)
                }
            }
        }
        _s(tb, Zd);
        _s(tb, Zc);
        var eb = "[object String]";

        function nb(t) {
            return typeof t == "string" || !Qe(t) && D(t) && A(t) == eb
        }
        var ob = nb;

        function ib(t, e, n = {}, o = []) {
            const i = n && n.xmlns;
            const r = i ? t.createElementNS(i, e) : t.createElement(e);
            for (const t in n) {
                r.setAttribute(t, n[t])
            }
            if (ob(o) || !Cs(o)) {
                o = [o]
            }
            for (let e of o) {
                if (ob(e)) {
                    e = t.createTextNode(e)
                }
                r.appendChild(e)
            }
            return r
        }
        class rb extends Ck {
            constructor(t, e = []) {
                super(e);
                this.locale = t
            }
            attachToDom() {
                this._bodyCollectionContainer = new yk({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"],
                        dir: this.locale.uiLanguageDirection
                    },
                    children: this
                }).render();
                let t = document.querySelector(".ck-body-wrapper");
                if (!t) {
                    t = ib(document, "div", {
                        class: "ck-body-wrapper"
                    });
                    document.body.appendChild(t)
                }
                t.appendChild(this._bodyCollectionContainer)
            }
            detachFromDom() {
                super.destroy();
                if (this._bodyCollectionContainer) {
                    this._bodyCollectionContainer.remove()
                }
                const t = document.querySelector(".ck-body-wrapper");
                if (t && t.childElementCount == 0) {
                    t.remove()
                }
            }
        }
        var sb = n(14);
        var ab = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        ab.insert = "head";
        ab.singleton = true;
        var cb = rk()(sb["a"], ab);
        var lb = sb["a"].locals || {};
        class db extends tb {
            constructor(t) {
                super(t);
                this.body = new rb(t)
            }
            render() {
                super.render();
                this.body.attachToDom()
            }
            destroy() {
                this.body.detachFromDom();
                return super.destroy()
            }
        }
        var ub = n(15);
        var hb = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        hb.insert = "head";
        hb.singleton = true;
        var fb = rk()(ub["a"], hb);
        var pb = ub["a"].locals || {};
        class mb extends tb {
            constructor(t) {
                super(t);
                this.set("text");
                this.set("for");
                this.id = `ck-editor__label_${ns()}`;
                const e = this.bindTemplate;
                this.setTemplate({
                    tag: "label",
                    attributes: {
                        class: ["ck", "ck-label"],
                        id: this.id,
                        for: e.to("for")
                    },
                    children: [{
                        text: e.to("text")
                    }]
                })
            }
        }
        class gb extends db {
            constructor(t) {
                super(t);
                this.top = this.createCollection();
                this.main = this.createCollection();
                this._voiceLabelView = this._createVoiceLabel();
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"],
                        role: "application",
                        dir: t.uiLanguageDirection,
                        lang: t.uiLanguage,
                        "aria-labelledby": this._voiceLabelView.id
                    },
                    children: [this._voiceLabelView, {
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-editor__top", "ck-reset_all"],
                            role: "presentation"
                        },
                        children: this.top
                    }, {
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-editor__main"],
                            role: "presentation"
                        },
                        children: this.main
                    }]
                })
            }
            _createVoiceLabel() {
                const t = this.t;
                const e = new mb;
                e.text = t("Rich Text Editor");
                e.extendTemplate({
                    attributes: {
                        class: "ck-voice-label"
                    }
                });
                return e
            }
        }
        class kb extends tb {
            constructor(t, e, n) {
                super(t);
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"],
                        lang: t.contentLanguage,
                        dir: t.contentLanguageDirection
                    }
                });
                this.name = null;
                this.set("isFocused", false);
                this._editableElement = n;
                this._hasExternalElement = !!this._editableElement;
                this._editingView = e
            }
            render() {
                super.render();
                if (this._hasExternalElement) {
                    this.template.apply(this.element = this._editableElement)
                } else {
                    this._editableElement = this.element
                }
                this.on("change:isFocused", (() => this._updateIsFocusedClasses()));
                this._updateIsFocusedClasses()
            }
            destroy() {
                if (this._hasExternalElement) {
                    this.template.revert(this._editableElement)
                }
                super.destroy()
            }
            _updateIsFocusedClasses() {
                const t = this._editingView;
                if (t.isRenderingInProgress) {
                    n(this)
                } else {
                    e(this)
                }

                function e(e) {
                    t.change((n => {
                        const o = t.document.getRoot(e.name);
                        n.addClass(e.isFocused ? "ck-focused" : "ck-blurred", o);
                        n.removeClass(e.isFocused ? "ck-blurred" : "ck-focused", o)
                    }))
                }

                function n(o) {
                    t.once("change:isRenderingInProgress", ((t, i, r) => {
                        if (!r) {
                            e(o)
                        } else {
                            n(o)
                        }
                    }))
                }
            }
        }
        class bb extends kb {
            constructor(t, e, n) {
                super(t, e, n);
                this.extendTemplate({
                    attributes: {
                        role: "textbox",
                        class: "ck-editor__editable_inline"
                    }
                })
            }
            render() {
                super.render();
                const t = this._editingView;
                const e = this.t;
                t.change((n => {
                    const o = t.document.getRoot(this.name);
                    n.setAttribute("aria-label", e("Rich Text Editor, %0", this.name), o)
                }))
            }
        }

        function wb(t) {
            return e => e + t
        }
        var Ab = n(16);
        var Cb = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        Cb.insert = "head";
        Cb.singleton = true;
        var _b = rk()(Ab["a"], Cb);
        var vb = Ab["a"].locals || {};
        const yb = wb("px");
        class xb extends tb {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("isActive", false);
                this.set("isSticky", false);
                this.set("limiterElement", null);
                this.set("limiterBottomOffset", 50);
                this.set("viewportTopOffset", 0);
                this.set("_marginLeft", null);
                this.set("_isStickyToTheLimiter", false);
                this.set("_hasViewportTopOffset", false);
                this.content = this.createCollection();
                this._contentPanelPlaceholder = new yk({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-sticky-panel__placeholder"],
                        style: {
                            display: e.to("isSticky", (t => t ? "block" : "none")),
                            height: e.to("isSticky", (t => t ? yb(this._panelRect.height) : null))
                        }
                    }
                }).render();
                this._contentPanel = new yk({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-sticky-panel__content", e.if("isSticky", "ck-sticky-panel__content_sticky"), e.if("_isStickyToTheLimiter", "ck-sticky-panel__content_sticky_bottom-limit")],
                        style: {
                            width: e.to("isSticky", (t => t ? yb(this._contentPanelPlaceholder.getBoundingClientRect().width) : null)),
                            top: e.to("_hasViewportTopOffset", (t => t ? yb(this.viewportTopOffset) : null)),
                            bottom: e.to("_isStickyToTheLimiter", (t => t ? yb(this.limiterBottomOffset) : null)),
                            marginLeft: e.to("_marginLeft")
                        }
                    },
                    children: this.content
                }).render();
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-sticky-panel"]
                    },
                    children: [this._contentPanelPlaceholder, this._contentPanel]
                })
            }
            render() {
                super.render();
                this._checkIfShouldBeSticky();
                this.listenTo(Fd.window, "scroll", (() => {
                    this._checkIfShouldBeSticky()
                }));
                this.listenTo(this, "change:isActive", (() => {
                    this._checkIfShouldBeSticky()
                }))
            }
            _checkIfShouldBeSticky() {
                const t = this._panelRect = this._contentPanel.getBoundingClientRect();
                let e;
                if (!this.limiterElement) {
                    this.isSticky = false
                } else {
                    e = this._limiterRect = this.limiterElement.getBoundingClientRect();
                    this.isSticky = this.isActive && e.top < this.viewportTopOffset && this._panelRect.height + this.limiterBottomOffset < e.height
                }
                if (this.isSticky) {
                    this._isStickyToTheLimiter = e.bottom < t.height + this.limiterBottomOffset + this.viewportTopOffset;
                    this._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset;
                    this._marginLeft = this._isStickyToTheLimiter ? null : yb(-Fd.window.scrollX)
                } else {
                    this._isStickyToTheLimiter = false;
                    this._hasViewportTopOffset = false;
                    this._marginLeft = null
                }
            }
        }
        class Db {
            constructor(t) {
                Object.assign(this, t);
                if (t.actions && t.keystrokeHandler) {
                    for (const e in t.actions) {
                        let n = t.actions[e];
                        if (typeof n == "string") {
                            n = [n]
                        }
                        for (const o of n) {
                            t.keystrokeHandler.set(o, ((t, n) => {
                                this[e]();
                                n()
                            }))
                        }
                    }
                }
            }
            get first() {
                return this.focusables.find(Mb) || null
            }
            get last() {
                return this.focusables.filter(Mb).slice(-1)[0] || null
            }
            get next() {
                return this._getFocusableItem(1)
            }
            get previous() {
                return this._getFocusableItem(-1)
            }
            get current() {
                let t = null;
                if (this.focusTracker.focusedElement === null) {
                    return null
                }
                this.focusables.find(((e, n) => {
                    const o = e.element === this.focusTracker.focusedElement;
                    if (o) {
                        t = n
                    }
                    return o
                }));
                return t
            }
            focusFirst() {
                this._focus(this.first)
            }
            focusLast() {
                this._focus(this.last)
            }
            focusNext() {
                this._focus(this.next)
            }
            focusPrevious() {
                this._focus(this.previous)
            }
            _focus(t) {
                if (t) {
                    t.focus()
                }
            }
            _getFocusableItem(t) {
                const e = this.current;
                const n = this.focusables.length;
                if (!n) {
                    return null
                }
                if (e === null) {
                    return this[t === 1 ? "first" : "last"]
                }
                let o = (e + n + t) % n;
                do {
                    const e = this.focusables.get(o);
                    if (Mb(e)) {
                        return e
                    }
                    o = (o + n + t) % n
                } while (o !== e);
                return null
            }
        }

        function Mb(t) {
            return !!(t.focus && Fd.window.getComputedStyle(t.element).display != "none")
        }
        class Eb extends tb {
            constructor(t) {
                super(t);
                this.setTemplate({
                    tag: "span",
                    attributes: {
                        class: ["ck", "ck-toolbar__separator"]
                    }
                })
            }
        }
        class Sb extends tb {
            constructor(t) {
                super(t);
                this.setTemplate({
                    tag: "span",
                    attributes: {
                        class: ["ck", "ck-toolbar__line-break"]
                    }
                })
            }
        }
        const Tb = 100;
        class Ib {
            constructor(t, e) {
                if (!Ib._observerInstance) {
                    Ib._createObserver()
                }
                this._element = t;
                this._callback = e;
                Ib._addElementCallback(t, e);
                Ib._observerInstance.observe(t)
            }
            destroy() {
                Ib._deleteElementCallback(this._element, this._callback)
            }
            static _addElementCallback(t, e) {
                if (!Ib._elementCallbacks) {
                    Ib._elementCallbacks = new Map
                }
                let n = Ib._elementCallbacks.get(t);
                if (!n) {
                    n = new Set;
                    Ib._elementCallbacks.set(t, n)
                }
                n.add(e)
            }
            static _deleteElementCallback(t, e) {
                const n = Ib._getElementCallbacks(t);
                if (n) {
                    n.delete(e);
                    if (!n.size) {
                        Ib._elementCallbacks.delete(t);
                        Ib._observerInstance.unobserve(t)
                    }
                }
                if (Ib._elementCallbacks && !Ib._elementCallbacks.size) {
                    Ib._observerInstance = null;
                    Ib._elementCallbacks = null
                }
            }
            static _getElementCallbacks(t) {
                if (!Ib._elementCallbacks) {
                    return null
                }
                return Ib._elementCallbacks.get(t)
            }
            static _createObserver() {
                let t;
                if (typeof Fd.window.ResizeObserver === "function") {
                    t = Fd.window.ResizeObserver
                } else {
                    t = Nb
                }
                Ib._observerInstance = new t((t => {
                    for (const e of t) {
                        const t = Ib._getElementCallbacks(e.target);
                        if (t) {
                            for (const n of t) {
                                n(e)
                            }
                        }
                    }
                }))
            }
        }
        Ib._observerInstance = null;
        Ib._elementCallbacks = null;
        class Nb {
            constructor(t) {
                this._callback = t;
                this._elements = new Set;
                this._previousRects = new Map;
                this._periodicCheckTimeout = null
            }
            observe(t) {
                this._elements.add(t);
                this._checkElementRectsAndExecuteCallback();
                if (this._elements.size === 1) {
                    this._startPeriodicCheck()
                }
            }
            unobserve(t) {
                this._elements.delete(t);
                this._previousRects.delete(t);
                if (!this._elements.size) {
                    this._stopPeriodicCheck()
                }
            }
            _startPeriodicCheck() {
                const t = () => {
                    this._checkElementRectsAndExecuteCallback();
                    this._periodicCheckTimeout = setTimeout(t, Tb)
                };
                this.listenTo(Fd.window, "resize", (() => {
                    this._checkElementRectsAndExecuteCallback()
                }));
                this._periodicCheckTimeout = setTimeout(t, Tb)
            }
            _stopPeriodicCheck() {
                clearTimeout(this._periodicCheckTimeout);
                this.stopListening();
                this._previousRects.clear()
            }
            _checkElementRectsAndExecuteCallback() {
                const t = [];
                for (const e of this._elements) {
                    if (this._hasRectChanged(e)) {
                        t.push({
                            target: e,
                            contentRect: this._previousRects.get(e)
                        })
                    }
                }
                if (t.length) {
                    this._callback(t)
                }
            }
            _hasRectChanged(t) {
                if (!t.ownerDocument.body.contains(t)) {
                    return false
                }
                const e = new Mh(t);
                const n = this._previousRects.get(t);
                const o = !n || !n.isEqual(e);
                this._previousRects.set(t, e);
                return o
            }
        }
        _s(Nb, Zd);

        function Pb(t) {
            return t.bindTemplate.to((e => {
                if (e.target === t.element) {
                    e.preventDefault()
                }
            }))
        }
        class Bb extends tb {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("isVisible", false);
                this.set("position", "se");
                this.children = this.createCollection();
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-reset", "ck-dropdown__panel", e.to("position", (t => `ck-dropdown__panel_${t}`)), e.if("isVisible", "ck-dropdown__panel-visible")]
                    },
                    children: this.children,
                    on: {
                        selectstart: e.to((t => t.preventDefault()))
                    }
                })
            }
            focus() {
                if (this.children.length) {
                    this.children.first.focus()
                }
            }
            focusLast() {
                if (this.children.length) {
                    const t = this.children.last;
                    if (typeof t.focusLast === "function") {
                        t.focusLast()
                    } else {
                        t.focus()
                    }
                }
            }
        }
        var Lb = n(17);
        var Ob = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        Ob.insert = "head";
        Ob.singleton = true;
        var zb = rk()(Lb["a"], Ob);
        var jb = Lb["a"].locals || {};

        function Fb(t) {
            if (!t || !t.parentNode) {
                return null
            }
            if (t.offsetParent === Fd.document.body) {
                return null
            }
            return t.offsetParent
        }

        function Rb({
            element: t,
            target: e,
            positions: n,
            limiter: o,
            fitInViewport: i
        }) {
            if (pt(e)) {
                e = e()
            }
            if (pt(o)) {
                o = o()
            }
            const r = Fb(t);
            const s = new Mh(t);
            const a = new Mh(e);
            let c;
            let l;
            if (!o && !i) {
                [l, c] = Vb(n[0], a, s)
            } else {
                const t = o && new Mh(o).getVisible();
                const e = i && new Mh(Fd.window);
                const r = Ub(n, {
                    targetRect: a,
                    elementRect: s,
                    limiterRect: t,
                    viewportRect: e
                });
                [l, c] = r || Vb(n[0], a, s)
            }
            let d = Hb(c);
            if (r) {
                d = Yb(d, r)
            }
            return {
                left: d.left,
                top: d.top,
                name: l
            }
        }

        function Vb(t, e, n) {
            const o = t(e, n);
            if (!o) {
                return null
            }
            const {
                left: i,
                top: r,
                name: s
            } = o;
            return [s, n.clone().moveTo(i, r)]
        }

        function Ub(t, e) {
            const {
                elementRect: n,
                viewportRect: o
            } = e;
            const i = n.getArea();
            const r = Gb(t, e);
            if (o) {
                const t = r.filter((({
                    viewportIntersectArea: t
                }) => t === i));
                const e = Kb(t, i);
                if (e) {
                    return e
                }
            }
            return Kb(r, i)
        }

        function Gb(t, {
            targetRect: e,
            elementRect: n,
            limiterRect: o,
            viewportRect: i
        }) {
            const r = [];
            const s = n.getArea();
            for (const a of t) {
                const t = Vb(a, e, n);
                if (!t) {
                    continue
                }
                const [c, l] = t;
                let d = 0;
                let u = 0;
                if (o) {
                    if (i) {
                        const t = o.getIntersection(i);
                        if (t) {
                            d = t.getIntersectionArea(l)
                        }
                    } else {
                        d = o.getIntersectionArea(l)
                    }
                }
                if (i) {
                    u = i.getIntersectionArea(l)
                }
                const h = {
                    positionName: c,
                    positionRect: l,
                    limiterIntersectArea: d,
                    viewportIntersectArea: u
                };
                if (d === s) {
                    return [h]
                }
                r.push(h)
            }
            return r
        }

        function Kb(t, e) {
            let n = 0;
            let o;
            let i;
            for (const {
                    positionName: r,
                    positionRect: s,
                    limiterIntersectArea: a,
                    viewportIntersectArea: c
                } of t) {
                if (a === e) {
                    return [r, s]
                }
                const t = c ** 2 + a ** 2;
                if (t > n) {
                    n = t;
                    o = s;
                    i = r
                }
            }
            return o ? [i, o] : null
        }

        function Yb({
            left: t,
            top: e
        }, n) {
            const o = Hb(new Mh(n));
            const i = xh(n);
            t -= o.left;
            e -= o.top;
            t += n.scrollLeft;
            e += n.scrollTop;
            t -= i.left;
            e -= i.top;
            return {
                left: t,
                top: e
            }
        }

        function Hb({
            left: t,
            top: e
        }) {
            const {
                scrollX: n,
                scrollY: o
            } = Fd.window;
            return {
                left: t + n,
                top: e + o
            }
        }
        class qb extends tb {
            constructor(t, e, n) {
                super(t);
                const o = this.bindTemplate;
                this.buttonView = e;
                this.panelView = n;
                this.set("isOpen", false);
                this.set("isEnabled", true);
                this.set("class");
                this.set("id");
                this.set("panelPosition", "auto");
                this.keystrokes = new Vg;
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-dropdown", o.to("class"), o.if("isEnabled", "ck-disabled", (t => !t))],
                        id: o.to("id"),
                        "aria-describedby": o.to("ariaDescribedById")
                    },
                    children: [e, n]
                });
                e.extendTemplate({
                    attributes: {
                        class: ["ck-dropdown__button"]
                    }
                })
            }
            render() {
                super.render();
                this.listenTo(this.buttonView, "open", (() => {
                    this.isOpen = !this.isOpen
                }));
                this.panelView.bind("isVisible").to(this, "isOpen");
                this.on("change:isOpen", (() => {
                    if (!this.isOpen) {
                        return
                    }
                    if (this.panelPosition === "auto") {
                        this.panelView.position = qb._getOptimalPosition({
                            element: this.panelView.element,
                            target: this.buttonView.element,
                            fitInViewport: true,
                            positions: this._panelPositions
                        }).name
                    } else {
                        this.panelView.position = this.panelPosition
                    }
                }));
                this.keystrokes.listenTo(this.element);
                const t = (t, e) => {
                    if (this.isOpen) {
                        this.buttonView.focus();
                        this.isOpen = false;
                        e()
                    }
                };
                this.keystrokes.set("arrowdown", ((t, e) => {
                    if (this.buttonView.isEnabled && !this.isOpen) {
                        this.isOpen = true;
                        e()
                    }
                }));
                this.keystrokes.set("arrowright", ((t, e) => {
                    if (this.isOpen) {
                        e()
                    }
                }));
                this.keystrokes.set("arrowleft", t);
                this.keystrokes.set("esc", t)
            }
            focus() {
                this.buttonView.focus()
            }
            get _panelPositions() {
                const {
                    southEast: t,
                    southWest: e,
                    northEast: n,
                    northWest: o
                } = qb.defaultPanelPositions;
                if (this.locale.uiLanguageDirection === "ltr") {
                    return [t, e, n, o]
                } else {
                    return [e, t, o, n]
                }
            }
        }
        qb.defaultPanelPositions = {
            southEast: t => ({
                top: t.bottom,
                left: t.left,
                name: "se"
            }),
            southWest: (t, e) => ({
                top: t.bottom,
                left: t.left - e.width + t.width,
                name: "sw"
            }),
            northEast: (t, e) => ({
                top: t.top - e.height,
                left: t.left,
                name: "ne"
            }),
            northWest: (t, e) => ({
                top: t.bottom - e.height,
                left: t.left - e.width + t.width,
                name: "nw"
            })
        };
        qb._getOptimalPosition = Rb;
        var Wb = n(18);
        var Qb = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        Qb.insert = "head";
        Qb.singleton = true;
        var $b = rk()(Wb["a"], Qb);
        var Zb = Wb["a"].locals || {};
        class Jb extends tb {
            constructor() {
                super();
                const t = this.bindTemplate;
                this.set("content", "");
                this.set("viewBox", "0 0 20 20");
                this.set("fillColor", "");
                this.setTemplate({
                    tag: "svg",
                    ns: "http://www.w3.org/2000/svg",
                    attributes: {
                        class: ["ck", "ck-icon"],
                        viewBox: t.to("viewBox")
                    }
                })
            }
            render() {
                super.render();
                this._updateXMLContent();
                this._colorFillPaths();
                this.on("change:content", (() => {
                    this._updateXMLContent();
                    this._colorFillPaths()
                }));
                this.on("change:fillColor", (() => {
                    this._colorFillPaths()
                }))
            }
            _updateXMLContent() {
                if (this.content) {
                    const t = (new DOMParser).parseFromString(this.content.trim(), "image/svg+xml");
                    const e = t.querySelector("svg");
                    const n = e.getAttribute("viewBox");
                    if (n) {
                        this.viewBox = n
                    }
                    this.element.innerHTML = "";
                    while (e.childNodes.length > 0) {
                        this.element.appendChild(e.childNodes[0])
                    }
                }
            }
            _colorFillPaths() {
                if (this.fillColor) {
                    this.element.querySelectorAll(".ck-icon__fill").forEach((t => {
                        t.style.fill = this.fillColor
                    }))
                }
            }
        }
        var Xb = n(19);
        var tw = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        tw.insert = "head";
        tw.singleton = true;
        var ew = rk()(Xb["a"], tw);
        var nw = Xb["a"].locals || {};
        class ow extends tb {
            constructor(t) {
                super(t);
                this.set("text", "");
                this.set("position", "s");
                const e = this.bindTemplate;
                this.setTemplate({
                    tag: "span",
                    attributes: {
                        class: ["ck", "ck-tooltip", e.to("position", (t => "ck-tooltip_" + t)), e.if("text", "ck-hidden", (t => !t.trim()))]
                    },
                    children: [{
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-tooltip__text"]
                        },
                        children: [{
                            text: e.to("text")
                        }]
                    }]
                })
            }
        }
        var iw = n(20);
        var rw = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        rw.insert = "head";
        rw.singleton = true;
        var sw = rk()(iw["a"], rw);
        var aw = iw["a"].locals || {};
        class cw extends tb {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                const n = ns();
                this.set("class");
                this.set("labelStyle");
                this.set("icon");
                this.set("isEnabled", true);
                this.set("isOn", false);
                this.set("isVisible", true);
                this.set("isToggleable", false);
                this.set("keystroke");
                this.set("label");
                this.set("tabindex", -1);
                this.set("tooltip");
                this.set("tooltipPosition", "s");
                this.set("type", "button");
                this.set("withText", false);
                this.set("withKeystroke", false);
                this.children = this.createCollection();
                this.tooltipView = this._createTooltipView();
                this.labelView = this._createLabelView(n);
                this.iconView = new Jb;
                this.iconView.extendTemplate({
                    attributes: {
                        class: "ck-button__icon"
                    }
                });
                this.keystrokeView = this._createKeystrokeView();
                this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
                this.setTemplate({
                    tag: "button",
                    attributes: {
                        class: ["ck", "ck-button", e.to("class"), e.if("isEnabled", "ck-disabled", (t => !t)), e.if("isVisible", "ck-hidden", (t => !t)), e.to("isOn", (t => t ? "ck-on" : "ck-off")), e.if("withText", "ck-button_with-text"), e.if("withKeystroke", "ck-button_with-keystroke")],
                        type: e.to("type", (t => t ? t : "button")),
                        tabindex: e.to("tabindex"),
                        "aria-labelledby": `ck-editor__aria-label_${n}`,
                        "aria-disabled": e.if("isEnabled", true, (t => !t)),
                        "aria-pressed": e.to("isOn", (t => this.isToggleable ? String(t) : false))
                    },
                    children: this.children,
                    on: {
                        mousedown: e.to((t => {
                            t.preventDefault()
                        })),
                        click: e.to((t => {
                            if (this.isEnabled) {
                                this.fire("execute")
                            } else {
                                t.preventDefault()
                            }
                        }))
                    }
                })
            }
            render() {
                super.render();
                if (this.icon) {
                    this.iconView.bind("content").to(this, "icon");
                    this.children.add(this.iconView)
                }
                this.children.add(this.tooltipView);
                this.children.add(this.labelView);
                if (this.withKeystroke) {
                    this.children.add(this.keystrokeView)
                }
            }
            focus() {
                this.element.focus()
            }
            _createTooltipView() {
                const t = new ow;
                t.bind("text").to(this, "_tooltipString");
                t.bind("position").to(this, "tooltipPosition");
                return t
            }
            _createLabelView(t) {
                const e = new tb;
                const n = this.bindTemplate;
                e.setTemplate({
                    tag: "span",
                    attributes: {
                        class: ["ck", "ck-button__label"],
                        style: n.to("labelStyle"),
                        id: `ck-editor__aria-label_${t}`
                    },
                    children: [{
                        text: this.bindTemplate.to("label")
                    }]
                });
                return e
            }
            _createKeystrokeView() {
                const t = new tb;
                t.setTemplate({
                    tag: "span",
                    attributes: {
                        class: ["ck", "ck-button__keystroke"]
                    },
                    children: [{
                        text: this.bindTemplate.to("keystroke", (t => Fl(t)))
                    }]
                });
                return t
            }
            _getTooltipString(t, e, n) {
                if (t) {
                    if (typeof t == "string") {
                        return t
                    } else {
                        if (n) {
                            n = Fl(n)
                        }
                        if (t instanceof Function) {
                            return t(e, n)
                        } else {
                            return `${e}${n?` (${n})`:""}`
                        }
                    }
                }
                return ""
            }
        }
        var lw = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
        class dw extends cw {
            constructor(t) {
                super(t);
                this.arrowView = this._createArrowView();
                this.extendTemplate({
                    attributes: {
                        "aria-haspopup": true
                    }
                });
                this.delegate("execute").to(this, "open")
            }
            render() {
                super.render();
                this.children.add(this.arrowView)
            }
            _createArrowView() {
                const t = new Jb;
                t.content = lw;
                t.extendTemplate({
                    attributes: {
                        class: "ck-dropdown__arrow"
                    }
                });
                return t
            }
        }
        var uw = n(21);
        var hw = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        hw.insert = "head";
        hw.singleton = true;
        var fw = rk()(uw["a"], hw);
        var pw = uw["a"].locals || {};
        class mw extends tb {
            constructor() {
                super();
                this.items = this.createCollection();
                this.focusTracker = new tk;
                this.keystrokes = new Vg;
                this._focusCycler = new Db({
                    focusables: this.items,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {
                        focusPrevious: "arrowup",
                        focusNext: "arrowdown"
                    }
                });
                this.setTemplate({
                    tag: "ul",
                    attributes: {
                        class: ["ck", "ck-reset", "ck-list"]
                    },
                    children: this.items
                })
            }
            render() {
                super.render();
                for (const t of this.items) {
                    this.focusTracker.add(t.element)
                }
                this.items.on("add", ((t, e) => {
                    this.focusTracker.add(e.element)
                }));
                this.items.on("remove", ((t, e) => {
                    this.focusTracker.remove(e.element)
                }));
                this.keystrokes.listenTo(this.element)
            }
            focus() {
                this._focusCycler.focusFirst()
            }
            focusLast() {
                this._focusCycler.focusLast()
            }
        }
        class gw extends tb {
            constructor(t) {
                super(t);
                this.children = this.createCollection();
                this.setTemplate({
                    tag: "li",
                    attributes: {
                        class: ["ck", "ck-list__item"]
                    },
                    children: this.children
                })
            }
            focus() {
                this.children.first.focus()
            }
        }
        class kw extends tb {
            constructor(t) {
                super(t);
                this.setTemplate({
                    tag: "li",
                    attributes: {
                        class: ["ck", "ck-list__separator"]
                    }
                })
            }
        }
        var bw = n(22);
        var ww = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        ww.insert = "head";
        ww.singleton = true;
        var Aw = rk()(bw["a"], ww);
        var Cw = bw["a"].locals || {};
        class _w extends cw {
            constructor(t) {
                super(t);
                this.isToggleable = true;
                this.toggleSwitchView = this._createToggleView();
                this.extendTemplate({
                    attributes: {
                        class: "ck-switchbutton"
                    }
                })
            }
            render() {
                super.render();
                this.children.add(this.toggleSwitchView)
            }
            _createToggleView() {
                const t = new tb;
                t.setTemplate({
                    tag: "span",
                    attributes: {
                        class: ["ck", "ck-button__toggle"]
                    },
                    children: [{
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-button__toggle__inner"]
                        }
                    }]
                });
                return t
            }
        }

        function vw({
            emitter: t,
            activator: e,
            callback: n,
            contextElements: o
        }) {
            t.listenTo(document, "mousedown", ((t, i) => {
                if (!e()) {
                    return
                }
                const r = typeof i.composedPath == "function" ? i.composedPath() : [];
                for (const t of o) {
                    if (t.contains(i.target) || r.includes(t)) {
                        return
                    }
                }
                n()
            }))
        }
        var yw = n(23);
        var xw = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        xw.insert = "head";
        xw.singleton = true;
        var Dw = rk()(yw["a"], xw);
        var Mw = yw["a"].locals || {};
        var Ew = n(24);
        var Sw = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        Sw.insert = "head";
        Sw.singleton = true;
        var Tw = rk()(Ew["a"], Sw);
        var Iw = Ew["a"].locals || {};

        function Nw(t, e = dw) {
            const n = new e(t);
            const o = new Bb(t);
            const i = new qb(t, n, o);
            n.bind("isEnabled").to(i);
            if (n instanceof dw) {
                n.bind("isOn").to(i, "isOpen")
            } else {
                n.arrowView.bind("isOn").to(i, "isOpen")
            }
            Lw(i);
            return i
        }

        function Pw(t, e) {
            const n = t.locale;
            const o = n.t;
            const i = t.toolbarView = new Kw(n);
            i.set("ariaLabel", o("Dropdown toolbar"));
            t.extendTemplate({
                attributes: {
                    class: ["ck-toolbar-dropdown"]
                }
            });
            e.map((t => i.items.add(t)));
            t.panelView.children.add(i);
            i.items.delegate("execute").to(t)
        }

        function Bw(t, e) {
            const n = t.locale;
            const o = t.listView = new mw(n);
            o.items.bindTo(e).using((({
                type: t,
                model: e
            }) => {
                if (t === "separator") {
                    return new kw(n)
                } else if (t === "button" || t === "switchbutton") {
                    const o = new gw(n);
                    let i;
                    if (t === "button") {
                        i = new cw(n)
                    } else {
                        i = new _w(n)
                    }
                    i.bind(...Object.keys(e)).to(e);
                    i.delegate("execute").to(o);
                    o.children.add(i);
                    return o
                }
            }));
            t.panelView.children.add(o);
            o.items.delegate("execute").to(t)
        }

        function Lw(t) {
            Ow(t);
            zw(t);
            jw(t)
        }

        function Ow(t) {
            t.on("render", (() => {
                vw({
                    emitter: t,
                    activator: () => t.isOpen,
                    callback: () => {
                        t.isOpen = false
                    },
                    contextElements: [t.element]
                })
            }))
        }

        function zw(t) {
            t.on("execute", (e => {
                if (e.source instanceof _w) {
                    return
                }
                t.isOpen = false
            }))
        }

        function jw(t) {
            t.keystrokes.set("arrowdown", ((e, n) => {
                if (t.isOpen) {
                    t.panelView.focus();
                    n()
                }
            }));
            t.keystrokes.set("arrowup", ((e, n) => {
                if (t.isOpen) {
                    t.panelView.focusLast();
                    n()
                }
            }))
        }
        var Fw = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>';
        var Rw = n(25);
        var Vw = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        Vw.insert = "head";
        Vw.singleton = true;
        var Uw = rk()(Rw["a"], Vw);
        var Gw = Rw["a"].locals || {};
        class Kw extends tb {
            constructor(t, e) {
                super(t);
                const n = this.bindTemplate;
                const o = this.t;
                this.options = e || {};
                this.set("ariaLabel", o("Editor toolbar"));
                this.set("maxWidth", "auto");
                this.items = this.createCollection();
                this.focusTracker = new tk;
                this.keystrokes = new Vg;
                this.set("class");
                this.set("isCompact", false);
                this.itemsView = new Yw(t);
                this.children = this.createCollection();
                this.children.add(this.itemsView);
                this.focusables = this.createCollection();
                this._focusCycler = new Db({
                    focusables: this.focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {
                        focusPrevious: ["arrowleft", "arrowup"],
                        focusNext: ["arrowright", "arrowdown"]
                    }
                });
                const i = ["ck", "ck-toolbar", n.to("class"), n.if("isCompact", "ck-toolbar_compact")];
                if (this.options.shouldGroupWhenFull && this.options.isFloating) {
                    i.push("ck-toolbar_floating")
                }
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: i,
                        role: "toolbar",
                        "aria-label": n.to("ariaLabel"),
                        style: {
                            maxWidth: n.to("maxWidth")
                        }
                    },
                    children: this.children,
                    on: {
                        mousedown: Pb(this)
                    }
                });
                this._behavior = this.options.shouldGroupWhenFull ? new qw(this) : new Hw(this)
            }
            render() {
                super.render();
                for (const t of this.items) {
                    this.focusTracker.add(t.element)
                }
                this.items.on("add", ((t, e) => {
                    this.focusTracker.add(e.element)
                }));
                this.items.on("remove", ((t, e) => {
                    this.focusTracker.remove(e.element)
                }));
                this.keystrokes.listenTo(this.element);
                this._behavior.render(this)
            }
            destroy() {
                this._behavior.destroy();
                return super.destroy()
            }
            focus() {
                this._focusCycler.focusFirst()
            }
            focusLast() {
                this._focusCycler.focusLast()
            }
            fillFromConfig(t, e) {
                this.items.addMany(t.map((n => {
                    if (n == "|") {
                        return new Eb
                    } else if (n == "-") {
                        if (this.options.shouldGroupWhenFull) {
                            Object(ss["c"])("toolbarview-line-break-ignored-when-grouping-items", t)
                        }
                        return new Sb
                    } else if (e.has(n)) {
                        return e.create(n)
                    } else {
                        Object(ss["c"])("toolbarview-item-unavailable", {
                            name: n
                        })
                    }
                })).filter((t => t !== undefined)))
            }
        }
        class Yw extends tb {
            constructor(t) {
                super(t);
                this.children = this.createCollection();
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-toolbar__items"]
                    },
                    children: this.children
                })
            }
        }
        class Hw {
            constructor(t) {
                const e = t.bindTemplate;
                t.set("isVertical", false);
                t.itemsView.children.bindTo(t.items).using((t => t));
                t.focusables.bindTo(t.items).using((t => t));
                t.extendTemplate({
                    attributes: {
                        class: [e.if("isVertical", "ck-toolbar_vertical")]
                    }
                })
            }
            render() {}
            destroy() {}
        }
        class qw {
            constructor(t) {
                this.view = t;
                this.viewChildren = t.children;
                this.viewFocusables = t.focusables;
                this.viewItemsView = t.itemsView;
                this.viewFocusTracker = t.focusTracker;
                this.viewLocale = t.locale;
                this.ungroupedItems = t.createCollection();
                this.groupedItems = t.createCollection();
                this.groupedItemsDropdown = this._createGroupedItemsDropdown();
                this.resizeObserver = null;
                this.cachedPadding = null;
                this.shouldUpdateGroupingOnNextResize = false;
                t.itemsView.children.bindTo(this.ungroupedItems).using((t => t));
                this.ungroupedItems.on("add", this._updateFocusCycleableItems.bind(this));
                this.ungroupedItems.on("remove", this._updateFocusCycleableItems.bind(this));
                t.children.on("add", this._updateFocusCycleableItems.bind(this));
                t.children.on("remove", this._updateFocusCycleableItems.bind(this));
                t.items.on("change", ((t, e) => {
                    const n = e.index;
                    for (const t of e.removed) {
                        if (n >= this.ungroupedItems.length) {
                            this.groupedItems.remove(t)
                        } else {
                            this.ungroupedItems.remove(t)
                        }
                    }
                    for (let t = n; t < n + e.added.length; t++) {
                        const o = e.added[t - n];
                        if (t > this.ungroupedItems.length) {
                            this.groupedItems.add(o, t - this.ungroupedItems.length)
                        } else {
                            this.ungroupedItems.add(o, t)
                        }
                    }
                    this._updateGrouping()
                }));
                t.extendTemplate({
                    attributes: {
                        class: ["ck-toolbar_grouping"]
                    }
                })
            }
            render(t) {
                this.viewElement = t.element;
                this._enableGroupingOnResize();
                this._enableGroupingOnMaxWidthChange(t)
            }
            destroy() {
                this.groupedItemsDropdown.destroy();
                this.resizeObserver.destroy()
            }
            _updateGrouping() {
                if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) {
                    return
                }
                if (!this.viewElement.offsetParent) {
                    this.shouldUpdateGroupingOnNextResize = true;
                    return
                }
                const t = this.groupedItems.length;
                let e;
                while (this._areItemsOverflowing) {
                    this._groupLastItem();
                    e = true
                }
                if (!e && this.groupedItems.length) {
                    while (this.groupedItems.length && !this._areItemsOverflowing) {
                        this._ungroupFirstItem()
                    }
                    if (this._areItemsOverflowing) {
                        this._groupLastItem()
                    }
                }
                if (this.groupedItems.length !== t) {
                    this.view.fire("groupedItemsUpdate")
                }
            }
            get _areItemsOverflowing() {
                if (!this.ungroupedItems.length) {
                    return false
                }
                const t = this.viewElement;
                const e = this.viewLocale.uiLanguageDirection;
                const n = new Mh(t.lastChild);
                const o = new Mh(t);
                if (!this.cachedPadding) {
                    const n = Fd.window.getComputedStyle(t);
                    const o = e === "ltr" ? "paddingRight" : "paddingLeft";
                    this.cachedPadding = Number.parseInt(n[o])
                }
                if (e === "ltr") {
                    return n.right > o.right - this.cachedPadding
                } else {
                    return n.left < o.left + this.cachedPadding
                }
            }
            _enableGroupingOnResize() {
                let t;
                this.resizeObserver = new Ib(this.viewElement, (e => {
                    if (!t || t !== e.contentRect.width || this.shouldUpdateGroupingOnNextResize) {
                        this.shouldUpdateGroupingOnNextResize = false;
                        this._updateGrouping();
                        t = e.contentRect.width
                    }
                }));
                this._updateGrouping()
            }
            _enableGroupingOnMaxWidthChange(t) {
                t.on("change:maxWidth", (() => {
                    this._updateGrouping()
                }))
            }
            _groupLastItem() {
                if (!this.groupedItems.length) {
                    this.viewChildren.add(new Eb);
                    this.viewChildren.add(this.groupedItemsDropdown);
                    this.viewFocusTracker.add(this.groupedItemsDropdown.element)
                }
                this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0)
            }
            _ungroupFirstItem() {
                this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first));
                if (!this.groupedItems.length) {
                    this.viewChildren.remove(this.groupedItemsDropdown);
                    this.viewChildren.remove(this.viewChildren.last);
                    this.viewFocusTracker.remove(this.groupedItemsDropdown.element)
                }
            }
            _createGroupedItemsDropdown() {
                const t = this.viewLocale;
                const e = t.t;
                const n = Nw(t);
                n.class = "ck-toolbar__grouped-dropdown";
                n.panelPosition = t.uiLanguageDirection === "ltr" ? "sw" : "se";
                Pw(n, []);
                n.buttonView.set({
                    label: e("Show more items"),
                    tooltip: true,
                    icon: Fw
                });
                n.toolbarView.items.bindTo(this.groupedItems).using((t => t));
                return n
            }
            _updateFocusCycleableItems() {
                this.viewFocusables.clear();
                this.ungroupedItems.map((t => {
                    this.viewFocusables.add(t)
                }));
                if (this.groupedItems.length) {
                    this.viewFocusables.add(this.groupedItemsDropdown)
                }
            }
        }
        var Ww = n(26);
        var Qw = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        Qw.insert = "head";
        Qw.singleton = true;
        var $w = rk()(Ww["a"], Qw);
        var Zw = Ww["a"].locals || {};
        class Jw extends gb {
            constructor(t, e, n = {}) {
                super(t);
                this.stickyPanel = new xb(t);
                this.toolbar = new Kw(t, {
                    shouldGroupWhenFull: n.shouldToolbarGroupWhenFull
                });
                this.editable = new bb(t, e)
            }
            render() {
                super.render();
                this.stickyPanel.content.add(this.toolbar);
                this.top.add(this.stickyPanel);
                this.main.add(this.editable)
            }
        }

        function Xw(t) {
            if (t instanceof HTMLTextAreaElement) {
                return t.value
            }
            return t.innerHTML
        }
        class tA extends Gg {
            constructor(t, e) {
                super(e);
                if (Wr(t)) {
                    this.sourceElement = t
                }
                this.data.processor = new Zg(this.data.viewDocument);
                this.model.document.createRoot();
                const n = !this.config.get("toolbar.shouldNotGroupWhenFull");
                const o = new Jw(this.locale, this.editing.view, {
                    shouldToolbarGroupWhenFull: n
                });
                this.ui = new Ak(this, o);
                Qg(this)
            }
            destroy() {
                if (this.sourceElement) {
                    this.updateSourceElement()
                }
                this.ui.destroy();
                return super.destroy()
            }
            static create(t, e = {}) {
                return new Promise((n => {
                    const o = new this(t, e);
                    n(o.initPlugins().then((() => o.ui.init(Wr(t) ? t : null))).then((() => {
                        if (!Wr(t) && e.initialData) {
                            throw new ss["a"]("editor-create-initial-data", null)
                        }
                        const n = e.initialData || eA(t);
                        return o.data.init(n)
                    })).then((() => o.fire("ready"))).then((() => o)))
                }))
            }
        }
        _s(tA, Yg);
        _s(tA, Wg);

        function eA(t) {
            return Wr(t) ? Xw(t) : t
        }
        class nA {
            constructor(t) {
                this.editor = t;
                this.set("isEnabled", true);
                this._disableStack = new Set
            }
            forceDisabled(t) {
                this._disableStack.add(t);
                if (this._disableStack.size == 1) {
                    this.on("set:isEnabled", oA, {
                        priority: "highest"
                    });
                    this.isEnabled = false
                }
            }
            clearForceDisabled(t) {
                this._disableStack.delete(t);
                if (this._disableStack.size == 0) {
                    this.off("set:isEnabled", oA);
                    this.isEnabled = true
                }
            }
            destroy() {
                this.stopListening()
            }
            static get isContextPlugin() {
                return false
            }
        }
        _s(nA, Zc);

        function oA(t) {
            t.return = false;
            t.stop()
        }
        class iA {
            constructor(t) {
                this.editor = t;
                this.set("value", undefined);
                this.set("isEnabled", false);
                this._disableStack = new Set;
                this.decorate("execute");
                this.listenTo(this.editor.model.document, "change", (() => {
                    this.refresh()
                }));
                this.on("execute", (t => {
                    if (!this.isEnabled) {
                        t.stop()
                    }
                }), {
                    priority: "high"
                });
                this.listenTo(t, "change:isReadOnly", ((t, e, n) => {
                    if (n) {
                        this.forceDisabled("readOnlyMode")
                    } else {
                        this.clearForceDisabled("readOnlyMode")
                    }
                }))
            }
            refresh() {
                this.isEnabled = true
            }
            forceDisabled(t) {
                this._disableStack.add(t);
                if (this._disableStack.size == 1) {
                    this.on("set:isEnabled", rA, {
                        priority: "highest"
                    });
                    this.isEnabled = false
                }
            }
            clearForceDisabled(t) {
                this._disableStack.delete(t);
                if (this._disableStack.size == 0) {
                    this.off("set:isEnabled", rA);
                    this.refresh()
                }
            }
            execute() {}
            destroy() {
                this.stopListening()
            }
        }
        _s(iA, Zc);

        function rA(t) {
            t.return = false;
            t.stop()
        }
        class sA extends iA {
            constructor(t, e) {
                super(t);
                this.attributeKey = e
            }
            refresh() {
                const t = this.editor.model;
                const e = t.document;
                this.value = this._getValueFromFirstAllowedNode();
                this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey)
            }
            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                const o = n.selection;
                const i = t.forceValue === undefined ? !this.value : t.forceValue;
                e.change((t => {
                    if (o.isCollapsed) {
                        if (i) {
                            t.setSelectionAttribute(this.attributeKey, true)
                        } else {
                            t.removeSelectionAttribute(this.attributeKey)
                        }
                    } else {
                        const n = e.schema.getValidRanges(o.getRanges(), this.attributeKey);
                        for (const e of n) {
                            if (i) {
                                t.setAttribute(this.attributeKey, i, e)
                            } else {
                                t.removeAttribute(this.attributeKey, e)
                            }
                        }
                    }
                }))
            }
            _getValueFromFirstAllowedNode() {
                const t = this.editor.model;
                const e = t.schema;
                const n = t.document.selection;
                if (n.isCollapsed) {
                    return n.hasAttribute(this.attributeKey)
                }
                for (const t of n.getRanges()) {
                    for (const n of t.getItems()) {
                        if (e.checkAttribute(n, this.attributeKey)) {
                            return n.hasAttribute(this.attributeKey)
                        }
                    }
                }
                return false
            }
        }
        const aA = "bold";
        class cA extends nA {
            static get pluginName() {
                return "BoldEditing"
            }
            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {
                    allowAttributes: aA
                });
                t.model.schema.setAttributeProperties(aA, {
                    isFormatting: true,
                    copyOnEnter: true
                });
                t.conversion.attributeToElement({
                    model: aA,
                    view: "strong",
                    upcastAlso: ["b", t => {
                        const e = t.getStyle("font-weight");
                        if (!e) {
                            return null
                        }
                        if (e == "bold" || Number(e) >= 600) {
                            return {
                                name: true,
                                styles: ["font-weight"]
                            }
                        }
                    }]
                });
                t.commands.add(aA, new sA(t, aA));
                t.keystrokes.set("CTRL+B", aA)
            }
        }
        var lA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>';
        const dA = "bold";
        class uA extends nA {
            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add(dA, (n => {
                    const o = t.commands.get(dA);
                    const i = new cw(n);
                    i.set({
                        label: e("Bold"),
                        icon: lA,
                        keystroke: "CTRL+B",
                        tooltip: true,
                        isToggleable: true
                    });
                    i.bind("isOn", "isEnabled").to(o, "value", "isEnabled");
                    this.listenTo(i, "execute", (() => {
                        t.execute(dA);
                        t.editing.view.focus()
                    }));
                    return i
                }))
            }
        }
        class hA extends nA {
            static get requires() {
                return [cA, uA]
            }
            static get pluginName() {
                return "Bold"
            }
        }
        class fA {
            constructor(t) {
                this.files = pA(t);
                this._native = t
            }
            get types() {
                return this._native.types
            }
            getData(t) {
                return this._native.getData(t)
            }
            setData(t, e) {
                this._native.setData(t, e)
            }
        }

        function pA(t) {
            const e = t.files ? Array.from(t.files) : [];
            const n = t.items ? Array.from(t.items) : [];
            if (e.length) {
                return e
            }
            return n.filter((t => t.kind === "file")).map((t => t.getAsFile()))
        }
        class mA extends nh {
            constructor(t) {
                super(t);
                const e = this.document;
                this.domEventType = ["paste", "copy", "cut", "drop", "dragover"];
                this.listenTo(e, "paste", n, {
                    priority: "low"
                });
                this.listenTo(e, "drop", n, {
                    priority: "low"
                });

                function n(t, n) {
                    n.preventDefault();
                    const o = n.dropRange ? [n.dropRange] : Array.from(e.selection.getRanges());
                    const i = new ts(e, "clipboardInput");
                    e.fire(i, {
                        dataTransfer: n.dataTransfer,
                        targetRanges: o
                    });
                    if (i.stop.called) {
                        n.stopPropagation()
                    }
                }
            }
            onDomEvent(t) {
                const e = {
                    dataTransfer: new fA(t.clipboardData ? t.clipboardData : t.dataTransfer)
                };
                if (t.type == "drop") {
                    e.dropRange = gA(this.view, t)
                }
                this.fire(t.type, t, e)
            }
        }

        function gA(t, e) {
            const n = e.target.ownerDocument;
            const o = e.clientX;
            const i = e.clientY;
            let r;
            if (n.caretRangeFromPoint && n.caretRangeFromPoint(o, i)) {
                r = n.caretRangeFromPoint(o, i)
            } else if (e.rangeParent) {
                r = n.createRange();
                r.setStart(e.rangeParent, e.rangeOffset);
                r.collapse(true)
            }
            if (r) {
                return t.domConverter.domRangeToView(r)
            } else {
                return t.document.selection.getFirstRange()
            }
        }
        class kA extends nA {
            static get pluginName() {
                return "PastePlainText"
            }
            init() {
                const t = this.editor.editing.view;
                const e = t.document;
                let n = false;
                t.addObserver(mA);
                this.listenTo(e, "keydown", ((t, e) => {
                    n = e.shiftKey
                }));
                this.listenTo(e, "clipboardInput", ((t, e) => {
                    if (n) {
                        e.asPlainText = true
                    }
                }), {
                    priority: "high"
                })
            }
        }

        function bA(t) {
            t = t.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;");
            if (t.includes("</p><p>") || t.includes("<br>")) {
                t = `<p>${t}</p>`
            }
            return t
        }

        function wA(t) {
            return t.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, ((t, e) => {
                if (e.length == 1) {
                    return " "
                }
                return e
            }))
        }
        const AA = ["figcaption", "li"];

        function CA(t) {
            let e = "";
            if (t.is("$text") || t.is("$textProxy")) {
                e = t.data
            } else if (t.is("element", "img") && t.hasAttribute("alt")) {
                e = t.getAttribute("alt")
            } else if (t.is("element", "br")) {
                e = "\n"
            } else {
                let n = null;
                for (const o of t.getChildren()) {
                    const t = CA(o);
                    if (n && (n.is("containerElement") || o.is("containerElement"))) {
                        if (AA.includes(n.name) || AA.includes(o.name)) {
                            e += "\n"
                        } else {
                            e += "\n\n"
                        }
                    }
                    e += t;
                    n = o
                }
            }
            return e
        }
        class _A extends nA {
            static get pluginName() {
                return "Clipboard"
            }
            static get requires() {
                return [kA]
            }
            init() {
                const t = this.editor;
                const e = t.model.document;
                const n = t.editing.view;
                const o = n.document;
                this._htmlDataProcessor = new Zg(o);
                n.addObserver(mA);
                this.listenTo(o, "clipboardInput", (e => {
                    if (t.isReadOnly) {
                        e.stop()
                    }
                }), {
                    priority: "highest"
                });
                this.listenTo(o, "clipboardInput", ((t, e) => {
                    const o = e.dataTransfer;
                    let i = "";
                    if (o.getData("text/html")) {
                        i = wA(o.getData("text/html"))
                    } else if (o.getData("text/plain")) {
                        i = bA(o.getData("text/plain"))
                    }
                    i = this._htmlDataProcessor.toView(i);
                    const r = new ts(this, "inputTransformation");
                    this.fire(r, {
                        content: i,
                        dataTransfer: o,
                        asPlainText: e.asPlainText
                    });
                    if (r.stop.called) {
                        t.stop()
                    }
                    n.scrollToTheSelection()
                }), {
                    priority: "low"
                });
                this.listenTo(this, "inputTransformation", ((t, e) => {
                    if (!e.content.isEmpty) {
                        const n = this.editor.data;
                        const o = this.editor.model;
                        const i = n.toModel(e.content, "$clipboardHolder");
                        if (i.childCount == 0) {
                            return
                        }
                        o.change((t => {
                            const n = o.document.selection;
                            if (e.asPlainText || vA(i, o.schema)) {
                                const e = Array.from(n.getAttributes()).filter((([t]) => o.schema.getAttributeProperties(t).isFormatting));
                                if (!n.isCollapsed) {
                                    o.deleteContent(n, {
                                        doNotAutoparagraph: true
                                    })
                                }
                                e.push(...n.getAttributes());
                                const r = t.createRangeIn(i);
                                for (const n of r.getItems()) {
                                    if (n.is("$text") || n.is("$textProxy")) {
                                        t.setAttributes(e, n)
                                    }
                                }
                            }
                            o.insertContent(i)
                        }));
                        t.stop()
                    }
                }), {
                    priority: "low"
                });

                function i(n, i) {
                    const r = i.dataTransfer;
                    i.preventDefault();
                    const s = t.data.toView(t.model.getSelectedContent(e.selection));
                    o.fire("clipboardOutput", {
                        dataTransfer: r,
                        content: s,
                        method: n.name
                    })
                }
                this.listenTo(o, "copy", i, {
                    priority: "low"
                });
                this.listenTo(o, "cut", ((e, n) => {
                    if (t.isReadOnly) {
                        n.preventDefault()
                    } else {
                        i(e, n)
                    }
                }), {
                    priority: "low"
                });
                this.listenTo(o, "clipboardOutput", ((n, o) => {
                    if (!o.content.isEmpty) {
                        o.dataTransfer.setData("text/html", this._htmlDataProcessor.toData(o.content));
                        o.dataTransfer.setData("text/plain", CA(o.content))
                    }
                    if (o.method == "cut") {
                        t.model.deleteContent(e.selection)
                    }
                }), {
                    priority: "low"
                })
            }
        }

        function vA(t, e) {
            if (t.childCount > 1) {
                return false
            }
            const n = t.getChild(0);
            if (e.isObject(n)) {
                return false
            }
            return [...n.getAttributeKeys()].length == 0
        }

        function* yA(t, e) {
            for (const n of e) {
                if (n && t.getAttributeProperties(n[0]).copyOnEnter) {
                    yield n
                }
            }
        }
        class xA extends iA {
            execute() {
                const t = this.editor.model;
                const e = t.document;
                t.change((n => {
                    DA(this.editor.model, n, e.selection, t.schema);
                    this.fire("afterExecute", {
                        writer: n
                    })
                }))
            }
        }

        function DA(t, e, n, o) {
            const i = n.isCollapsed;
            const r = n.getFirstRange();
            const s = r.start.parent;
            const a = r.end.parent;
            if (o.isLimit(s) || o.isLimit(a)) {
                if (!i && s == a) {
                    t.deleteContent(n)
                }
                return
            }
            if (i) {
                const t = yA(e.model.schema, n.getAttributes());
                MA(e, r.start);
                e.setSelectionAttribute(t)
            } else {
                const o = !(r.start.isAtStart && r.end.isAtEnd);
                const i = s == a;
                t.deleteContent(n, {
                    leaveUnmerged: o
                });
                if (o) {
                    if (i) {
                        MA(e, n.focus)
                    } else {
                        e.setSelection(a, 0)
                    }
                }
            }
        }

        function MA(t, e) {
            t.split(e);
            t.setSelection(e.parent.nextSibling, 0)
        }
        class EA extends tu {
            constructor(t) {
                super(t);
                const e = this.document;
                e.on("keydown", ((t, n) => {
                    if (this.isEnabled && n.keyCode == Ol.enter) {
                        let o;
                        e.once("enter", (t => o = t), {
                            priority: "highest"
                        });
                        e.fire("enter", new eh(e, n.domEvent, {
                            isSoft: n.shiftKey
                        }));
                        if (o && o.stop.called) {
                            t.stop()
                        }
                    }
                }))
            }
            observe() {}
        }
        class SA extends nA {
            static get pluginName() {
                return "Enter"
            }
            init() {
                const t = this.editor;
                const e = t.editing.view;
                const n = e.document;
                e.addObserver(EA);
                t.commands.add("enter", new xA(t));
                this.listenTo(n, "enter", ((n, o) => {
                    o.preventDefault();
                    if (o.isSoft) {
                        return
                    }
                    t.execute("enter");
                    e.scrollToTheSelection()
                }), {
                    priority: "low"
                })
            }
        }
        class TA extends iA {
            execute() {
                const t = this.editor.model;
                const e = t.document;
                t.change((n => {
                    NA(t, n, e.selection);
                    this.fire("afterExecute", {
                        writer: n
                    })
                }))
            }
            refresh() {
                const t = this.editor.model;
                const e = t.document;
                this.isEnabled = IA(t.schema, e.selection)
            }
        }

        function IA(t, e) {
            if (e.rangeCount > 1) {
                return false
            }
            const n = e.anchor;
            if (!n || !t.checkChild(n, "softBreak")) {
                return false
            }
            const o = e.getFirstRange();
            const i = o.start.parent;
            const r = o.end.parent;
            if ((BA(i, t) || BA(r, t)) && i !== r) {
                return false
            }
            return true
        }

        function NA(t, e, n) {
            const o = n.isCollapsed;
            const i = n.getFirstRange();
            const r = i.start.parent;
            const s = i.end.parent;
            const a = r == s;
            if (o) {
                const o = yA(t.schema, n.getAttributes());
                PA(t, e, i.end);
                e.removeSelectionAttribute(n.getAttributeKeys());
                e.setSelectionAttribute(o)
            } else {
                const o = !(i.start.isAtStart && i.end.isAtEnd);
                t.deleteContent(n, {
                    leaveUnmerged: o
                });
                if (a) {
                    PA(t, e, n.focus)
                } else {
                    if (o) {
                        e.setSelection(s, 0)
                    }
                }
            }
        }

        function PA(t, e, n) {
            const o = e.createElement("softBreak");
            t.insertContent(o, n);
            e.setSelection(o, "after")
        }

        function BA(t, e) {
            if (t.is("rootElement")) {
                return false
            }
            return e.isLimit(t) || BA(t.parent, e)
        }
        class LA extends nA {
            static get pluginName() {
                return "ShiftEnter"
            }
            init() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.conversion;
                const o = t.editing.view;
                const i = o.document;
                e.register("softBreak", {
                    allowWhere: "$text",
                    isInline: true
                });
                n.for("upcast").elementToElement({
                    model: "softBreak",
                    view: "br"
                });
                n.for("downcast").elementToElement({
                    model: "softBreak",
                    view: (t, {
                        writer: e
                    }) => e.createEmptyElement("br")
                });
                o.addObserver(EA);
                t.commands.add("shiftEnter", new TA(t));
                this.listenTo(i, "enter", ((e, n) => {
                    n.preventDefault();
                    if (!n.isSoft) {
                        return
                    }
                    t.execute("shiftEnter");
                    o.scrollToTheSelection()
                }), {
                    priority: "low"
                })
            }
        }
        class OA extends iA {
            execute() {
                const t = this.editor.model;
                const e = t.document.selection;
                let n = t.schema.getLimitElement(e);
                if (e.containsEntireContent(n) || !zA(t.schema, n)) {
                    do {
                        n = n.parent;
                        if (!n) {
                            return
                        }
                    } while (!zA(t.schema, n))
                }
                t.change((t => {
                    t.setSelection(n, "in")
                }))
            }
        }

        function zA(t, e) {
            return t.isLimit(e) && (t.checkChild(e, "$text") || t.checkChild(e, "paragraph"))
        }
        const jA = jl("Ctrl+A");
        class FA extends nA {
            static get pluginName() {
                return "SelectAllEditing"
            }
            init() {
                const t = this.editor;
                const e = t.editing.view;
                const n = e.document;
                t.commands.add("selectAll", new OA(t));
                this.listenTo(n, "keydown", ((e, n) => {
                    if (zl(n) === jA) {
                        t.execute("selectAll");
                        n.preventDefault()
                    }
                }))
            }
        }
        var RA = '<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>';
        class VA extends nA {
            static get pluginName() {
                return "SelectAllUI"
            }
            init() {
                const t = this.editor;
                t.ui.componentFactory.add("selectAll", (e => {
                    const n = t.commands.get("selectAll");
                    const o = new cw(e);
                    const i = e.t;
                    o.set({
                        label: i("Select all"),
                        icon: RA,
                        keystroke: "Ctrl+A",
                        tooltip: true
                    });
                    o.bind("isOn", "isEnabled").to(n, "value", "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute("selectAll");
                        t.editing.view.focus()
                    }));
                    return o
                }))
            }
        }
        class UA extends nA {
            static get requires() {
                return [FA, VA]
            }
            static get pluginName() {
                return "SelectAll"
            }
        }
        class GA {
            constructor(t, e = 20) {
                this.model = t;
                this.size = 0;
                this.limit = e;
                this.isLocked = false;
                this._changeCallback = (t, e) => {
                    if (e.type != "transparent" && e !== this._batch) {
                        this._reset(true)
                    }
                };
                this._selectionChangeCallback = () => {
                    this._reset()
                };
                this.model.document.on("change", this._changeCallback);
                this.model.document.selection.on("change:range", this._selectionChangeCallback);
                this.model.document.selection.on("change:attribute", this._selectionChangeCallback)
            }
            get batch() {
                if (!this._batch) {
                    this._batch = this.model.createBatch()
                }
                return this._batch
            }
            input(t) {
                this.size += t;
                if (this.size >= this.limit) {
                    this._reset(true)
                }
            }
            lock() {
                this.isLocked = true
            }
            unlock() {
                this.isLocked = false
            }
            destroy() {
                this.model.document.off("change", this._changeCallback);
                this.model.document.selection.off("change:range", this._selectionChangeCallback);
                this.model.document.selection.off("change:attribute", this._selectionChangeCallback)
            }
            _reset(t) {
                if (!this.isLocked || t) {
                    this._batch = null;
                    this.size = 0
                }
            }
        }
        class KA extends iA {
            constructor(t, e) {
                super(t);
                this._buffer = new GA(t.model, e);
                this._batches = new WeakSet
            }
            get buffer() {
                return this._buffer
            }
            destroy() {
                super.destroy();
                this._buffer.destroy()
            }
            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                const o = t.text || "";
                const i = o.length;
                const r = t.range ? e.createSelection(t.range) : n.selection;
                const s = t.resultRange;
                e.enqueueChange(this._buffer.batch, (t => {
                    this._buffer.lock();
                    this._batches.add(this._buffer.batch);
                    e.deleteContent(r);
                    if (o) {
                        e.insertContent(t.createText(o, n.selection.getAttributes()), r)
                    }
                    if (s) {
                        t.setSelection(s)
                    } else if (!r.is("documentSelection")) {
                        t.setSelection(r)
                    }
                    this._buffer.unlock();
                    this._buffer.input(i)
                }))
            }
        }

        function YA(t) {
            let e = null;
            const n = t.model;
            const o = t.editing.view;
            const i = t.commands.get("input");
            if (Ml.isAndroid) {
                o.document.on("beforeinput", ((t, e) => r(e)), {
                    priority: "lowest"
                })
            } else {
                o.document.on("keydown", ((t, e) => r(e)), {
                    priority: "lowest"
                })
            }
            o.document.on("compositionstart", s, {
                priority: "lowest"
            });
            o.document.on("compositionend", (() => {
                e = n.createSelection(n.document.selection)
            }), {
                priority: "lowest"
            });

            function r(t) {
                const r = n.document;
                const s = o.document.isComposing;
                const c = e && e.isEqual(r.selection);
                e = null;
                if (!i.isEnabled) {
                    return
                }
                if (qA(t) || r.selection.isCollapsed) {
                    return
                }
                if (s && t.keyCode === 229) {
                    return
                }
                if (!s && t.keyCode === 229 && c) {
                    return
                }
                a()
            }

            function s() {
                const t = n.document;
                const e = t.selection.rangeCount === 1 ? t.selection.getFirstRange().isFlat : true;
                if (t.selection.isCollapsed || e) {
                    return
                }
                a()
            }

            function a() {
                const t = i.buffer;
                t.lock();
                const e = t.batch;
                i._batches.add(e);
                n.enqueueChange(e, (() => {
                    n.deleteContent(n.document.selection)
                }));
                t.unlock()
            }
        }
        const HA = [zl("arrowUp"), zl("arrowRight"), zl("arrowDown"), zl("arrowLeft"), 9, 16, 17, 18, 19, 20, 27, 33, 34, 35, 36, 45, 91, 93, 144, 145, 173, 174, 175, 176, 177, 178, 179, 255];
        for (let t = 112; t <= 135; t++) {
            HA.push(t)
        }

        function qA(t) {
            if (t.ctrlKey) {
                return true
            }
            return HA.includes(t.keyCode)
        }

        function WA(t, e) {
            const n = [];
            let o = 0;
            let i;
            t.forEach((t => {
                if (t == "equal") {
                    r();
                    o++
                } else if (t == "insert") {
                    if (s("insert")) {
                        i.values.push(e[o])
                    } else {
                        r();
                        i = {
                            type: "insert",
                            index: o,
                            values: [e[o]]
                        }
                    }
                    o++
                } else {
                    if (s("delete")) {
                        i.howMany++
                    } else {
                        r();
                        i = {
                            type: "delete",
                            index: o,
                            howMany: 1
                        }
                    }
                }
            }));
            r();
            return n;

            function r() {
                if (i) {
                    n.push(i);
                    i = null
                }
            }

            function s(t) {
                return i && i.type == t
            }
        }

        function QA(t) {
            if (t.length == 0) {
                return false
            }
            for (const e of t) {
                if (e.type === "children" && !$A(e)) {
                    return true
                }
            }
            return false
        }

        function $A(t) {
            if (t.newChildren.length - t.oldChildren.length != 1) {
                return
            }
            const e = Md(t.oldChildren, t.newChildren, ZA);
            const n = WA(e, t.newChildren);
            if (n.length > 1) {
                return
            }
            const o = n[0];
            if (!(!!o.values[0] && o.values[0].is("$text"))) {
                return
            }
            return o
        }

        function ZA(t, e) {
            if (!!t && t.is("$text") && !!e && e.is("$text")) {
                return t.data === e.data
            } else {
                return t === e
            }
        }

        function JA(t) {
            t.editing.view.document.on("mutations", ((e, n, o) => {
                new XA(t).handle(n, o)
            }))
        }
        class XA {
            constructor(t) {
                this.editor = t;
                this.editing = this.editor.editing
            }
            handle(t, e) {
                if (QA(t)) {
                    this._handleContainerChildrenMutations(t, e)
                } else {
                    for (const n of t) {
                        this._handleTextMutation(n, e);
                        this._handleTextNodeInsertion(n)
                    }
                }
            }
            _handleContainerChildrenMutations(t, e) {
                const n = tC(t);
                if (!n) {
                    return
                }
                const o = this.editor.editing.view.domConverter;
                const i = o.mapViewToDom(n);
                const r = new Kd(this.editor.editing.view.document);
                const s = this.editor.data.toModel(r.domToView(i)).getChild(0);
                const a = this.editor.editing.mapper.toModelElement(n);
                if (!a) {
                    return
                }
                const c = Array.from(s.getChildren());
                const l = Array.from(a.getChildren());
                const d = c[c.length - 1];
                const u = l[l.length - 1];
                const h = d && d.is("element", "softBreak");
                const f = u && !u.is("element", "softBreak");
                if (h && f) {
                    c.pop()
                }
                const p = this.editor.model.schema;
                if (!eC(c, p) || !eC(l, p)) {
                    return
                }
                const m = c.map((t => t.is("$text") ? t.data : "@")).join("").replace(/\u00A0/g, " ");
                const g = l.map((t => t.is("$text") ? t.data : "@")).join("").replace(/\u00A0/g, " ");
                if (g === m) {
                    return
                }
                const k = Md(g, m);
                const {
                    firstChangeAt: b,
                    insertions: w,
                    deletions: A
                } = nC(k);
                let C = null;
                if (e) {
                    C = this.editing.mapper.toModelRange(e.getFirstRange())
                }
                const _ = m.substr(b, w);
                const v = this.editor.model.createRange(this.editor.model.createPositionAt(a, b), this.editor.model.createPositionAt(a, b + A));
                this.editor.execute("input", {
                    text: _,
                    range: v,
                    resultRange: C
                })
            }
            _handleTextMutation(t, e) {
                if (t.type != "text") {
                    return
                }
                const n = t.newText.replace(/\u00A0/g, " ");
                const o = t.oldText.replace(/\u00A0/g, " ");
                if (o === n) {
                    return
                }
                const i = Md(o, n);
                const {
                    firstChangeAt: r,
                    insertions: s,
                    deletions: a
                } = nC(i);
                let c = null;
                if (e) {
                    c = this.editing.mapper.toModelRange(e.getFirstRange())
                }
                const l = this.editing.view.createPositionAt(t.node, r);
                const d = this.editing.mapper.toModelPosition(l);
                const u = this.editor.model.createRange(d, d.getShiftedBy(a));
                const h = n.substr(r, s);
                this.editor.execute("input", {
                    text: h,
                    range: u,
                    resultRange: c
                })
            }
            _handleTextNodeInsertion(t) {
                if (t.type != "children") {
                    return
                }
                const e = $A(t);
                const n = this.editing.view.createPositionAt(t.node, e.index);
                const o = this.editing.mapper.toModelPosition(n);
                const i = e.values[0].data;
                this.editor.execute("input", {
                    text: i.replace(/\u00A0/g, " "),
                    range: this.editor.model.createRange(o)
                })
            }
        }

        function tC(t) {
            const e = t.map((t => t.node)).reduce(((t, e) => t.getCommonAncestor(e, {
                includeSelf: true
            })));
            if (!e) {
                return
            }
            return e.getAncestors({
                includeSelf: true,
                parentFirst: true
            }).find((t => t.is("containerElement") || t.is("rootElement")))
        }

        function eC(t, e) {
            return t.every((t => e.isInline(t)))
        }

        function nC(t) {
            let e = null;
            let n = null;
            for (let o = 0; o < t.length; o++) {
                const i = t[o];
                if (i != "equal") {
                    e = e === null ? o : e;
                    n = o
                }
            }
            let o = 0;
            let i = 0;
            for (let r = e; r <= n; r++) {
                if (t[r] != "insert") {
                    o++
                }
                if (t[r] != "delete") {
                    i++
                }
            }
            return {
                insertions: i,
                deletions: o,
                firstChangeAt: e
            }
        }
        class oC extends nA {
            static get pluginName() {
                return "Input"
            }
            init() {
                const t = this.editor;
                const e = new KA(t, t.config.get("typing.undoStep") || 20);
                t.commands.add("input", e);
                YA(t);
                JA(t)
            }
            isInput(t) {
                const e = this.editor.commands.get("input");
                return e._batches.has(t)
            }
        }
        class iC extends iA {
            constructor(t, e) {
                super(t);
                this.direction = e;
                this._buffer = new GA(t.model, t.config.get("typing.undoStep"))
            }
            get buffer() {
                return this._buffer
            }
            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                e.enqueueChange(this._buffer.batch, (o => {
                    this._buffer.lock();
                    const i = o.createSelection(t.selection || n.selection);
                    const r = i.isCollapsed;
                    if (i.isCollapsed) {
                        e.modifySelection(i, {
                            direction: this.direction,
                            unit: t.unit
                        })
                    }
                    if (this._shouldEntireContentBeReplacedWithParagraph(t.sequence || 1)) {
                        this._replaceEntireContentWithParagraph(o);
                        return
                    }
                    if (i.isCollapsed) {
                        return
                    }
                    let s = 0;
                    i.getFirstRange().getMinimalFlatRanges().forEach((t => {
                        s += ml(t.getWalker({
                            singleCharacters: true,
                            ignoreElementEnd: true,
                            shallow: true
                        }))
                    }));
                    e.deleteContent(i, {
                        doNotResetEntireContent: r,
                        direction: this.direction
                    });
                    this._buffer.input(s);
                    o.setSelection(i);
                    this._buffer.unlock()
                }))
            }
            _shouldEntireContentBeReplacedWithParagraph(t) {
                if (t > 1) {
                    return false
                }
                const e = this.editor.model;
                const n = e.document;
                const o = n.selection;
                const i = e.schema.getLimitElement(o);
                const r = o.isCollapsed && o.containsEntireContent(i);
                if (!r) {
                    return false
                }
                if (!e.schema.checkChild(i, "paragraph")) {
                    return false
                }
                const s = i.getChild(0);
                if (s && s.name === "paragraph") {
                    return false
                }
                return true
            }
            _replaceEntireContentWithParagraph(t) {
                const e = this.editor.model;
                const n = e.document;
                const o = n.selection;
                const i = e.schema.getLimitElement(o);
                const r = t.createElement("paragraph");
                t.remove(t.createRangeIn(i));
                t.insert(r, i);
                t.setSelection(r, 0)
            }
        }
        class rC extends tu {
            constructor(t) {
                super(t);
                const e = t.document;
                let n = 0;
                e.on("keyup", ((t, e) => {
                    if (e.keyCode == Ol.delete || e.keyCode == Ol.backspace) {
                        n = 0
                    }
                }));
                e.on("keydown", ((t, e) => {
                    const i = {};
                    if (e.keyCode == Ol.delete) {
                        i.direction = "forward";
                        i.unit = "character"
                    } else if (e.keyCode == Ol.backspace) {
                        i.direction = "backward";
                        i.unit = "codePoint"
                    } else {
                        return
                    }
                    const r = Ml.isMac ? e.altKey : e.ctrlKey;
                    i.unit = r ? "word" : i.unit;
                    i.sequence = ++n;
                    o(t, e.domEvent, i)
                }));
                if (Ml.isAndroid) {
                    e.on("beforeinput", ((e, n) => {
                        if (n.domEvent.inputType != "deleteContentBackward") {
                            return
                        }
                        const i = {
                            unit: "codepoint",
                            direction: "backward",
                            sequence: 1
                        };
                        const r = n.domTarget.ownerDocument.defaultView.getSelection();
                        if (r.anchorNode == r.focusNode && r.anchorOffset + 1 != r.focusOffset) {
                            i.selectionToRemove = t.domConverter.domSelectionToView(r)
                        }
                        o(e, n.domEvent, i)
                    }))
                }

                function o(t, n, o) {
                    let i;
                    e.once("delete", (t => i = t), {
                        priority: Number.POSITIVE_INFINITY
                    });
                    e.fire("delete", new eh(e, n, o));
                    if (i && i.stop.called) {
                        t.stop()
                    }
                }
            }
            observe() {}
        }
        class sC extends nA {
            static get pluginName() {
                return "Delete"
            }
            init() {
                const t = this.editor;
                const e = t.editing.view;
                const n = e.document;
                e.addObserver(rC);
                t.commands.add("forwardDelete", new iC(t, "forward"));
                t.commands.add("delete", new iC(t, "backward"));
                this.listenTo(n, "delete", ((n, o) => {
                    const i = {
                        unit: o.unit,
                        sequence: o.sequence
                    };
                    if (o.selectionToRemove) {
                        const e = t.model.createSelection();
                        const n = [];
                        for (const e of o.selectionToRemove.getRanges()) {
                            n.push(t.editing.mapper.toModelRange(e))
                        }
                        e.setTo(n);
                        i.selection = e
                    }
                    t.execute(o.direction == "forward" ? "forwardDelete" : "delete", i);
                    o.preventDefault();
                    e.scrollToTheSelection()
                }));
                if (Ml.isAndroid) {
                    let t = null;
                    this.listenTo(n, "delete", ((e, n) => {
                        const o = n.domTarget.ownerDocument.defaultView.getSelection();
                        t = {
                            anchorNode: o.anchorNode,
                            anchorOffset: o.anchorOffset,
                            focusNode: o.focusNode,
                            focusOffset: o.focusOffset
                        }
                    }), {
                        priority: "lowest"
                    });
                    this.listenTo(n, "keyup", ((e, n) => {
                        if (t) {
                            const e = n.domTarget.ownerDocument.defaultView.getSelection();
                            e.collapse(t.anchorNode, t.anchorOffset);
                            e.extend(t.focusNode, t.focusOffset);
                            t = null
                        }
                    }))
                }
            }
        }
        class aC extends nA {
            static get requires() {
                return [oC, sC]
            }
            static get pluginName() {
                return "Typing"
            }
        }
        const cC = new Map;

        function lC(t, e, n) {
            let o = cC.get(t);
            if (!o) {
                o = new Map;
                cC.set(t, o)
            }
            o.set(e, n)
        }

        function dC(t, e) {
            const n = cC.get(t);
            if (n && n.has(e)) {
                return n.get(e)
            }
            return uC
        }

        function uC(t) {
            return [t]
        }

        function hC(t, e, n = {}) {
            const o = dC(t.constructor, e.constructor);
            try {
                t = t.clone();
                return o(t, e, n)
            } catch (t) {
                throw t
            }
        }

        function fC(t, e, n) {
            t = t.slice();
            e = e.slice();
            const o = new pC(n.document, n.useRelations, n.forceWeakRemove);
            o.setOriginalOperations(t);
            o.setOriginalOperations(e);
            const i = o.originalOperations;
            if (t.length == 0 || e.length == 0) {
                return {
                    operationsA: t,
                    operationsB: e,
                    originalOperations: i
                }
            }
            const r = new WeakMap;
            for (const e of t) {
                r.set(e, 0)
            }
            const s = {
                nextBaseVersionA: t[t.length - 1].baseVersion + 1,
                nextBaseVersionB: e[e.length - 1].baseVersion + 1,
                originalOperationsACount: t.length,
                originalOperationsBCount: e.length
            };
            let a = 0;
            while (a < t.length) {
                const n = t[a];
                const i = r.get(n);
                if (i == e.length) {
                    a++;
                    continue
                }
                const s = e[i];
                const c = hC(n, s, o.getContext(n, s, true));
                const l = hC(s, n, o.getContext(s, n, false));
                o.updateRelation(n, s);
                o.setOriginalOperations(c, n);
                o.setOriginalOperations(l, s);
                for (const t of c) {
                    r.set(t, i + l.length)
                }
                t.splice(a, 1, ...c);
                e.splice(i, 1, ...l)
            }
            if (n.padWithNoOps) {
                const n = t.length - s.originalOperationsACount;
                const o = e.length - s.originalOperationsBCount;
                gC(t, o - n);
                gC(e, n - o)
            }
            mC(t, s.nextBaseVersionB);
            mC(e, s.nextBaseVersionA);
            return {
                operationsA: t,
                operationsB: e,
                originalOperations: i
            }
        }
        class pC {
            constructor(t, e, n = false) {
                this.originalOperations = new Map;
                this._history = t.history;
                this._useRelations = e;
                this._forceWeakRemove = !!n;
                this._relations = new Map
            }
            setOriginalOperations(t, e = null) {
                const n = e ? this.originalOperations.get(e) : null;
                for (const e of t) {
                    this.originalOperations.set(e, n || e)
                }
            }
            updateRelation(t, e) {
                switch (t.constructor) {
                    case vm: {
                        switch (e.constructor) {
                            case Em: {
                                if (t.targetPosition.isEqual(e.sourcePosition) || e.movedRange.containsPosition(t.targetPosition)) {
                                    this._setRelation(t, e, "insertAtSource")
                                } else if (t.targetPosition.isEqual(e.deletionPosition)) {
                                    this._setRelation(t, e, "insertBetween")
                                } else if (t.targetPosition.isAfter(e.sourcePosition)) {
                                    this._setRelation(t, e, "moveTargetAfter")
                                }
                                break
                            }
                            case vm: {
                                if (t.targetPosition.isEqual(e.sourcePosition) || t.targetPosition.isBefore(e.sourcePosition)) {
                                    this._setRelation(t, e, "insertBefore")
                                } else {
                                    this._setRelation(t, e, "insertAfter")
                                }
                                break
                            }
                        }
                        break
                    }
                    case Sm: {
                        switch (e.constructor) {
                            case Em: {
                                if (t.splitPosition.isBefore(e.sourcePosition)) {
                                    this._setRelation(t, e, "splitBefore")
                                }
                                break
                            }
                            case vm: {
                                if (t.splitPosition.isEqual(e.sourcePosition) || t.splitPosition.isBefore(e.sourcePosition)) {
                                    this._setRelation(t, e, "splitBefore")
                                }
                                break
                            }
                        }
                        break
                    }
                    case Em: {
                        switch (e.constructor) {
                            case Em: {
                                if (!t.targetPosition.isEqual(e.sourcePosition)) {
                                    this._setRelation(t, e, "mergeTargetNotMoved")
                                }
                                if (t.sourcePosition.isEqual(e.targetPosition)) {
                                    this._setRelation(t, e, "mergeSourceNotMoved")
                                }
                                if (t.sourcePosition.isEqual(e.sourcePosition)) {
                                    this._setRelation(t, e, "mergeSameElement")
                                }
                                break
                            }
                            case Sm: {
                                if (t.sourcePosition.isEqual(e.splitPosition)) {
                                    this._setRelation(t, e, "splitAtSource")
                                }
                            }
                        }
                        break
                    }
                    case xm: {
                        const n = t.newRange;
                        if (!n) {
                            return
                        }
                        switch (e.constructor) {
                            case vm: {
                                const o = ef._createFromPositionAndShift(e.sourcePosition, e.howMany);
                                const i = o.containsPosition(n.start) || o.start.isEqual(n.start);
                                const r = o.containsPosition(n.end) || o.end.isEqual(n.end);
                                if ((i || r) && !o.containsRange(n)) {
                                    this._setRelation(t, e, {
                                        side: i ? "left" : "right",
                                        path: i ? n.start.path.slice() : n.end.path.slice()
                                    })
                                }
                                break
                            }
                            case Em: {
                                const o = n.start.isEqual(e.targetPosition);
                                const i = n.start.isEqual(e.deletionPosition);
                                const r = n.end.isEqual(e.deletionPosition);
                                const s = n.end.isEqual(e.sourcePosition);
                                if (o || i || r || s) {
                                    this._setRelation(t, e, {
                                        wasInLeftElement: o,
                                        wasStartBeforeMergedElement: i,
                                        wasEndBeforeMergedElement: r,
                                        wasInRightElement: s
                                    })
                                }
                                break
                            }
                        }
                        break
                    }
                }
            }
            getContext(t, e, n) {
                return {
                    aIsStrong: n,
                    aWasUndone: this._wasUndone(t),
                    bWasUndone: this._wasUndone(e),
                    abRelation: this._useRelations ? this._getRelation(t, e) : null,
                    baRelation: this._useRelations ? this._getRelation(e, t) : null,
                    forceWeakRemove: this._forceWeakRemove
                }
            }
            _wasUndone(t) {
                const e = this.originalOperations.get(t);
                return e.wasUndone || this._history.isUndoneOperation(e)
            }
            _getRelation(t, e) {
                const n = this.originalOperations.get(e);
                const o = this._history.getUndoneOperation(n);
                if (!o) {
                    return null
                }
                const i = this.originalOperations.get(t);
                const r = this._relations.get(i);
                if (r) {
                    return r.get(o) || null
                }
                return null
            }
            _setRelation(t, e, n) {
                const o = this.originalOperations.get(t);
                const i = this.originalOperations.get(e);
                let r = this._relations.get(o);
                if (!r) {
                    r = new Map;
                    this._relations.set(o, r)
                }
                r.set(i, n)
            }
        }

        function mC(t, e) {
            for (const n of t) {
                n.baseVersion = e++
            }
        }

        function gC(t, e) {
            for (let n = 0; n < e; n++) {
                t.push(new Jm(0))
            }
        }
        lC(Cm, Cm, ((t, e, n) => {
            if (t.key === e.key && t.range.start.hasSameParentAs(e.range.start)) {
                const o = t.range.getDifference(e.range).map((e => new Cm(e, t.key, t.oldValue, t.newValue, 0)));
                const i = t.range.getIntersection(e.range);
                if (i) {
                    if (n.aIsStrong) {
                        o.push(new Cm(i, e.key, e.newValue, t.newValue, 0))
                    }
                }
                if (o.length == 0) {
                    return [new Jm(0)]
                }
                return o
            } else {
                return [t]
            }
        }));
        lC(Cm, ym, ((t, e) => {
            if (t.range.start.hasSameParentAs(e.position) && t.range.containsPosition(e.position)) {
                const n = t.range._getTransformedByInsertion(e.position, e.howMany, !e.shouldReceiveAttributes);
                const o = n.map((e => new Cm(e, t.key, t.oldValue, t.newValue, t.baseVersion)));
                if (e.shouldReceiveAttributes) {
                    const n = kC(e, t.key, t.oldValue);
                    if (n) {
                        o.unshift(n)
                    }
                }
                return o
            }
            t.range = t.range._getTransformedByInsertion(e.position, e.howMany, false)[0];
            return [t]
        }));

        function kC(t, e, n) {
            const o = t.nodes;
            const i = o.getNode(0).getAttribute(e);
            if (i == n) {
                return null
            }
            const r = new ef(t.position, t.position.getShiftedBy(t.howMany));
            return new Cm(r, e, i, n, 0)
        }
        lC(Cm, Em, ((t, e) => {
            const n = [];
            if (t.range.start.hasSameParentAs(e.deletionPosition)) {
                if (t.range.containsPosition(e.deletionPosition) || t.range.start.isEqual(e.deletionPosition)) {
                    n.push(ef._createFromPositionAndShift(e.graveyardPosition, 1))
                }
            }
            const o = t.range._getTransformedByMergeOperation(e);
            if (!o.isCollapsed) {
                n.push(o)
            }
            return n.map((e => new Cm(e, t.key, t.oldValue, t.newValue, t.baseVersion)))
        }));
        lC(Cm, vm, ((t, e) => {
            const n = bC(t.range, e);
            return n.map((e => new Cm(e, t.key, t.oldValue, t.newValue, t.baseVersion)))
        }));

        function bC(t, e) {
            const n = ef._createFromPositionAndShift(e.sourcePosition, e.howMany);
            let o = null;
            let i = [];
            if (n.containsRange(t, true)) {
                o = t
            } else if (t.start.hasSameParentAs(n.start)) {
                i = t.getDifference(n);
                o = t.getIntersection(n)
            } else {
                i = [t]
            }
            const r = [];
            for (let t of i) {
                t = t._getTransformedByDeletion(e.sourcePosition, e.howMany);
                const n = e.getMovedRangeStart();
                const o = t.start.hasSameParentAs(n);
                t = t._getTransformedByInsertion(n, e.howMany, o);
                r.push(...t)
            }
            if (o) {
                r.push(o._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany, false)[0])
            }
            return r
        }
        lC(Cm, Sm, ((t, e) => {
            if (t.range.end.isEqual(e.insertionPosition)) {
                if (!e.graveyardPosition) {
                    t.range.end.offset++
                }
                return [t]
            }
            if (t.range.start.hasSameParentAs(e.splitPosition) && t.range.containsPosition(e.splitPosition)) {
                const n = t.clone();
                n.range = new ef(e.moveTargetPosition.clone(), t.range.end._getCombined(e.splitPosition, e.moveTargetPosition));
                t.range.end = e.splitPosition.clone();
                t.range.end.stickiness = "toPrevious";
                return [t, n]
            }
            t.range = t.range._getTransformedBySplitOperation(e);
            return [t]
        }));
        lC(ym, Cm, ((t, e) => {
            const n = [t];
            if (t.shouldReceiveAttributes && t.position.hasSameParentAs(e.range.start) && e.range.containsPosition(t.position)) {
                const o = kC(t, e.key, e.newValue);
                if (o) {
                    n.push(o)
                }
            }
            return n
        }));
        lC(ym, ym, ((t, e, n) => {
            if (t.position.isEqual(e.position) && n.aIsStrong) {
                return [t]
            }
            t.position = t.position._getTransformedByInsertOperation(e);
            return [t]
        }));
        lC(ym, vm, ((t, e) => {
            t.position = t.position._getTransformedByMoveOperation(e);
            return [t]
        }));
        lC(ym, Sm, ((t, e) => {
            t.position = t.position._getTransformedBySplitOperation(e);
            return [t]
        }));
        lC(ym, Em, ((t, e) => {
            t.position = t.position._getTransformedByMergeOperation(e);
            return [t]
        }));
        lC(xm, ym, ((t, e) => {
            if (t.oldRange) {
                t.oldRange = t.oldRange._getTransformedByInsertOperation(e)[0]
            }
            if (t.newRange) {
                t.newRange = t.newRange._getTransformedByInsertOperation(e)[0]
            }
            return [t]
        }));
        lC(xm, xm, ((t, e, n) => {
            if (t.name == e.name) {
                if (n.aIsStrong) {
                    t.oldRange = e.newRange ? e.newRange.clone() : null
                } else {
                    return [new Jm(0)]
                }
            }
            return [t]
        }));
        lC(xm, Em, ((t, e) => {
            if (t.oldRange) {
                t.oldRange = t.oldRange._getTransformedByMergeOperation(e)
            }
            if (t.newRange) {
                t.newRange = t.newRange._getTransformedByMergeOperation(e)
            }
            return [t]
        }));
        lC(xm, vm, ((t, e, n) => {
            if (t.oldRange) {
                t.oldRange = ef._createFromRanges(t.oldRange._getTransformedByMoveOperation(e))
            }
            if (t.newRange) {
                if (n.abRelation) {
                    const o = ef._createFromRanges(t.newRange._getTransformedByMoveOperation(e));
                    if (n.abRelation.side == "left" && e.targetPosition.isEqual(t.newRange.start)) {
                        t.newRange.start.path = n.abRelation.path;
                        t.newRange.end = o.end;
                        return [t]
                    } else if (n.abRelation.side == "right" && e.targetPosition.isEqual(t.newRange.end)) {
                        t.newRange.start = o.start;
                        t.newRange.end.path = n.abRelation.path;
                        return [t]
                    }
                }
                t.newRange = ef._createFromRanges(t.newRange._getTransformedByMoveOperation(e))
            }
            return [t]
        }));
        lC(xm, Sm, ((t, e, n) => {
            if (t.oldRange) {
                t.oldRange = t.oldRange._getTransformedBySplitOperation(e)
            }
            if (t.newRange) {
                if (n.abRelation) {
                    const o = t.newRange._getTransformedBySplitOperation(e);
                    if (t.newRange.start.isEqual(e.splitPosition) && n.abRelation.wasStartBeforeMergedElement) {
                        t.newRange.start = Zh._createAt(e.insertionPosition)
                    } else if (t.newRange.start.isEqual(e.splitPosition) && !n.abRelation.wasInLeftElement) {
                        t.newRange.start = Zh._createAt(e.moveTargetPosition)
                    }
                    if (t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasInRightElement) {
                        t.newRange.end = Zh._createAt(e.moveTargetPosition)
                    } else if (t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasEndBeforeMergedElement) {
                        t.newRange.end = Zh._createAt(e.insertionPosition)
                    } else {
                        t.newRange.end = o.end
                    }
                    return [t]
                }
                t.newRange = t.newRange._getTransformedBySplitOperation(e)
            }
            return [t]
        }));
        lC(Em, ym, ((t, e) => {
            if (t.sourcePosition.hasSameParentAs(e.position)) {
                t.howMany += e.howMany
            }
            t.sourcePosition = t.sourcePosition._getTransformedByInsertOperation(e);
            t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e);
            return [t]
        }));
        lC(Em, Em, ((t, e, n) => {
            if (t.sourcePosition.isEqual(e.sourcePosition) && t.targetPosition.isEqual(e.targetPosition)) {
                if (!n.bWasUndone) {
                    return [new Jm(0)]
                } else {
                    const n = e.graveyardPosition.path.slice();
                    n.push(0);
                    t.sourcePosition = new Zh(e.graveyardPosition.root, n);
                    t.howMany = 0;
                    return [t]
                }
            }
            if (t.sourcePosition.isEqual(e.sourcePosition) && !t.targetPosition.isEqual(e.targetPosition) && !n.bWasUndone && n.abRelation != "splitAtSource") {
                const o = t.targetPosition.root.rootName == "$graveyard";
                const i = e.targetPosition.root.rootName == "$graveyard";
                const r = o && !i;
                const s = i && !o;
                const a = s || !r && n.aIsStrong;
                if (a) {
                    const n = e.targetPosition._getTransformedByMergeOperation(e);
                    const o = t.targetPosition._getTransformedByMergeOperation(e);
                    return [new vm(n, t.howMany, o, 0)]
                } else {
                    return [new Jm(0)]
                }
            }
            if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
                t.howMany += e.howMany
            }
            t.sourcePosition = t.sourcePosition._getTransformedByMergeOperation(e);
            t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e);
            if (!t.graveyardPosition.isEqual(e.graveyardPosition) || !n.aIsStrong) {
                t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e)
            }
            return [t]
        }));
        lC(Em, vm, ((t, e, n) => {
            const o = ef._createFromPositionAndShift(e.sourcePosition, e.howMany);
            if (e.type == "remove" && !n.bWasUndone && !n.forceWeakRemove) {
                if (t.deletionPosition.hasSameParentAs(e.sourcePosition) && o.containsPosition(t.sourcePosition)) {
                    return [new Jm(0)]
                }
            }
            if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
                t.howMany += e.howMany
            }
            if (t.sourcePosition.hasSameParentAs(e.sourcePosition)) {
                t.howMany -= e.howMany
            }
            t.sourcePosition = t.sourcePosition._getTransformedByMoveOperation(e);
            t.targetPosition = t.targetPosition._getTransformedByMoveOperation(e);
            if (!t.graveyardPosition.isEqual(e.targetPosition)) {
                t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e)
            }
            return [t]
        }));
        lC(Em, Sm, ((t, e, n) => {
            if (e.graveyardPosition) {
                t.graveyardPosition = t.graveyardPosition._getTransformedByDeletion(e.graveyardPosition, 1);
                if (t.deletionPosition.isEqual(e.graveyardPosition)) {
                    t.howMany = e.howMany
                }
            }
            if (t.targetPosition.isEqual(e.splitPosition)) {
                const o = e.howMany != 0;
                const i = e.graveyardPosition && t.deletionPosition.isEqual(e.graveyardPosition);
                if (o || i || n.abRelation == "mergeTargetNotMoved") {
                    t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e);
                    return [t]
                }
            }
            if (t.sourcePosition.isEqual(e.splitPosition)) {
                if (n.abRelation == "mergeSourceNotMoved") {
                    t.howMany = 0;
                    t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e);
                    return [t]
                }
                if (n.abRelation == "mergeSameElement" || t.sourcePosition.offset > 0) {
                    t.sourcePosition = e.moveTargetPosition.clone();
                    t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e);
                    return [t]
                }
            }
            if (t.sourcePosition.hasSameParentAs(e.splitPosition)) {
                t.howMany = e.splitPosition.offset
            }
            t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e);
            t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e);
            return [t]
        }));
        lC(vm, ym, ((t, e) => {
            const n = ef._createFromPositionAndShift(t.sourcePosition, t.howMany);
            const o = n._getTransformedByInsertOperation(e, false)[0];
            t.sourcePosition = o.start;
            t.howMany = o.end.offset - o.start.offset;
            if (!t.targetPosition.isEqual(e.position)) {
                t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e)
            }
            return [t]
        }));
        lC(vm, vm, ((t, e, n) => {
            const o = ef._createFromPositionAndShift(t.sourcePosition, t.howMany);
            const i = ef._createFromPositionAndShift(e.sourcePosition, e.howMany);
            let r = n.aIsStrong;
            let s = !n.aIsStrong;
            if (n.abRelation == "insertBefore" || n.baRelation == "insertAfter") {
                s = true
            } else if (n.abRelation == "insertAfter" || n.baRelation == "insertBefore") {
                s = false
            }
            let a;
            if (t.targetPosition.isEqual(e.targetPosition) && s) {
                a = t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany)
            } else {
                a = t.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)
            }
            if (wC(t, e) && wC(e, t)) {
                return [e.getReversed()]
            }
            const c = o.containsPosition(e.targetPosition);
            if (c && o.containsRange(i, true)) {
                o.start = o.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
                o.end = o.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
                return AC([o], a)
            }
            const l = i.containsPosition(t.targetPosition);
            if (l && i.containsRange(o, true)) {
                o.start = o.start._getCombined(e.sourcePosition, e.getMovedRangeStart());
                o.end = o.end._getCombined(e.sourcePosition, e.getMovedRangeStart());
                return AC([o], a)
            }
            const d = Os(t.sourcePosition.getParentPath(), e.sourcePosition.getParentPath());
            if (d == "prefix" || d == "extension") {
                o.start = o.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
                o.end = o.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
                return AC([o], a)
            }
            if (t.type == "remove" && e.type != "remove" && !n.aWasUndone && !n.forceWeakRemove) {
                r = true
            } else if (t.type != "remove" && e.type == "remove" && !n.bWasUndone && !n.forceWeakRemove) {
                r = false
            }
            const u = [];
            const h = o.getDifference(i);
            for (const t of h) {
                t.start = t.start._getTransformedByDeletion(e.sourcePosition, e.howMany);
                t.end = t.end._getTransformedByDeletion(e.sourcePosition, e.howMany);
                const n = Os(t.start.getParentPath(), e.getMovedRangeStart().getParentPath()) == "same";
                const o = t._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, n);
                u.push(...o)
            }
            const f = o.getIntersection(i);
            if (f !== null && r) {
                f.start = f.start._getCombined(e.sourcePosition, e.getMovedRangeStart());
                f.end = f.end._getCombined(e.sourcePosition, e.getMovedRangeStart());
                if (u.length === 0) {
                    u.push(f)
                } else if (u.length == 1) {
                    if (i.start.isBefore(o.start) || i.start.isEqual(o.start)) {
                        u.unshift(f)
                    } else {
                        u.push(f)
                    }
                } else {
                    u.splice(1, 0, f)
                }
            }
            if (u.length === 0) {
                return [new Jm(t.baseVersion)]
            }
            return AC(u, a)
        }));
        lC(vm, Sm, ((t, e, n) => {
            let o = t.targetPosition.clone();
            if (!t.targetPosition.isEqual(e.insertionPosition) || !e.graveyardPosition || n.abRelation == "moveTargetAfter") {
                o = t.targetPosition._getTransformedBySplitOperation(e)
            }
            const i = ef._createFromPositionAndShift(t.sourcePosition, t.howMany);
            if (i.end.isEqual(e.insertionPosition)) {
                if (!e.graveyardPosition) {
                    t.howMany++
                }
                t.targetPosition = o;
                return [t]
            }
            if (i.start.hasSameParentAs(e.splitPosition) && i.containsPosition(e.splitPosition)) {
                let t = new ef(e.splitPosition, i.end);
                t = t._getTransformedBySplitOperation(e);
                const n = [new ef(i.start, e.splitPosition), t];
                return AC(n, o)
            }
            if (t.targetPosition.isEqual(e.splitPosition) && n.abRelation == "insertAtSource") {
                o = e.moveTargetPosition
            }
            if (t.targetPosition.isEqual(e.insertionPosition) && n.abRelation == "insertBetween") {
                o = t.targetPosition
            }
            const r = i._getTransformedBySplitOperation(e);
            const s = [r];
            if (e.graveyardPosition) {
                const o = i.start.isEqual(e.graveyardPosition) || i.containsPosition(e.graveyardPosition);
                if (t.howMany > 1 && o && !n.aWasUndone) {
                    s.push(ef._createFromPositionAndShift(e.insertionPosition, 1))
                }
            }
            return AC(s, o)
        }));
        lC(vm, Em, ((t, e, n) => {
            const o = ef._createFromPositionAndShift(t.sourcePosition, t.howMany);
            if (e.deletionPosition.hasSameParentAs(t.sourcePosition) && o.containsPosition(e.sourcePosition)) {
                if (t.type == "remove" && !n.forceWeakRemove) {
                    if (!n.aWasUndone) {
                        const n = [];
                        let o = e.graveyardPosition.clone();
                        let i = e.targetPosition._getTransformedByMergeOperation(e);
                        if (t.howMany > 1) {
                            n.push(new vm(t.sourcePosition, t.howMany - 1, t.targetPosition, 0));
                            o = o._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1);
                            i = i._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1)
                        }
                        const r = e.deletionPosition._getCombined(t.sourcePosition, t.targetPosition);
                        const s = new vm(o, 1, r, 0);
                        const a = s.getMovedRangeStart().path.slice();
                        a.push(0);
                        const c = new Zh(s.targetPosition.root, a);
                        i = i._getTransformedByMove(o, r, 1);
                        const l = new vm(i, e.howMany, c, 0);
                        n.push(s);
                        n.push(l);
                        return n
                    }
                } else {
                    if (t.howMany == 1) {
                        if (!n.bWasUndone) {
                            return [new Jm(0)]
                        } else {
                            t.sourcePosition = e.graveyardPosition.clone();
                            t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e);
                            return [t]
                        }
                    }
                }
            }
            const i = ef._createFromPositionAndShift(t.sourcePosition, t.howMany);
            const r = i._getTransformedByMergeOperation(e);
            t.sourcePosition = r.start;
            t.howMany = r.end.offset - r.start.offset;
            t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e);
            return [t]
        }));
        lC(Dm, ym, ((t, e) => {
            t.position = t.position._getTransformedByInsertOperation(e);
            return [t]
        }));
        lC(Dm, Em, ((t, e) => {
            if (t.position.isEqual(e.deletionPosition)) {
                t.position = e.graveyardPosition.clone();
                t.position.stickiness = "toNext";
                return [t]
            }
            t.position = t.position._getTransformedByMergeOperation(e);
            return [t]
        }));
        lC(Dm, vm, ((t, e) => {
            t.position = t.position._getTransformedByMoveOperation(e);
            return [t]
        }));
        lC(Dm, Dm, ((t, e, n) => {
            if (t.position.isEqual(e.position)) {
                if (n.aIsStrong) {
                    t.oldName = e.newName
                } else {
                    return [new Jm(0)]
                }
            }
            return [t]
        }));
        lC(Dm, Sm, ((t, e) => {
            const n = t.position.path;
            const o = e.splitPosition.getParentPath();
            if (Os(n, o) == "same" && !e.graveyardPosition) {
                const e = new Dm(t.position.getShiftedBy(1), t.oldName, t.newName, 0);
                return [t, e]
            }
            t.position = t.position._getTransformedBySplitOperation(e);
            return [t]
        }));
        lC(Mm, Mm, ((t, e, n) => {
            if (t.root === e.root && t.key === e.key) {
                if (!n.aIsStrong || t.newValue === e.newValue) {
                    return [new Jm(0)]
                } else {
                    t.oldValue = e.newValue
                }
            }
            return [t]
        }));
        lC(Sm, ym, ((t, e) => {
            if (t.splitPosition.hasSameParentAs(e.position) && t.splitPosition.offset < e.position.offset) {
                t.howMany += e.howMany
            }
            t.splitPosition = t.splitPosition._getTransformedByInsertOperation(e);
            t.insertionPosition = Sm.getInsertionPosition(t.splitPosition);
            return [t]
        }));
        lC(Sm, Em, ((t, e, n) => {
            if (!t.graveyardPosition && !n.bWasUndone && t.splitPosition.hasSameParentAs(e.sourcePosition)) {
                const n = e.graveyardPosition.path.slice();
                n.push(0);
                const o = new Zh(e.graveyardPosition.root, n);
                const i = Sm.getInsertionPosition(new Zh(e.graveyardPosition.root, n));
                const r = new Sm(o, 0, null, 0);
                r.insertionPosition = i;
                t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e);
                t.insertionPosition = Sm.getInsertionPosition(t.splitPosition);
                t.graveyardPosition = r.insertionPosition.clone();
                t.graveyardPosition.stickiness = "toNext";
                return [r, t]
            }
            if (t.splitPosition.hasSameParentAs(e.deletionPosition) && !t.splitPosition.isAfter(e.deletionPosition)) {
                t.howMany--
            }
            if (t.splitPosition.hasSameParentAs(e.targetPosition)) {
                t.howMany += e.howMany
            }
            t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e);
            t.insertionPosition = Sm.getInsertionPosition(t.splitPosition);
            if (t.graveyardPosition) {
                t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e)
            }
            return [t]
        }));
        lC(Sm, vm, ((t, e, n) => {
            const o = ef._createFromPositionAndShift(e.sourcePosition, e.howMany);
            if (t.graveyardPosition) {
                const i = o.start.isEqual(t.graveyardPosition) || o.containsPosition(t.graveyardPosition);
                if (!n.bWasUndone && i) {
                    const n = t.splitPosition._getTransformedByMoveOperation(e);
                    const o = t.graveyardPosition._getTransformedByMoveOperation(e);
                    const i = o.path.slice();
                    i.push(0);
                    const r = new Zh(o.root, i);
                    const s = new vm(n, t.howMany, r, 0);
                    return [s]
                }
                t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e)
            }
            if (t.splitPosition.hasSameParentAs(e.sourcePosition) && o.containsPosition(t.splitPosition)) {
                const n = e.howMany - (t.splitPosition.offset - e.sourcePosition.offset);
                t.howMany -= n;
                if (t.splitPosition.hasSameParentAs(e.targetPosition) && t.splitPosition.offset < e.targetPosition.offset) {
                    t.howMany += e.howMany
                }
                t.splitPosition = e.sourcePosition.clone();
                t.insertionPosition = Sm.getInsertionPosition(t.splitPosition);
                return [t]
            }
            const i = t.splitPosition.isEqual(e.targetPosition);
            if (i && (n.baRelation == "insertAtSource" || n.abRelation == "splitBefore")) {
                t.howMany += e.howMany;
                t.splitPosition = t.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany);
                t.insertionPosition = Sm.getInsertionPosition(t.splitPosition);
                return [t]
            }
            if (!e.sourcePosition.isEqual(e.targetPosition)) {
                if (t.splitPosition.hasSameParentAs(e.sourcePosition) && t.splitPosition.offset <= e.sourcePosition.offset) {
                    t.howMany -= e.howMany
                }
                if (t.splitPosition.hasSameParentAs(e.targetPosition) && t.splitPosition.offset < e.targetPosition.offset) {
                    t.howMany += e.howMany
                }
            }
            t.splitPosition.stickiness = "toNone";
            t.splitPosition = t.splitPosition._getTransformedByMoveOperation(e);
            t.splitPosition.stickiness = "toNext";
            if (t.graveyardPosition) {
                t.insertionPosition = t.insertionPosition._getTransformedByMoveOperation(e)
            } else {
                t.insertionPosition = Sm.getInsertionPosition(t.splitPosition)
            }
            return [t]
        }));
        lC(Sm, Sm, ((t, e, n) => {
            if (t.splitPosition.isEqual(e.splitPosition)) {
                if (!t.graveyardPosition && !e.graveyardPosition) {
                    return [new Jm(0)]
                }
                if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition)) {
                    return [new Jm(0)]
                }
                if (n.abRelation == "splitBefore") {
                    t.howMany = 0;
                    t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e);
                    return [t]
                }
            }
            if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition)) {
                const o = t.splitPosition.root.rootName == "$graveyard";
                const i = e.splitPosition.root.rootName == "$graveyard";
                const r = o && !i;
                const s = i && !o;
                const a = s || !r && n.aIsStrong;
                if (a) {
                    const n = [];
                    if (e.howMany) {
                        n.push(new vm(e.moveTargetPosition, e.howMany, e.splitPosition, 0))
                    }
                    if (t.howMany) {
                        n.push(new vm(t.splitPosition, t.howMany, t.moveTargetPosition, 0))
                    }
                    return n
                } else {
                    return [new Jm(0)]
                }
            }
            if (t.graveyardPosition) {
                t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e)
            }
            if (t.splitPosition.isEqual(e.insertionPosition) && n.abRelation == "splitBefore") {
                t.howMany++;
                return [t]
            }
            if (e.splitPosition.isEqual(t.insertionPosition) && n.baRelation == "splitBefore") {
                const n = e.insertionPosition.path.slice();
                n.push(0);
                const o = new Zh(e.insertionPosition.root, n);
                const i = new vm(t.insertionPosition, 1, o, 0);
                return [t, i]
            }
            if (t.splitPosition.hasSameParentAs(e.splitPosition) && t.splitPosition.offset < e.splitPosition.offset) {
                t.howMany -= e.howMany
            }
            t.splitPosition = t.splitPosition._getTransformedBySplitOperation(e);
            t.insertionPosition = Sm.getInsertionPosition(t.splitPosition);
            return [t]
        }));

        function wC(t, e) {
            return t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) === null
        }

        function AC(t, e) {
            const n = [];
            for (let o = 0; o < t.length; o++) {
                const i = t[o];
                const r = new vm(i.start, i.end.offset - i.start.offset, e, 0);
                n.push(r);
                for (let e = o + 1; e < t.length; e++) {
                    t[e] = t[e]._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany)[0]
                }
                e = e._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany)
            }
            return n
        }
        class CC extends iA {
            constructor(t) {
                super(t);
                this._stack = [];
                this._createdBatches = new WeakSet;
                this.refresh();
                this.listenTo(t.data, "set", (() => this.clearStack()))
            }
            refresh() {
                this.isEnabled = this._stack.length > 0
            }
            addBatch(t) {
                const e = this.editor.model.document.selection;
                const n = {
                    ranges: e.hasOwnRange ? Array.from(e.getRanges()) : [],
                    isBackward: e.isBackward
                };
                this._stack.push({
                    batch: t,
                    selection: n
                });
                this.refresh()
            }
            clearStack() {
                this._stack = [];
                this.refresh()
            }
            _restoreSelection(t, e, n) {
                const o = this.editor.model;
                const i = o.document;
                const r = [];
                const s = t.map((t => t.getTransformedByOperations(n)));
                const a = s.flat();
                for (const t of s) {
                    const e = t.filter((t => t.root != i.graveyard)).filter((t => !vC(t, a)));
                    if (!e.length) {
                        continue
                    }
                    _C(e);
                    r.push(e[0])
                }
                if (r.length) {
                    o.change((t => {
                        t.setSelection(r, {
                            backward: e
                        })
                    }))
                }
            }
            _undo(t, e) {
                const n = this.editor.model;
                const o = n.document;
                this._createdBatches.add(e);
                const i = t.operations.slice().filter((t => t.isDocumentOperation));
                i.reverse();
                for (const t of i) {
                    const i = t.baseVersion + 1;
                    const r = Array.from(o.history.getOperations(i));
                    const s = fC([t.getReversed()], r, {
                        useRelations: true,
                        document: this.editor.model.document,
                        padWithNoOps: false,
                        forceWeakRemove: true
                    });
                    const a = s.operationsA;
                    for (const i of a) {
                        e.addOperation(i);
                        n.applyOperation(i);
                        o.history.setOperationAsUndone(t, i)
                    }
                }
            }
        }

        function _C(t) {
            t.sort(((t, e) => t.start.isBefore(e.start) ? -1 : 1));
            for (let e = 1; e < t.length; e++) {
                const n = t[e - 1];
                const o = n.getJoined(t[e], true);
                if (o) {
                    e--;
                    t.splice(e, 2, o)
                }
            }
        }

        function vC(t, e) {
            return e.some((e => e !== t && e.containsRange(t, true)))
        }
        class yC extends CC {
            execute(t = null) {
                const e = t ? this._stack.findIndex((e => e.batch == t)) : this._stack.length - 1;
                const n = this._stack.splice(e, 1)[0];
                const o = this.editor.model.createBatch("transparent");
                this.editor.model.enqueueChange(o, (() => {
                    this._undo(n.batch, o);
                    const t = this.editor.model.document.history.getOperations(n.batch.baseVersion);
                    this._restoreSelection(n.selection.ranges, n.selection.isBackward, t);
                    this.fire("revert", n.batch, o)
                }));
                this.refresh()
            }
        }
        class xC extends CC {
            execute() {
                const t = this._stack.pop();
                const e = this.editor.model.createBatch("transparent");
                this.editor.model.enqueueChange(e, (() => {
                    const n = t.batch.operations[t.batch.operations.length - 1];
                    const o = n.baseVersion + 1;
                    const i = this.editor.model.document.history.getOperations(o);
                    this._restoreSelection(t.selection.ranges, t.selection.isBackward, i);
                    this._undo(t.batch, e)
                }));
                this.refresh()
            }
        }
        class DC extends nA {
            static get pluginName() {
                return "UndoEditing"
            }
            constructor(t) {
                super(t);
                this._batchRegistry = new WeakSet
            }
            init() {
                const t = this.editor;
                this._undoCommand = new yC(t);
                this._redoCommand = new xC(t);
                t.commands.add("undo", this._undoCommand);
                t.commands.add("redo", this._redoCommand);
                this.listenTo(t.model, "applyOperation", ((t, e) => {
                    const n = e[0];
                    if (!n.isDocumentOperation) {
                        return
                    }
                    const o = n.batch;
                    const i = this._redoCommand._createdBatches.has(o);
                    const r = this._undoCommand._createdBatches.has(o);
                    const s = this._batchRegistry.has(o);
                    if (s || o.type == "transparent" && !i && !r) {
                        return
                    } else {
                        if (i) {
                            this._undoCommand.addBatch(o)
                        } else if (!r) {
                            this._undoCommand.addBatch(o);
                            this._redoCommand.clearStack()
                        }
                    }
                    this._batchRegistry.add(o)
                }), {
                    priority: "highest"
                });
                this.listenTo(this._undoCommand, "revert", ((t, e, n) => {
                    this._redoCommand.addBatch(n)
                }));
                t.keystrokes.set("CTRL+Z", "undo");
                t.keystrokes.set("CTRL+Y", "redo");
                t.keystrokes.set("CTRL+SHIFT+Z", "redo")
            }
        }
        var MC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.042 9.367l2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>';
        var EC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M14.958 9.367l-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
        class SC extends nA {
            init() {
                const t = this.editor;
                const e = t.locale;
                const n = t.t;
                const o = e.uiLanguageDirection == "ltr" ? MC : EC;
                const i = e.uiLanguageDirection == "ltr" ? EC : MC;
                this._addButton("undo", n("Undo"), "CTRL+Z", o);
                this._addButton("redo", n("Redo"), "CTRL+Y", i)
            }
            _addButton(t, e, n, o) {
                const i = this.editor;
                i.ui.componentFactory.add(t, (r => {
                    const s = i.commands.get(t);
                    const a = new cw(r);
                    a.set({
                        label: e,
                        icon: o,
                        keystroke: n,
                        tooltip: true
                    });
                    a.bind("isEnabled").to(s, "isEnabled");
                    this.listenTo(a, "execute", (() => {
                        i.execute(t);
                        i.editing.view.focus()
                    }));
                    return a
                }))
            }
        }
        class TC extends nA {
            static get requires() {
                return [DC, SC]
            }
            static get pluginName() {
                return "Undo"
            }
        }
        class IC extends nA {
            static get requires() {
                return [_A, SA, UA, LA, aC, TC]
            }
            static get pluginName() {
                return "Essentials"
            }
        }
        class NC extends iA {
            constructor(t, e) {
                super(t);
                this.attributeKey = e
            }
            refresh() {
                const t = this.editor.model;
                const e = t.document;
                this.value = e.selection.getAttribute(this.attributeKey);
                this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey)
            }
            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                const o = n.selection;
                const i = t.value;
                e.change((t => {
                    if (o.isCollapsed) {
                        if (i) {
                            t.setSelectionAttribute(this.attributeKey, i)
                        } else {
                            t.removeSelectionAttribute(this.attributeKey)
                        }
                    } else {
                        const n = e.schema.getValidRanges(o.getRanges(), this.attributeKey);
                        for (const e of n) {
                            if (i) {
                                t.setAttribute(this.attributeKey, i, e)
                            } else {
                                t.removeAttribute(this.attributeKey, e)
                            }
                        }
                    }
                }))
            }
        }
        var PC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0z"/><path d="M14.814 6.035L8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z"/></svg>';
        class BC extends cw {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("color");
                this.set("hasBorder");
                this.icon = PC;
                this.extendTemplate({
                    attributes: {
                        style: {
                            backgroundColor: e.to("color")
                        },
                        class: ["ck", "ck-color-grid__tile", e.if("hasBorder", "ck-color-table__color-tile_bordered")]
                    }
                })
            }
            render() {
                super.render();
                this.iconView.fillColor = "hsl(0, 0%, 100%)"
            }
        }
        var LC = n(27);
        var OC = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        OC.insert = "head";
        OC.singleton = true;
        var zC = rk()(LC["a"], OC);
        var jC = LC["a"].locals || {};
        class FC extends tb {
            constructor(t, e) {
                super(t);
                const n = e && e.colorDefinitions || [];
                const o = {};
                if (e && e.columns) {
                    o.gridTemplateColumns = `repeat( ${e.columns}, 1fr)`
                }
                this.set("selectedColor");
                this.items = this.createCollection();
                this.focusTracker = new tk;
                this.keystrokes = new Vg;
                this._focusCycler = new Db({
                    focusables: this.items,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {
                        focusPrevious: "arrowleft",
                        focusNext: "arrowright"
                    }
                });
                this.items.on("add", ((t, e) => {
                    e.isOn = e.color === this.selectedColor
                }));
                n.forEach((t => {
                    const e = new BC;
                    e.set({
                        color: t.color,
                        label: t.label,
                        tooltip: true,
                        hasBorder: t.options.hasBorder
                    });
                    e.on("execute", (() => {
                        this.fire("execute", {
                            value: t.color,
                            hasBorder: t.options.hasBorder,
                            label: t.label
                        })
                    }));
                    this.items.add(e)
                }));
                this.setTemplate({
                    tag: "div",
                    children: this.items,
                    attributes: {
                        class: ["ck", "ck-color-grid"],
                        style: o
                    }
                });
                this.on("change:selectedColor", ((t, e, n) => {
                    for (const t of this.items) {
                        t.isOn = t.color === n
                    }
                }))
            }
            focus() {
                if (this.items.length) {
                    this.items.first.focus()
                }
            }
            focusLast() {
                if (this.items.length) {
                    this.items.last.focus()
                }
            }
            render() {
                super.render();
                for (const t of this.items) {
                    this.focusTracker.add(t.element)
                }
                this.items.on("add", ((t, e) => {
                    this.focusTracker.add(e.element)
                }));
                this.items.on("remove", ((t, e) => {
                    this.focusTracker.remove(e.element)
                }));
                this.keystrokes.listenTo(this.element)
            }
        }
        class RC extends vs {
            constructor(t) {
                super(t);
                this.set("isEmpty", true);
                this.on("change", (() => {
                    this.set("isEmpty", this.length === 0)
                }))
            }
            add(t, e) {
                if (this.find((e => e.color === t.color))) {
                    return
                }
                super.add(t, e)
            }
            hasColor(t) {
                return !!this.find((e => e.color === t))
            }
        }
        _s(RC, Zc);
        var VC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.636 9.531l-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>';
        var UC = n(28);
        var GC = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        GC.insert = "head";
        GC.singleton = true;
        var KC = rk()(UC["a"], GC);
        var YC = UC["a"].locals || {};
        class HC extends tb {
            constructor(t, {
                colors: e,
                columns: n,
                removeButtonLabel: o,
                documentColorsLabel: i,
                documentColorsCount: r
            }) {
                super(t);
                this.items = this.createCollection();
                this.colorDefinitions = e;
                this.focusTracker = new tk;
                this.keystrokes = new Vg;
                this.set("selectedColor");
                this.removeButtonLabel = o;
                this.columns = n;
                this.documentColors = new RC;
                this.documentColorsCount = r;
                this._focusCycler = new Db({
                    focusables: this.items,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {
                        focusPrevious: "arrowup",
                        focusNext: "arrowdown"
                    }
                });
                this._documentColorsLabel = i;
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-color-table"]
                    },
                    children: this.items
                });
                this.items.add(this._removeColorButton())
            }
            updateDocumentColors(t, e) {
                const n = t.document;
                const o = this.documentColorsCount;
                this.documentColors.clear();
                for (const i of n.getRootNames()) {
                    const r = n.getRoot(i);
                    const s = t.createRangeIn(r);
                    for (const t of s.getItems()) {
                        if (t.is("$textProxy") && t.hasAttribute(e)) {
                            this._addColorToDocumentColors(t.getAttribute(e));
                            if (this.documentColors.length >= o) {
                                return
                            }
                        }
                    }
                }
            }
            updateSelectedColors() {
                const t = this.documentColorsGrid;
                const e = this.staticColorsGrid;
                const n = this.selectedColor;
                e.selectedColor = n;
                if (t) {
                    t.selectedColor = n
                }
            }
            render() {
                super.render();
                for (const t of this.items) {
                    this.focusTracker.add(t.element)
                }
                this.keystrokes.listenTo(this.element)
            }
            appendGrids() {
                if (this.staticColorsGrid) {
                    return
                }
                this.staticColorsGrid = this._createStaticColorsGrid();
                this.items.add(this.staticColorsGrid);
                if (this.documentColorsCount) {
                    const t = yk.bind(this.documentColors, this.documentColors);
                    const e = new mb(this.locale);
                    e.text = this._documentColorsLabel;
                    e.extendTemplate({
                        attributes: {
                            class: ["ck", "ck-color-grid__label", t.if("isEmpty", "ck-hidden")]
                        }
                    });
                    this.items.add(e);
                    this.documentColorsGrid = this._createDocumentColorsGrid();
                    this.items.add(this.documentColorsGrid)
                }
            }
            focus() {
                this._focusCycler.focusFirst()
            }
            focusLast() {
                this._focusCycler.focusLast()
            }
            _removeColorButton() {
                const t = new cw;
                t.set({
                    withText: true,
                    icon: VC,
                    tooltip: true,
                    label: this.removeButtonLabel
                });
                t.class = "ck-color-table__remove-color";
                t.on("execute", (() => {
                    this.fire("execute", {
                        value: null
                    })
                }));
                return t
            }
            _createStaticColorsGrid() {
                const t = new FC(this.locale, {
                    colorDefinitions: this.colorDefinitions,
                    columns: this.columns
                });
                t.delegate("execute").to(this);
                return t
            }
            _createDocumentColorsGrid() {
                const t = yk.bind(this.documentColors, this.documentColors);
                const e = new FC(this.locale, {
                    columns: this.columns
                });
                e.delegate("execute").to(this);
                e.extendTemplate({
                    attributes: {
                        class: t.if("isEmpty", "ck-hidden")
                    }
                });
                e.items.bindTo(this.documentColors).using((t => {
                    const e = new BC;
                    e.set({
                        color: t.color,
                        hasBorder: t.options && t.options.hasBorder
                    });
                    if (t.label) {
                        e.set({
                            label: t.label,
                            tooltip: true
                        })
                    }
                    e.on("execute", (() => {
                        this.fire("execute", {
                            value: t.color
                        })
                    }));
                    return e
                }));
                this.documentColors.on("change:isEmpty", ((t, n, o) => {
                    if (o) {
                        e.selectedColor = null
                    }
                }));
                return e
            }
            _addColorToDocumentColors(t) {
                const e = this.colorDefinitions.find((e => e.color === t));
                if (!e) {
                    this.documentColors.add({
                        color: t,
                        label: t,
                        options: {
                            hasBorder: false
                        }
                    })
                } else {
                    this.documentColors.add(Object.assign({}, e))
                }
            }
        }
        const qC = "fontSize";
        const WC = "fontFamily";
        const QC = "fontColor";
        const $C = "fontBackgroundColor";

        function ZC(t, e) {
            const n = {
                model: {
                    key: t,
                    values: []
                },
                view: {},
                upcastAlso: {}
            };
            for (const t of e) {
                n.model.values.push(t.model);
                n.view[t.model] = t.view;
                if (t.upcastAlso) {
                    n.upcastAlso[t.model] = t.upcastAlso
                }
            }
            return n
        }

        function JC(t) {
            return e => e_(e.getStyle(t))
        }

        function XC(t) {
            return (e, {
                writer: n
            }) => n.createAttributeElement("span", {
                style: `${t}:${e}`
            }, {
                priority: 7
            })
        }

        function t_({
            dropdownView: t,
            colors: e,
            columns: n,
            removeButtonLabel: o,
            documentColorsLabel: i,
            documentColorsCount: r
        }) {
            const s = t.locale;
            const a = new HC(s, {
                colors: e,
                columns: n,
                removeButtonLabel: o,
                documentColorsLabel: i,
                documentColorsCount: r
            });
            t.colorTableView = a;
            t.panelView.children.add(a);
            a.delegate("execute").to(t, "execute");
            return a
        }

        function e_(t) {
            return t.replace(/\s/g, "")
        }
        class n_ extends NC {
            constructor(t) {
                super(t, $C)
            }
        }
        const o_ = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;
        const i_ = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i;
        const r_ = /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i;
        const s_ = /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i;
        const a_ = /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i;
        const c_ = new Set(["black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia", "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua", "orange", "aliceblue", "antiquewhite", "aquamarine", "azure", "beige", "bisque", "blanchedalmond", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "gainsboro", "ghostwhite", "gold", "goldenrod", "greenyellow", "grey", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "limegreen", "linen", "magenta", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "oldlace", "olivedrab", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "thistle", "tomato", "turquoise", "violet", "wheat", "whitesmoke", "yellowgreen", "rebeccapurple", "currentcolor", "transparent"]);

        function l_(t) {
            if (t.startsWith("#")) {
                return o_.test(t)
            }
            if (t.startsWith("rgb")) {
                return i_.test(t) || r_.test(t)
            }
            if (t.startsWith("hsl")) {
                return s_.test(t) || a_.test(t)
            }
            return c_.has(t.toLowerCase())
        }
        const d_ = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"];

        function u_(t) {
            return d_.includes(t)
        }
        const h_ = /^([+-]?[0-9]*[.]?[0-9]+(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/;

        function f_(t) {
            return h_.test(t)
        }
        const p_ = /^[+-]?[0-9]*[.]?[0-9]+%$/;

        function m_(t) {
            return p_.test(t)
        }
        const g_ = ["repeat-x", "repeat-y", "repeat", "space", "round", "no-repeat"];

        function k_(t) {
            return g_.includes(t)
        }
        const b_ = ["center", "top", "bottom", "left", "right"];

        function w_(t) {
            return b_.includes(t)
        }
        const A_ = ["fixed", "scroll", "local"];

        function C_(t) {
            return A_.includes(t)
        }
        const __ = /^url\(/;

        function v_(t) {
            return __.test(t)
        }

        function y_(t = "") {
            if (t === "") {
                return {
                    top: undefined,
                    right: undefined,
                    bottom: undefined,
                    left: undefined
                }
            }
            const e = E_(t);
            const n = e[0];
            const o = e[2] || n;
            const i = e[1] || n;
            const r = e[3] || i;
            return {
                top: n,
                bottom: o,
                right: i,
                left: r
            }
        }

        function x_(t) {
            return e => {
                const {
                    top: n,
                    right: o,
                    bottom: i,
                    left: r
                } = e;
                const s = [];
                if (![n, o, r, i].every((t => !!t))) {
                    if (n) {
                        s.push([t + "-top", n])
                    }
                    if (o) {
                        s.push([t + "-right", o])
                    }
                    if (i) {
                        s.push([t + "-bottom", i])
                    }
                    if (r) {
                        s.push([t + "-left", r])
                    }
                } else {
                    s.push([t, D_(e)])
                }
                return s
            }
        }

        function D_({
            top: t,
            right: e,
            bottom: n,
            left: o
        }) {
            const i = [];
            if (o !== e) {
                i.push(t, e, n, o)
            } else if (n !== t) {
                i.push(t, e, n)
            } else if (e !== t) {
                i.push(t, e)
            } else {
                i.push(t)
            }
            return i.join(" ")
        }

        function M_(t) {
            return e => ({
                path: t,
                value: y_(e)
            })
        }

        function E_(t) {
            return t.replace(/, /g, ",").split(" ").map((t => t.replace(/,/g, ", ")))
        }

        function S_(t) {
            t.setNormalizer("background", T_);
            t.setNormalizer("background-color", (t => ({
                path: "background.color",
                value: t
            })));
            t.setReducer("background", (t => {
                const e = [];
                e.push(["background-color", t.color]);
                return e
            }))
        }

        function T_(t) {
            const e = {};
            const n = E_(t);
            for (const t of n) {
                if (k_(t)) {
                    e.repeat = e.repeat || [];
                    e.repeat.push(t)
                } else if (w_(t)) {
                    e.position = e.position || [];
                    e.position.push(t)
                } else if (C_(t)) {
                    e.attachment = t
                } else if (l_(t)) {
                    e.color = t
                } else if (v_(t)) {
                    e.image = t
                }
            }
            return {
                path: "background",
                value: e
            }
        }
        class I_ extends nA {
            static get pluginName() {
                return "FontBackgroundColorEditing"
            }
            constructor(t) {
                super(t);
                t.config.define($C, {
                    colors: [{
                        color: "hsl(0, 0%, 0%)",
                        label: "Black"
                    }, {
                        color: "hsl(0, 0%, 30%)",
                        label: "Dim grey"
                    }, {
                        color: "hsl(0, 0%, 60%)",
                        label: "Grey"
                    }, {
                        color: "hsl(0, 0%, 90%)",
                        label: "Light grey"
                    }, {
                        color: "hsl(0, 0%, 100%)",
                        label: "White",
                        hasBorder: true
                    }, {
                        color: "hsl(0, 75%, 60%)",
                        label: "Red"
                    }, {
                        color: "hsl(30, 75%, 60%)",
                        label: "Orange"
                    }, {
                        color: "hsl(60, 75%, 60%)",
                        label: "Yellow"
                    }, {
                        color: "hsl(90, 75%, 60%)",
                        label: "Light green"
                    }, {
                        color: "hsl(120, 75%, 60%)",
                        label: "Green"
                    }, {
                        color: "hsl(150, 75%, 60%)",
                        label: "Aquamarine"
                    }, {
                        color: "hsl(180, 75%, 60%)",
                        label: "Turquoise"
                    }, {
                        color: "hsl(210, 75%, 60%)",
                        label: "Light blue"
                    }, {
                        color: "hsl(240, 75%, 60%)",
                        label: "Blue"
                    }, {
                        color: "hsl(270, 75%, 60%)",
                        label: "Purple"
                    }],
                    columns: 5
                });
                t.data.addStyleProcessorRules(S_);
                t.conversion.for("upcast").elementToAttribute({
                    view: {
                        name: "span",
                        styles: {
                            "background-color": /[\s\S]+/
                        }
                    },
                    model: {
                        key: $C,
                        value: JC("background-color")
                    }
                });
                t.conversion.for("downcast").attributeToElement({
                    model: $C,
                    view: XC("background-color")
                });
                t.commands.add($C, new n_(t));
                t.model.schema.extend("$text", {
                    allowAttributes: $C
                });
                t.model.schema.setAttributeProperties($C, {
                    isFormatting: true,
                    copyOnEnter: true
                })
            }
        }

        function N_(t, e) {
            const n = t.t;
            const o = {
                Black: n("Black"),
                "Dim grey": n("Dim grey"),
                Grey: n("Grey"),
                "Light grey": n("Light grey"),
                White: n("White"),
                Red: n("Red"),
                Orange: n("Orange"),
                Yellow: n("Yellow"),
                "Light green": n("Light green"),
                Green: n("Green"),
                Aquamarine: n("Aquamarine"),
                Turquoise: n("Turquoise"),
                "Light blue": n("Light blue"),
                Blue: n("Blue"),
                Purple: n("Purple")
            };
            return e.map((t => {
                const e = o[t.label];
                if (e && e != t.label) {
                    t.label = e
                }
                return t
            }))
        }

        function P_(t) {
            return t.map(B_).filter((t => !!t))
        }

        function B_(t) {
            if (typeof t === "string") {
                return {
                    model: t,
                    label: t,
                    hasBorder: false,
                    view: {
                        name: "span",
                        styles: {
                            color: t
                        }
                    }
                }
            } else {
                return {
                    model: t.color,
                    label: t.label || t.color,
                    hasBorder: t.hasBorder === undefined ? false : t.hasBorder,
                    view: {
                        name: "span",
                        styles: {
                            color: `${t.color}`
                        }
                    }
                }
            }
        }
        class L_ extends nA {
            constructor(t, {
                commandName: e,
                icon: n,
                componentName: o,
                dropdownLabel: i
            }) {
                super(t);
                this.commandName = e;
                this.componentName = o;
                this.icon = n;
                this.dropdownLabel = i;
                this.columns = t.config.get(`${this.componentName}.columns`);
                this.colorTableView = undefined
            }
            init() {
                const t = this.editor;
                const e = t.locale;
                const n = e.t;
                const o = t.commands.get(this.commandName);
                const i = P_(t.config.get(this.componentName).colors);
                const r = N_(e, i);
                const s = t.config.get(`${this.componentName}.documentColors`);
                t.ui.componentFactory.add(this.componentName, (e => {
                    const i = Nw(e);
                    this.colorTableView = t_({
                        dropdownView: i,
                        colors: r.map((t => ({
                            label: t.label,
                            color: t.model,
                            options: {
                                hasBorder: t.hasBorder
                            }
                        }))),
                        columns: this.columns,
                        removeButtonLabel: n("Remove color"),
                        documentColorsLabel: s !== 0 ? n("Document colors") : undefined,
                        documentColorsCount: s === undefined ? this.columns : s
                    });
                    this.colorTableView.bind("selectedColor").to(o, "value");
                    i.buttonView.set({
                        label: this.dropdownLabel,
                        icon: this.icon,
                        tooltip: true
                    });
                    i.extendTemplate({
                        attributes: {
                            class: "ck-color-ui-dropdown"
                        }
                    });
                    i.bind("isEnabled").to(o);
                    i.on("execute", ((e, n) => {
                        t.execute(this.commandName, n);
                        t.editing.view.focus()
                    }));
                    i.on("change:isOpen", ((e, n, o) => {
                        i.colorTableView.appendGrids();
                        if (o) {
                            if (s !== 0) {
                                this.colorTableView.updateDocumentColors(t.model, this.componentName)
                            }
                            this.colorTableView.updateSelectedColors()
                        }
                    }));
                    return i
                }))
            }
        }
        var O_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M4 2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm8.38 9.262H7.62L10 5.506l2.38 5.756zm.532 1.285L14.34 16h1.426L10.804 4H9.196L4.234 16H5.66l1.428-3.453h5.824z"/></svg>';
        class z_ extends L_ {
            constructor(t) {
                const e = t.locale.t;
                super(t, {
                    commandName: $C,
                    componentName: $C,
                    icon: O_,
                    dropdownLabel: e("Font Background Color")
                })
            }
            static get pluginName() {
                return "FontBackgroundColorUI"
            }
        }
        class j_ extends nA {
            static get requires() {
                return [I_, z_]
            }
            static get pluginName() {
                return "FontBackgroundColor"
            }
        }
        class F_ extends NC {
            constructor(t) {
                super(t, QC)
            }
        }
        class R_ extends nA {
            static get pluginName() {
                return "FontColorEditing"
            }
            constructor(t) {
                super(t);
                t.config.define(QC, {
                    colors: [{
                        color: "hsl(0, 0%, 0%)",
                        label: "Black"
                    }, {
                        color: "hsl(0, 0%, 30%)",
                        label: "Dim grey"
                    }, {
                        color: "hsl(0, 0%, 60%)",
                        label: "Grey"
                    }, {
                        color: "hsl(0, 0%, 90%)",
                        label: "Light grey"
                    }, {
                        color: "hsl(0, 0%, 100%)",
                        label: "White",
                        hasBorder: true
                    }, {
                        color: "hsl(0, 75%, 60%)",
                        label: "Red"
                    }, {
                        color: "hsl(30, 75%, 60%)",
                        label: "Orange"
                    }, {
                        color: "hsl(60, 75%, 60%)",
                        label: "Yellow"
                    }, {
                        color: "hsl(90, 75%, 60%)",
                        label: "Light green"
                    }, {
                        color: "hsl(120, 75%, 60%)",
                        label: "Green"
                    }, {
                        color: "hsl(150, 75%, 60%)",
                        label: "Aquamarine"
                    }, {
                        color: "hsl(180, 75%, 60%)",
                        label: "Turquoise"
                    }, {
                        color: "hsl(210, 75%, 60%)",
                        label: "Light blue"
                    }, {
                        color: "hsl(240, 75%, 60%)",
                        label: "Blue"
                    }, {
                        color: "hsl(270, 75%, 60%)",
                        label: "Purple"
                    }],
                    columns: 5
                });
                t.conversion.for("upcast").elementToAttribute({
                    view: {
                        name: "span",
                        styles: {
                            color: /[\s\S]+/
                        }
                    },
                    model: {
                        key: QC,
                        value: JC("color")
                    }
                });
                t.conversion.for("downcast").attributeToElement({
                    model: QC,
                    view: XC("color")
                });
                t.commands.add(QC, new F_(t));
                t.model.schema.extend("$text", {
                    allowAttributes: QC
                });
                t.model.schema.setAttributeProperties(QC, {
                    isFormatting: true,
                    copyOnEnter: true
                })
            }
        }
        var V_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.4 10.3L10 4.5l-2.4 5.8h4.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2z"/></svg>';
        class U_ extends L_ {
            constructor(t) {
                const e = t.locale.t;
                super(t, {
                    commandName: QC,
                    componentName: QC,
                    icon: V_,
                    dropdownLabel: e("Font Color")
                })
            }
            static get pluginName() {
                return "FontColorUI"
            }
        }
        class G_ extends nA {
            static get requires() {
                return [R_, U_]
            }
            static get pluginName() {
                return "FontColor"
            }
        }
        class K_ extends tu {
            observe(t) {
                this.listenTo(t, "load", ((t, e) => {
                    const n = e.target;
                    if (this.checkShouldIgnoreEventFromTarget(n)) {
                        return
                    }
                    if (n.tagName == "IMG") {
                        this._fireEvents(e)
                    }
                }), {
                    useCapture: true
                })
            }
            _fireEvents(t) {
                if (this.isEnabled) {
                    this.document.fire("layoutChanged");
                    this.document.fire("imageLoaded", t)
                }
            }
        }

        function Y_(t) {
            const e = t.next();
            if (e.done) {
                return null
            }
            return e.value
        }
        class H_ {
            constructor() {
                this._stack = []
            }
            add(t, e) {
                const n = this._stack;
                const o = n[0];
                this._insertDescriptor(t);
                const i = n[0];
                if (o !== i && !q_(o, i)) {
                    this.fire("change:top", {
                        oldDescriptor: o,
                        newDescriptor: i,
                        writer: e
                    })
                }
            }
            remove(t, e) {
                const n = this._stack;
                const o = n[0];
                this._removeDescriptor(t);
                const i = n[0];
                if (o !== i && !q_(o, i)) {
                    this.fire("change:top", {
                        oldDescriptor: o,
                        newDescriptor: i,
                        writer: e
                    })
                }
            }
            _insertDescriptor(t) {
                const e = this._stack;
                const n = e.findIndex((e => e.id === t.id));
                if (q_(t, e[n])) {
                    return
                }
                if (n > -1) {
                    e.splice(n, 1)
                }
                let o = 0;
                while (e[o] && W_(e[o], t)) {
                    o++
                }
                e.splice(o, 0, t)
            }
            _removeDescriptor(t) {
                const e = this._stack;
                const n = e.findIndex((e => e.id === t));
                if (n > -1) {
                    e.splice(n, 1)
                }
            }
        }
        _s(H_, ds);

        function q_(t, e) {
            return t && e && t.priority == e.priority && Q_(t.classes) == Q_(e.classes)
        }

        function W_(t, e) {
            if (t.priority > e.priority) {
                return true
            } else if (t.priority < e.priority) {
                return false
            }
            return Q_(t.classes) > Q_(e.classes)
        }

        function Q_(t) {
            return Array.isArray(t) ? t.sort().join(",") : t
        }
        var $_ = n(29);
        var Z_ = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        Z_.insert = "head";
        Z_.singleton = true;
        var J_ = rk()($_["a"], Z_);
        var X_ = $_["a"].locals || {};
        const tv = wb("px");
        const ev = Fd.document.body;
        class nv extends tb {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("top", 0);
                this.set("left", 0);
                this.set("position", "arrow_nw");
                this.set("isVisible", false);
                this.set("withArrow", true);
                this.set("class");
                this.content = this.createCollection();
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-balloon-panel", e.to("position", (t => `ck-balloon-panel_${t}`)), e.if("isVisible", "ck-balloon-panel_visible"), e.if("withArrow", "ck-balloon-panel_with-arrow"), e.to("class")],
                        style: {
                            top: e.to("top", tv),
                            left: e.to("left", tv)
                        }
                    },
                    children: this.content
                })
            }
            show() {
                this.isVisible = true
            }
            hide() {
                this.isVisible = false
            }
            attachTo(t) {
                this.show();
                const e = nv.defaultPositions;
                const n = Object.assign({}, {
                    element: this.element,
                    positions: [e.southArrowNorth, e.southArrowNorthMiddleWest, e.southArrowNorthMiddleEast, e.southArrowNorthWest, e.southArrowNorthEast, e.northArrowSouth, e.northArrowSouthMiddleWest, e.northArrowSouthMiddleEast, e.northArrowSouthWest, e.northArrowSouthEast],
                    limiter: ev,
                    fitInViewport: true
                }, t);
                const o = nv._getOptimalPosition(n);
                const i = parseInt(o.left);
                const r = parseInt(o.top);
                const s = o.name;
                Object.assign(this, {
                    top: r,
                    left: i,
                    position: s
                })
            }
            pin(t) {
                this.unpin();
                this._pinWhenIsVisibleCallback = () => {
                    if (this.isVisible) {
                        this._startPinning(t)
                    } else {
                        this._stopPinning()
                    }
                };
                this._startPinning(t);
                this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback)
            }
            unpin() {
                if (this._pinWhenIsVisibleCallback) {
                    this._stopPinning();
                    this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback);
                    this._pinWhenIsVisibleCallback = null;
                    this.hide()
                }
            }
            _startPinning(t) {
                this.attachTo(t);
                const e = ov(t.target);
                const n = t.limiter ? ov(t.limiter) : ev;
                this.listenTo(Fd.document, "scroll", ((o, i) => {
                    const r = i.target;
                    const s = e && r.contains(e);
                    const a = n && r.contains(n);
                    if (s || a || !e || !n) {
                        this.attachTo(t)
                    }
                }), {
                    useCapture: true
                });
                this.listenTo(Fd.window, "resize", (() => {
                    this.attachTo(t)
                }))
            }
            _stopPinning() {
                this.stopListening(Fd.document, "scroll");
                this.stopListening(Fd.window, "resize")
            }
        }

        function ov(t) {
            if (Wr(t)) {
                return t
            }
            if (yh(t)) {
                return t.commonAncestorContainer
            }
            if (typeof t == "function") {
                return ov(t())
            }
            return null
        }
        nv.arrowHorizontalOffset = 25;
        nv.arrowVerticalOffset = 10;
        nv._getOptimalPosition = Rb;
        nv.defaultPositions = {
            northWestArrowSouthWest: (t, e) => ({
                top: iv(t, e),
                left: t.left - nv.arrowHorizontalOffset,
                name: "arrow_sw"
            }),
            northWestArrowSouthMiddleWest: (t, e) => ({
                top: iv(t, e),
                left: t.left - e.width * .25 - nv.arrowHorizontalOffset,
                name: "arrow_smw"
            }),
            northWestArrowSouth: (t, e) => ({
                top: iv(t, e),
                left: t.left - e.width / 2,
                name: "arrow_s"
            }),
            northWestArrowSouthMiddleEast: (t, e) => ({
                top: iv(t, e),
                left: t.left - e.width * .75 + nv.arrowHorizontalOffset,
                name: "arrow_sme"
            }),
            northWestArrowSouthEast: (t, e) => ({
                top: iv(t, e),
                left: t.left - e.width + nv.arrowHorizontalOffset,
                name: "arrow_se"
            }),
            northArrowSouthWest: (t, e) => ({
                top: iv(t, e),
                left: t.left + t.width / 2 - nv.arrowHorizontalOffset,
                name: "arrow_sw"
            }),
            northArrowSouthMiddleWest: (t, e) => ({
                top: iv(t, e),
                left: t.left + t.width / 2 - e.width * .25 - nv.arrowHorizontalOffset,
                name: "arrow_smw"
            }),
            northArrowSouth: (t, e) => ({
                top: iv(t, e),
                left: t.left + t.width / 2 - e.width / 2,
                name: "arrow_s"
            }),
            northArrowSouthMiddleEast: (t, e) => ({
                top: iv(t, e),
                left: t.left + t.width / 2 - e.width * .75 + nv.arrowHorizontalOffset,
                name: "arrow_sme"
            }),
            northArrowSouthEast: (t, e) => ({
                top: iv(t, e),
                left: t.left + t.width / 2 - e.width + nv.arrowHorizontalOffset,
                name: "arrow_se"
            }),
            northEastArrowSouthWest: (t, e) => ({
                top: iv(t, e),
                left: t.right - nv.arrowHorizontalOffset,
                name: "arrow_sw"
            }),
            northEastArrowSouthMiddleWest: (t, e) => ({
                top: iv(t, e),
                left: t.right - e.width * .25 - nv.arrowHorizontalOffset,
                name: "arrow_smw"
            }),
            northEastArrowSouth: (t, e) => ({
                top: iv(t, e),
                left: t.right - e.width / 2,
                name: "arrow_s"
            }),
            northEastArrowSouthMiddleEast: (t, e) => ({
                top: iv(t, e),
                left: t.right - e.width * .75 + nv.arrowHorizontalOffset,
                name: "arrow_sme"
            }),
            northEastArrowSouthEast: (t, e) => ({
                top: iv(t, e),
                left: t.right - e.width + nv.arrowHorizontalOffset,
                name: "arrow_se"
            }),
            southWestArrowNorthWest: (t, e) => ({
                top: rv(t, e),
                left: t.left - nv.arrowHorizontalOffset,
                name: "arrow_nw"
            }),
            southWestArrowNorthMiddleWest: (t, e) => ({
                top: rv(t, e),
                left: t.left - e.width * .25 - nv.arrowHorizontalOffset,
                name: "arrow_nmw"
            }),
            southWestArrowNorth: (t, e) => ({
                top: rv(t, e),
                left: t.left - e.width / 2,
                name: "arrow_n"
            }),
            southWestArrowNorthMiddleEast: (t, e) => ({
                top: rv(t, e),
                left: t.left - e.width * .75 + nv.arrowHorizontalOffset,
                name: "arrow_nme"
            }),
            southWestArrowNorthEast: (t, e) => ({
                top: rv(t, e),
                left: t.left - e.width + nv.arrowHorizontalOffset,
                name: "arrow_ne"
            }),
            southArrowNorthWest: (t, e) => ({
                top: rv(t, e),
                left: t.left + t.width / 2 - nv.arrowHorizontalOffset,
                name: "arrow_nw"
            }),
            southArrowNorthMiddleWest: (t, e) => ({
                top: rv(t, e),
                left: t.left + t.width / 2 - e.width * .25 - nv.arrowHorizontalOffset,
                name: "arrow_nmw"
            }),
            southArrowNorth: (t, e) => ({
                top: rv(t, e),
                left: t.left + t.width / 2 - e.width / 2,
                name: "arrow_n"
            }),
            southArrowNorthMiddleEast: (t, e) => ({
                top: rv(t, e),
                left: t.left + t.width / 2 - e.width * .75 + nv.arrowHorizontalOffset,
                name: "arrow_nme"
            }),
            southArrowNorthEast: (t, e) => ({
                top: rv(t, e),
                left: t.left + t.width / 2 - e.width + nv.arrowHorizontalOffset,
                name: "arrow_ne"
            }),
            southEastArrowNorthWest: (t, e) => ({
                top: rv(t, e),
                left: t.right - nv.arrowHorizontalOffset,
                name: "arrow_nw"
            }),
            southEastArrowNorthMiddleWest: (t, e) => ({
                top: rv(t, e),
                left: t.right - e.width * .25 - nv.arrowHorizontalOffset,
                name: "arrow_nmw"
            }),
            southEastArrowNorth: (t, e) => ({
                top: rv(t, e),
                left: t.right - e.width / 2,
                name: "arrow_n"
            }),
            southEastArrowNorthMiddleEast: (t, e) => ({
                top: rv(t, e),
                left: t.right - e.width * .75 + nv.arrowHorizontalOffset,
                name: "arrow_nme"
            }),
            southEastArrowNorthEast: (t, e) => ({
                top: rv(t, e),
                left: t.right - e.width + nv.arrowHorizontalOffset,
                name: "arrow_ne"
            })
        };

        function iv(t, e) {
            return t.top - e.height - nv.arrowVerticalOffset
        }

        function rv(t) {
            return t.bottom + nv.arrowVerticalOffset
        }
        var sv = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>';
        const av = "widget-type-around";

        function cv(t, e, n) {
            return t && mv(t) && !n.isInline(e)
        }

        function lv(t) {
            return t.closest(".ck-widget__type-around__button")
        }

        function dv(t) {
            return t.classList.contains("ck-widget__type-around__button_before") ? "before" : "after"
        }

        function uv(t, e) {
            const n = t.closest(".ck-widget");
            return e.mapDomToView(n)
        }

        function hv(t) {
            return t.getAttribute(av)
        }
        const fv = "ck-widget";
        const pv = "ck-widget_selected";

        function mv(t) {
            if (!t.is("element")) {
                return false
            }
            return !!t.getCustomProperty("widget")
        }

        function gv(t, e, n = {}) {
            if (!t.is("containerElement")) {
                throw new ss["a"]("widget-to-widget-wrong-element-type", null, {
                    element: t
                })
            }
            e.setAttribute("contenteditable", "false", t);
            e.addClass(fv, t);
            e.setCustomProperty("widget", true, t);
            t.getFillerOffset = yv;
            if (n.label) {
                bv(t, n.label, e)
            }
            if (n.hasSelectionHandle) {
                xv(t, e)
            }
            kv(t, e, ((t, e, n) => n.addClass(xs(e.classes), t)), ((t, e, n) => n.removeClass(xs(e.classes), t)));
            return t
        }

        function kv(t, e, n, o) {
            const i = new H_;
            i.on("change:top", ((e, i) => {
                if (i.oldDescriptor) {
                    o(t, i.oldDescriptor, i.writer)
                }
                if (i.newDescriptor) {
                    n(t, i.newDescriptor, i.writer)
                }
            }));
            e.setCustomProperty("addHighlight", ((t, e, n) => i.add(e, n)), t);
            e.setCustomProperty("removeHighlight", ((t, e, n) => i.remove(e, n)), t)
        }

        function bv(t, e, n) {
            n.setCustomProperty("widgetLabel", e, t)
        }

        function wv(t) {
            const e = t.getCustomProperty("widgetLabel");
            if (!e) {
                return ""
            }
            return typeof e == "function" ? e() : e
        }

        function Av(t, e) {
            e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], t);
            e.setAttribute("contenteditable", t.isReadOnly ? "false" : "true", t);
            t.on("change:isReadOnly", ((n, o, i) => {
                e.setAttribute("contenteditable", i ? "false" : "true", t)
            }));
            t.on("change:isFocused", ((n, o, i) => {
                if (i) {
                    e.addClass("ck-editor__nested-editable_focused", t)
                } else {
                    e.removeClass("ck-editor__nested-editable_focused", t)
                }
            }));
            return t
        }

        function Cv(t, e) {
            const n = t.getSelectedElement();
            if (n) {
                const o = hv(t);
                if (o) {
                    return e.createPositionAt(n, o)
                }
                if (e.schema.isBlock(n)) {
                    return e.createPositionAfter(n)
                }
            }
            const o = t.getSelectedBlocks().next().value;
            if (o) {
                if (o.isEmpty) {
                    return e.createPositionAt(o, 0)
                }
                const n = e.createPositionAfter(o);
                if (t.focus.isTouching(n)) {
                    return n
                }
                return e.createPositionBefore(o)
            }
            return t.focus
        }

        function _v(t, e) {
            return (n, o) => {
                const {
                    mapper: i,
                    viewPosition: r
                } = o;
                const s = i.findMappedViewAncestor(r);
                if (!e(s)) {
                    return
                }
                const a = i.toModelElement(s);
                o.modelPosition = t.createPositionAt(a, r.isAtStart ? "before" : "after")
            }
        }

        function vv(t, e) {
            const n = new Mh(Fd.window);
            const o = n.getIntersection(t);
            const i = e.height + nv.arrowVerticalOffset;
            if (t.top - i > n.top || t.bottom + i < n.bottom) {
                return null
            }
            const r = o || t;
            const s = r.left + r.width / 2 - e.width / 2;
            return {
                top: Math.max(t.top, 0) + nv.arrowVerticalOffset,
                left: s,
                name: "arrow_n"
            }
        }

        function yv() {
            return null
        }

        function xv(t, e) {
            const n = e.createUIElement("div", {
                class: "ck ck-widget__selection-handle"
            }, (function(t) {
                const e = this.toDomElement(t);
                const n = new Jb;
                n.set("content", sv);
                n.render();
                e.appendChild(n.element);
                return e
            }));
            e.insert(e.createPositionAt(t, 0), n);
            e.addClass(["ck-widget_with-selection-handle"], t)
        }

        function Dv(t, e, n) {
            e.setCustomProperty("image", true, t);
            return gv(t, e, {
                label: o
            });

            function o() {
                const e = Nv(t);
                const o = e.getAttribute("alt");
                return o ? `${o} ${n}` : n
            }
        }

        function Mv(t) {
            return !!t.getCustomProperty("image") && mv(t)
        }

        function Ev(t) {
            const e = t.getSelectedElement();
            if (e && Mv(e)) {
                return e
            }
            return null
        }

        function Sv(t) {
            return !!t && t.is("element", "image")
        }

        function Tv(t, e = {}, n = null) {
            t.change((o => {
                const i = o.createElement("image", e);
                const r = n || Cv(t.document.selection, t);
                t.insertContent(i, r);
                if (i.parent) {
                    o.setSelection(i, "on")
                }
            }))
        }

        function Iv(t) {
            const e = t.schema;
            const n = t.document.selection;
            return Pv(n, e, t) && !Bv(n, e) && Lv(n)
        }

        function Nv(t) {
            const e = [];
            for (const n of t.getChildren()) {
                e.push(n);
                if (n.is("element")) {
                    e.push(...n.getChildren())
                }
            }
            return e.find((t => t.is("element", "img")))
        }

        function Pv(t, e, n) {
            const o = Ov(t, n);
            return e.checkChild(o, "image")
        }

        function Bv(t, e) {
            const n = t.getSelectedElement();
            return n && e.isObject(n)
        }

        function Lv(t) {
            return [...t.focus.getAncestors()].every((t => !t.is("element", "image")))
        }

        function Ov(t, e) {
            const n = Cv(t, e);
            const o = n.parent;
            if (o.isEmpty && !o.is("element", "$root")) {
                return o.parent
            }
            return o
        }

        function zv() {
            return e => {
                e.on("element:figure", t)
            };

            function t(t, e, n) {
                if (!n.consumable.test(e.viewItem, {
                        name: true,
                        classes: "image"
                    })) {
                    return
                }
                const o = Nv(e.viewItem);
                if (!o || !o.hasAttribute("src") || !n.consumable.test(o, {
                        name: true
                    })) {
                    return
                }
                const i = n.convertItem(o, e.modelCursor);
                const r = Y_(i.modelRange.getItems());
                if (!r) {
                    return
                }
                n.convertChildren(e.viewItem, r);
                n.updateConversionResult(r, e)
            }
        }

        function jv() {
            return e => {
                e.on("attribute:srcset:image", t)
            };

            function t(t, e, n) {
                if (!n.consumable.consume(e.item, t.name)) {
                    return
                }
                const o = n.writer;
                const i = n.mapper.toViewElement(e.item);
                const r = Nv(i);
                if (e.attributeNewValue === null) {
                    const t = e.attributeOldValue;
                    if (t.data) {
                        o.removeAttribute("srcset", r);
                        o.removeAttribute("sizes", r);
                        if (t.width) {
                            o.removeAttribute("width", r)
                        }
                    }
                } else {
                    const t = e.attributeNewValue;
                    if (t.data) {
                        o.setAttribute("srcset", t.data, r);
                        o.setAttribute("sizes", "100vw", r);
                        if (t.width) {
                            o.setAttribute("width", t.width, r)
                        }
                    }
                }
            }
        }

        function Fv(t) {
            return n => {
                n.on(`attribute:${t}:image`, e)
            };

            function e(t, e, n) {
                if (!n.consumable.consume(e.item, t.name)) {
                    return
                }
                const o = n.writer;
                const i = n.mapper.toViewElement(e.item);
                const r = Nv(i);
                o.setAttribute(e.attributeKey, e.attributeNewValue || "", r)
            }
        }
        class Rv extends iA {
            refresh() {
                this.isEnabled = Iv(this.editor.model)
            }
            execute(t) {
                const e = this.editor.model;
                for (const n of xs(t.source)) {
                    Tv(e, {
                        src: n
                    })
                }
            }
        }
        class Vv extends nA {
            static get pluginName() {
                return "ImageEditing"
            }
            init() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.t;
                const o = t.conversion;
                t.editing.view.addObserver(K_);
                e.register("image", {
                    isObject: true,
                    isBlock: true,
                    allowWhere: "$block",
                    allowAttributes: ["alt", "src", "srcset"]
                });
                o.for("dataDowncast").elementToElement({
                    model: "image",
                    view: (t, {
                        writer: e
                    }) => Uv(e)
                });
                o.for("editingDowncast").elementToElement({
                    model: "image",
                    view: (t, {
                        writer: e
                    }) => Dv(Uv(e), e, n("image widget"))
                });
                o.for("downcast").add(Fv("src")).add(Fv("alt")).add(jv());
                o.for("upcast").elementToElement({
                    view: {
                        name: "img",
                        attributes: {
                            src: true
                        }
                    },
                    model: (t, {
                        writer: e
                    }) => e.createElement("image", {
                        src: t.getAttribute("src")
                    })
                }).attributeToAttribute({
                    view: {
                        name: "img",
                        key: "alt"
                    },
                    model: "alt"
                }).attributeToAttribute({
                    view: {
                        name: "img",
                        key: "srcset"
                    },
                    model: {
                        key: "srcset",
                        value: t => {
                            const e = {
                                data: t.getAttribute("srcset")
                            };
                            if (t.hasAttribute("width")) {
                                e.width = t.getAttribute("width")
                            }
                            return e
                        }
                    }
                }).add(zv());
                t.commands.add("imageInsert", new Rv(t))
            }
        }

        function Uv(t) {
            const e = t.createEmptyElement("img");
            const n = t.createContainerElement("figure", {
                class: "image"
            });
            t.insert(t.createPositionAt(n, 0), e);
            return n
        }
        class Gv extends nh {
            constructor(t) {
                super(t);
                this.domEventType = "mousedown"
            }
            onDomEvent(t) {
                this.fire(t.type, t)
            }
        }
        var Kv = '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2l2 2.038"/></svg>';
        var Yv = n(30);
        var Hv = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        Hv.insert = "head";
        Hv.singleton = true;
        var qv = rk()(Yv["a"], Hv);
        var Wv = Yv["a"].locals || {};
        const Qv = ["before", "after"];
        const $v = (new DOMParser).parseFromString(Kv, "image/svg+xml").firstChild;
        const Zv = "ck-widget__type-around_disabled";
        class Jv extends nA {
            static get pluginName() {
                return "WidgetTypeAround"
            }
            constructor(t) {
                super(t);
                this._currentFakeCaretModelElement = null
            }
            init() {
                const t = this.editor;
                const e = t.editing.view;
                this.on("change:isEnabled", ((n, o, i) => {
                    e.change((t => {
                        for (const n of e.document.roots) {
                            if (i) {
                                t.removeClass(Zv, n)
                            } else {
                                t.addClass(Zv, n)
                            }
                        }
                    }));
                    if (!i) {
                        t.model.change((t => {
                            t.removeSelectionAttribute(av)
                        }))
                    }
                }));
                this._enableTypeAroundUIInjection();
                this._enableInsertingParagraphsOnButtonClick();
                this._enableInsertingParagraphsOnEnterKeypress();
                this._enableInsertingParagraphsOnTypingKeystroke();
                this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();
                this._enableDeleteIntegration();
                this._enableInsertContentIntegration()
            }
            destroy() {
                this._currentFakeCaretModelElement = null
            }
            _insertParagraph(t, e) {
                const n = this.editor;
                const o = n.editing.view;
                n.execute("insertParagraph", {
                    position: n.model.createPositionAt(t, e)
                });
                o.focus();
                o.scrollToTheSelection()
            }
            _listenToIfEnabled(t, e, n, o) {
                this.listenTo(t, e, ((...t) => {
                    if (this.isEnabled) {
                        n(...t)
                    }
                }), o)
            }
            _insertParagraphAccordingToFakeCaretPosition() {
                const t = this.editor;
                const e = t.model;
                const n = e.document.selection;
                const o = hv(n);
                if (!o) {
                    return false
                }
                const i = n.getSelectedElement();
                this._insertParagraph(i, o);
                return true
            }
            _enableTypeAroundUIInjection() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.locale.t;
                const o = {
                    before: n("Insert paragraph before block"),
                    after: n("Insert paragraph after block")
                };
                t.editing.downcastDispatcher.on("insert", ((t, n, i) => {
                    const r = i.mapper.toViewElement(n.item);
                    if (cv(r, n.item, e)) {
                        Xv(i.writer, o, r)
                    }
                }), {
                    priority: "low"
                })
            }
            _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
                const t = this.editor;
                const e = t.model;
                const n = e.document.selection;
                const o = e.schema;
                const i = t.editing.view;
                this._listenToIfEnabled(i.document, "keydown", ((t, e) => {
                    if (Rl(e.keyCode)) {
                        this._handleArrowKeyPress(t, e)
                    }
                }), {
                    priority: is.get("high") + 10
                });
                this._listenToIfEnabled(n, "change:range", ((e, n) => {
                    if (!n.directChange) {
                        return
                    }
                    t.model.change((t => {
                        t.removeSelectionAttribute(av)
                    }))
                }));
                this._listenToIfEnabled(e.document, "change:data", (() => {
                    const e = n.getSelectedElement();
                    if (e) {
                        const n = t.editing.mapper.toViewElement(e);
                        if (cv(n, e, o)) {
                            return
                        }
                    }
                    t.model.change((t => {
                        t.removeSelectionAttribute(av)
                    }))
                }));
                this._listenToIfEnabled(t.editing.downcastDispatcher, "selection", ((t, e, n) => {
                    const i = n.writer;
                    if (this._currentFakeCaretModelElement) {
                        const t = n.mapper.toViewElement(this._currentFakeCaretModelElement);
                        if (t) {
                            i.removeClass(Qv.map(r), t);
                            this._currentFakeCaretModelElement = null
                        }
                    }
                    const s = e.selection.getSelectedElement();
                    if (!s) {
                        return
                    }
                    const a = n.mapper.toViewElement(s);
                    if (!cv(a, s, o)) {
                        return
                    }
                    const c = hv(e.selection);
                    if (!c) {
                        return
                    }
                    i.addClass(r(c), a);
                    this._currentFakeCaretModelElement = s
                }));
                this._listenToIfEnabled(t.ui.focusTracker, "change:isFocused", ((e, n, o) => {
                    if (!o) {
                        t.model.change((t => {
                            t.removeSelectionAttribute(av)
                        }))
                    }
                }));

                function r(t) {
                    return `ck-widget_type-around_show-fake-caret_${t}`
                }
            }
            _handleArrowKeyPress(t, e) {
                const n = this.editor;
                const o = n.model;
                const i = o.document.selection;
                const r = o.schema;
                const s = n.editing.view;
                const a = e.keyCode;
                const c = Ul(a, n.locale.contentLanguageDirection);
                const l = s.document.selection.getSelectedElement();
                const d = n.editing.mapper.toModelElement(l);
                let u;
                if (cv(l, d, r)) {
                    u = this._handleArrowKeyPressOnSelectedWidget(c)
                } else if (i.isCollapsed) {
                    u = this._handleArrowKeyPressWhenSelectionNextToAWidget(c)
                }
                if (u) {
                    e.preventDefault();
                    t.stop()
                }
            }
            _handleArrowKeyPressOnSelectedWidget(t) {
                const e = this.editor;
                const n = e.model;
                const o = n.document.selection;
                const i = hv(o);
                return n.change((e => {
                    if (i) {
                        const n = i === (t ? "after" : "before");
                        if (!n) {
                            e.removeSelectionAttribute(av);
                            return true
                        }
                    } else {
                        e.setSelectionAttribute(av, t ? "after" : "before");
                        return true
                    }
                    return false
                }))
            }
            _handleArrowKeyPressWhenSelectionNextToAWidget(t) {
                const e = this.editor;
                const n = e.model;
                const o = n.schema;
                const i = e.plugins.get("Widget");
                const r = i._getObjectElementNextToSelection(t);
                const s = e.editing.mapper.toViewElement(r);
                if (cv(s, r, o)) {
                    n.change((e => {
                        i._setSelectionOverElement(r);
                        e.setSelectionAttribute(av, t ? "before" : "after")
                    }));
                    return true
                }
                return false
            }
            _enableInsertingParagraphsOnButtonClick() {
                const t = this.editor;
                const e = t.editing.view;
                this._listenToIfEnabled(e.document, "mousedown", ((n, o) => {
                    const i = lv(o.domTarget);
                    if (!i) {
                        return
                    }
                    const r = dv(i);
                    const s = uv(i, e.domConverter);
                    const a = t.editing.mapper.toModelElement(s);
                    this._insertParagraph(a, r);
                    o.preventDefault();
                    n.stop()
                }))
            }
            _enableInsertingParagraphsOnEnterKeypress() {
                const t = this.editor;
                const e = t.editing.view;
                this._listenToIfEnabled(e.document, "enter", ((n, o) => {
                    const i = e.document.selection.getSelectedElement();
                    const r = t.editing.mapper.toModelElement(i);
                    const s = t.model.schema;
                    let a;
                    if (this._insertParagraphAccordingToFakeCaretPosition()) {
                        a = true
                    } else if (cv(i, r, s)) {
                        this._insertParagraph(r, o.isSoft ? "before" : "after");
                        a = true
                    }
                    if (a) {
                        o.preventDefault();
                        n.stop()
                    }
                }))
            }
            _enableInsertingParagraphsOnTypingKeystroke() {
                const t = this.editor;
                const e = t.editing.view;
                const n = [Ol.enter, Ol.delete, Ol.backspace];
                this._listenToIfEnabled(e.document, "keydown", ((t, e) => {
                    if (!n.includes(e.keyCode) && !qA(e)) {
                        this._insertParagraphAccordingToFakeCaretPosition()
                    }
                }), {
                    priority: is.get("high") + 1
                })
            }
            _enableDeleteIntegration() {
                const t = this.editor;
                const e = t.editing.view;
                const n = t.model;
                const o = n.schema;
                this._listenToIfEnabled(e.document, "delete", ((e, i) => {
                    const r = hv(n.document.selection);
                    if (!r) {
                        return
                    }
                    const s = i.direction;
                    const a = n.document.selection.getSelectedElement();
                    const c = r === "before";
                    const l = s == "forward";
                    const d = c === l;
                    if (d) {
                        t.execute("delete", {
                            selection: n.createSelection(a, "on")
                        })
                    } else {
                        const e = o.getNearestSelectionRange(n.createPositionAt(a, r), s);
                        if (e) {
                            if (!e.isCollapsed) {
                                n.change((n => {
                                    n.setSelection(e);
                                    t.execute(l ? "forwardDelete" : "delete")
                                }))
                            } else {
                                const i = n.createSelection(e.start);
                                n.modifySelection(i, {
                                    direction: s
                                });
                                if (!i.focus.isEqual(e.start)) {
                                    n.change((n => {
                                        n.setSelection(e);
                                        t.execute(l ? "forwardDelete" : "delete")
                                    }))
                                } else {
                                    const t = ny(o, e.start.parent);
                                    n.deleteContent(n.createSelection(t, "on"), {
                                        doNotAutoparagraph: true
                                    })
                                }
                            }
                        }
                    }
                    i.preventDefault();
                    e.stop()
                }), {
                    priority: is.get("high") + 1
                })
            }
            _enableInsertContentIntegration() {
                const t = this.editor;
                const e = this.editor.model;
                const n = e.document.selection;
                this._listenToIfEnabled(t.model, "insertContent", ((t, [o, i]) => {
                    if (i && !i.is("documentSelection")) {
                        return
                    }
                    const r = hv(n);
                    if (!r) {
                        return
                    }
                    t.stop();
                    return e.change((t => {
                        const i = n.getSelectedElement();
                        const s = e.createPositionAt(i, r);
                        const a = t.createSelection(s);
                        const c = e.insertContent(o, a);
                        t.setSelection(a);
                        return c
                    }))
                }), {
                    priority: "high"
                })
            }
        }

        function Xv(t, e, n) {
            const o = t.createUIElement("div", {
                class: "ck ck-reset_all ck-widget__type-around"
            }, (function(t) {
                const n = this.toDomElement(t);
                ty(n, e);
                ey(n);
                return n
            }));
            t.insert(t.createPositionAt(n, "end"), o)
        }

        function ty(t, e) {
            for (const n of Qv) {
                const o = new yk({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-widget__type-around__button", `ck-widget__type-around__button_${n}`],
                        title: e[n]
                    },
                    children: [t.ownerDocument.importNode($v, true)]
                });
                t.appendChild(o.render())
            }
        }

        function ey(t) {
            const e = new yk({
                tag: "div",
                attributes: {
                    class: ["ck", "ck-widget__type-around__fake-caret"]
                }
            });
            t.appendChild(e.render())
        }

        function ny(t, e) {
            let n = e;
            for (const o of e.getAncestors({
                    parentFirst: true
                })) {
                if (o.childCount > 1 || t.isLimit(o)) {
                    break
                }
                n = o
            }
            return n
        }
        var oy = n(31);
        var iy = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        iy.insert = "head";
        iy.singleton = true;
        var ry = rk()(oy["a"], iy);
        var sy = oy["a"].locals || {};

        function ay(t) {
            const e = t.model;
            return (n, o) => {
                const i = o.keyCode == Ol.arrowup;
                const r = o.keyCode == Ol.arrowdown;
                const s = o.shiftKey;
                const a = e.document.selection;
                if (!i && !r) {
                    return
                }
                const c = r;
                if (s && hy(a, c)) {
                    return
                }
                const l = cy(t, a, c);
                if (!l || l.isCollapsed) {
                    return
                }
                if (uy(t, l, c)) {
                    e.change((t => {
                        const n = c ? l.end : l.start;
                        if (s) {
                            const o = e.createSelection(a.anchor);
                            o.setFocus(n);
                            t.setSelection(o)
                        } else {
                            t.setSelection(n)
                        }
                    }));
                    n.stop();
                    o.preventDefault();
                    o.stopPropagation()
                }
            }
        }

        function cy(t, e, n) {
            const o = t.model;
            if (n) {
                const t = e.isCollapsed ? e.focus : e.getLastPosition();
                const n = ly(o, t, "forward");
                if (!n) {
                    return null
                }
                const i = o.createRange(t, n);
                const r = dy(o.schema, i, "backward");
                if (r && t.isBefore(r)) {
                    return o.createRange(t, r)
                }
                return null
            } else {
                const t = e.isCollapsed ? e.focus : e.getFirstPosition();
                const n = ly(o, t, "backward");
                if (!n) {
                    return null
                }
                const i = o.createRange(n, t);
                const r = dy(o.schema, i, "forward");
                if (r && t.isAfter(r)) {
                    return o.createRange(r, t)
                }
                return null
            }
        }

        function ly(t, e, n) {
            const o = t.schema;
            const i = t.createRangeIn(e.root);
            const r = n == "forward" ? "elementStart" : "elementEnd";
            for (const {
                    previousPosition: t,
                    item: s,
                    type: a
                } of i.getWalker({
                    startPosition: e,
                    direction: n
                })) {
                if (o.isLimit(s) && !o.isInline(s)) {
                    return t
                }
                if (a == r && o.isBlock(s)) {
                    return null
                }
            }
            return null
        }

        function dy(t, e, n) {
            const o = n == "backward" ? e.end : e.start;
            if (t.checkChild(o, "$text")) {
                return o
            }
            for (const {
                    nextPosition: o
                } of e.getWalker({
                    direction: n
                })) {
                if (t.checkChild(o, "$text")) {
                    return o
                }
            }
        }

        function uy(t, e, n) {
            const o = t.model;
            const i = t.view.domConverter;
            if (n) {
                const t = o.createSelection(e.start);
                o.modifySelection(t);
                if (!t.focus.isAtEnd && !e.start.isEqual(t.focus)) {
                    e = o.createRange(t.focus, e.end)
                }
            }
            const r = t.mapper.toViewRange(e);
            const s = i.viewRangeToDom(r);
            const a = Mh.getDomRangeRects(s);
            let c;
            for (const t of a) {
                if (c === undefined) {
                    c = Math.round(t.bottom);
                    continue
                }
                if (Math.round(t.top) >= c) {
                    return false
                }
                c = Math.max(c, Math.round(t.bottom))
            }
            return true
        }

        function hy(t, e) {
            return !t.isCollapsed && t.isBackward == e
        }
        class fy extends nA {
            static get pluginName() {
                return "Widget"
            }
            static get requires() {
                return [Jv]
            }
            init() {
                const t = this.editor.editing.view;
                const e = t.document;
                this._previouslySelected = new Set;
                this.editor.editing.downcastDispatcher.on("selection", ((t, e, n) => {
                    this._clearPreviouslySelectedWidgets(n.writer);
                    const o = n.writer;
                    const i = o.document.selection;
                    const r = i.getSelectedElement();
                    let s = null;
                    for (const t of i.getRanges()) {
                        for (const e of t) {
                            const t = e.item;
                            if (mv(t) && !my(t, s)) {
                                o.addClass(pv, t);
                                this._previouslySelected.add(t);
                                s = t;
                                if (t == r) {
                                    o.setSelection(i.getRanges(), {
                                        fake: true,
                                        label: wv(r)
                                    })
                                }
                            }
                        }
                    }
                }), {
                    priority: "low"
                });
                t.addObserver(Gv);
                this.listenTo(e, "mousedown", ((...t) => this._onMousedown(...t)));
                this.listenTo(e, "keydown", ((...t) => {
                    this._handleSelectionChangeOnArrowKeyPress(...t)
                }), {
                    priority: "high"
                });
                this.listenTo(e, "keydown", ((...t) => {
                    this._preventDefaultOnArrowKeyPress(...t)
                }), {
                    priority: is.get("high") - 20
                });
                this.listenTo(e, "keydown", ay(this.editor.editing));
                this.listenTo(e, "delete", ((t, e) => {
                    if (this._handleDelete(e.direction == "forward")) {
                        e.preventDefault();
                        t.stop()
                    }
                }), {
                    priority: "high"
                })
            }
            _onMousedown(t, e) {
                const n = this.editor;
                const o = n.editing.view;
                const i = o.document;
                let r = e.target;
                if (py(r)) {
                    if ((Ml.isSafari || Ml.isGecko) && e.domEvent.detail >= 3) {
                        const t = n.editing.mapper;
                        const o = r.is("attributeElement") ? r.findAncestor((t => !t.is("attributeElement"))) : r;
                        const i = t.toModelElement(o);
                        e.preventDefault();
                        this.editor.model.change((t => {
                            t.setSelection(i, "in")
                        }))
                    }
                    return
                }
                if (!mv(r)) {
                    r = r.findAncestor(mv);
                    if (!r) {
                        return
                    }
                }
                e.preventDefault();
                if (!i.isFocused) {
                    o.focus()
                }
                const s = n.editing.mapper.toModelElement(r);
                this._setSelectionOverElement(s)
            }
            _handleSelectionChangeOnArrowKeyPress(t, e) {
                const n = e.keyCode;
                if (!Rl(n)) {
                    return
                }
                const o = this.editor.model;
                const i = o.schema;
                const r = o.document.selection;
                const s = r.getSelectedElement();
                const a = Ul(n, this.editor.locale.contentLanguageDirection);
                if (s && i.isObject(s)) {
                    const n = a ? r.getLastPosition() : r.getFirstPosition();
                    const s = i.getNearestSelectionRange(n, a ? "forward" : "backward");
                    if (s) {
                        o.change((t => {
                            t.setSelection(s)
                        }));
                        e.preventDefault();
                        t.stop()
                    }
                    return
                }
                if (!r.isCollapsed) {
                    return
                }
                const c = this._getObjectElementNextToSelection(a);
                if (c && i.isObject(c)) {
                    this._setSelectionOverElement(c);
                    e.preventDefault();
                    t.stop()
                }
            }
            _preventDefaultOnArrowKeyPress(t, e) {
                const n = e.keyCode;
                if (!Rl(n)) {
                    return
                }
                const o = this.editor.model;
                const i = o.schema;
                const r = o.document.selection.getSelectedElement();
                if (r && i.isObject(r)) {
                    e.preventDefault();
                    t.stop()
                }
            }
            _handleDelete(t) {
                if (this.editor.isReadOnly) {
                    return
                }
                const e = this.editor.model.document;
                const n = e.selection;
                if (!n.isCollapsed) {
                    return
                }
                const o = this._getObjectElementNextToSelection(t);
                if (o) {
                    this.editor.model.change((t => {
                        let e = n.anchor.parent;
                        while (e.isEmpty) {
                            const n = e;
                            e = n.parent;
                            t.remove(n)
                        }
                        this._setSelectionOverElement(o)
                    }));
                    return true
                }
            }
            _setSelectionOverElement(t) {
                this.editor.model.change((e => {
                    e.setSelection(e.createRangeOn(t))
                }))
            }
            _getObjectElementNextToSelection(t) {
                const e = this.editor.model;
                const n = e.schema;
                const o = e.document.selection;
                const i = e.createSelection(o);
                e.modifySelection(i, {
                    direction: t ? "forward" : "backward"
                });
                const r = t ? i.focus.nodeBefore : i.focus.nodeAfter;
                if (!!r && n.isObject(r)) {
                    return r
                }
                return null
            }
            _clearPreviouslySelectedWidgets(t) {
                for (const e of this._previouslySelected) {
                    t.removeClass(pv, e)
                }
                this._previouslySelected.clear()
            }
        }

        function py(t) {
            while (t) {
                if (t.is("editableElement") && !t.is("rootElement")) {
                    return true
                }
                if (mv(t)) {
                    return false
                }
                t = t.parent
            }
            return false
        }

        function my(t, e) {
            if (!e) {
                return false
            }
            return Array.from(t.getAncestors()).includes(e)
        }
        class gy extends iA {
            refresh() {
                const t = this.editor.model.document.selection.getSelectedElement();
                this.isEnabled = Sv(t);
                if (Sv(t) && t.hasAttribute("alt")) {
                    this.value = t.getAttribute("alt")
                } else {
                    this.value = false
                }
            }
            execute(t) {
                const e = this.editor.model;
                const n = e.document.selection.getSelectedElement();
                e.change((e => {
                    e.setAttribute("alt", t.newValue, n)
                }))
            }
        }
        class ky extends nA {
            static get pluginName() {
                return "ImageTextAlternativeEditing"
            }
            init() {
                this.editor.commands.add("imageTextAlternative", new gy(this.editor))
            }
        }
        var by = n(32);
        var wy = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        wy.insert = "head";
        wy.singleton = true;
        var Ay = rk()(by["a"], wy);
        var Cy = by["a"].locals || {};
        class _y extends tb {
            constructor(t, e) {
                super(t);
                const n = `ck-labeled-field-view-${ns()}`;
                const o = `ck-labeled-field-view-status-${ns()}`;
                this.fieldView = e(this, n, o);
                this.set("label");
                this.set("isEnabled", true);
                this.set("isEmpty", true);
                this.set("isFocused", false);
                this.set("errorText", null);
                this.set("infoText", null);
                this.set("class");
                this.set("placeholder");
                this.labelView = this._createLabelView(n);
                this.statusView = this._createStatusView(o);
                this.bind("_statusText").to(this, "errorText", this, "infoText", ((t, e) => t || e));
                const i = this.bindTemplate;
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-labeled-field-view", i.to("class"), i.if("isEnabled", "ck-disabled", (t => !t)), i.if("isEmpty", "ck-labeled-field-view_empty"), i.if("isFocused", "ck-labeled-field-view_focused"), i.if("placeholder", "ck-labeled-field-view_placeholder"), i.if("errorText", "ck-error")]
                    },
                    children: [{
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-labeled-field-view__input-wrapper"]
                        },
                        children: [this.fieldView, this.labelView]
                    }, this.statusView]
                })
            }
            _createLabelView(t) {
                const e = new mb(this.locale);
                e.for = t;
                e.bind("text").to(this, "label");
                return e
            }
            _createStatusView(t) {
                const e = new tb(this.locale);
                const n = this.bindTemplate;
                e.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-labeled-field-view__status", n.if("errorText", "ck-labeled-field-view__status_error"), n.if("_statusText", "ck-hidden", (t => !t))],
                        id: t,
                        role: n.if("errorText", "alert")
                    },
                    children: [{
                        text: n.to("_statusText")
                    }]
                });
                return e
            }
            focus() {
                this.fieldView.focus()
            }
        }
        var vy = n(33);
        var yy = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        yy.insert = "head";
        yy.singleton = true;
        var xy = rk()(vy["a"], yy);
        var Dy = vy["a"].locals || {};
        class My extends tb {
            constructor(t) {
                super(t);
                this.set("value");
                this.set("id");
                this.set("placeholder");
                this.set("isReadOnly", false);
                this.set("hasError", false);
                this.set("ariaDescribedById");
                this.focusTracker = new tk;
                this.bind("isFocused").to(this.focusTracker);
                this.set("isEmpty", true);
                const e = this.bindTemplate;
                this.setTemplate({
                    tag: "input",
                    attributes: {
                        type: "text",
                        class: ["ck", "ck-input", "ck-input-text", e.if("isFocused", "ck-input_focused"), e.if("isEmpty", "ck-input-text_empty"), e.if("hasError", "ck-error")],
                        id: e.to("id"),
                        placeholder: e.to("placeholder"),
                        readonly: e.to("isReadOnly"),
                        "aria-invalid": e.if("hasError", true),
                        "aria-describedby": e.to("ariaDescribedById")
                    },
                    on: {
                        input: e.to("input"),
                        change: e.to(this._updateIsEmpty.bind(this))
                    }
                })
            }
            render() {
                super.render();
                this.focusTracker.add(this.element);
                this._setDomElementValue(this.value);
                this._updateIsEmpty();
                this.on("change:value", ((t, e, n) => {
                    this._setDomElementValue(n);
                    this._updateIsEmpty()
                }))
            }
            select() {
                this.element.select()
            }
            focus() {
                this.element.focus()
            }
            _updateIsEmpty() {
                this.isEmpty = Ey(this.element)
            }
            _setDomElementValue(t) {
                this.element.value = !t && t !== 0 ? "" : t
            }
        }

        function Ey(t) {
            return !t.value
        }

        function Sy(t, e, n) {
            const o = new My(t.locale);
            o.set({
                id: e,
                ariaDescribedById: n
            });
            o.bind("isReadOnly").to(t, "isEnabled", (t => !t));
            o.bind("hasError").to(t, "errorText", (t => !!t));
            o.on("input", (() => {
                t.errorText = null
            }));
            t.bind("isEmpty", "isFocused", "placeholder").to(o);
            return o
        }

        function Ty(t, e, n) {
            const o = Nw(t.locale);
            o.set({
                id: e,
                ariaDescribedById: n
            });
            o.bind("isEnabled").to(t);
            return o
        }

        function Iy(t) {
            t.set("_isCssTransitionsDisabled", false);
            t.disableCssTransitions = () => {
                t._isCssTransitionsDisabled = true
            };
            t.enableCssTransitions = () => {
                t._isCssTransitionsDisabled = false
            };
            t.extendTemplate({
                attributes: {
                    class: [t.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")]
                }
            })
        }

        function Ny({
            view: t
        }) {
            t.listenTo(t.element, "submit", ((e, n) => {
                n.preventDefault();
                t.fire("submit")
            }), {
                useCapture: true
            })
        }
        var Py = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>';
        var By = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.591 10.177l4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>';
        var Ly = n(34);
        var Oy = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        Oy.insert = "head";
        Oy.singleton = true;
        var zy = rk()(Ly["a"], Oy);
        var jy = Ly["a"].locals || {};
        var Fy = n(35);
        var Ry = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        Ry.insert = "head";
        Ry.singleton = true;
        var Vy = rk()(Fy["a"], Ry);
        var Uy = Fy["a"].locals || {};
        class Gy extends tb {
            constructor(t) {
                super(t);
                const e = this.locale.t;
                this.focusTracker = new tk;
                this.keystrokes = new Vg;
                this.labeledInput = this._createLabeledInputView();
                this.saveButtonView = this._createButton(e("Save"), Py, "ck-button-save");
                this.saveButtonView.type = "submit";
                this.cancelButtonView = this._createButton(e("Cancel"), By, "ck-button-cancel", "cancel");
                this._focusables = new Ck;
                this._focusCycler = new Db({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {
                        focusPrevious: "shift + tab",
                        focusNext: "tab"
                    }
                });
                this.setTemplate({
                    tag: "form",
                    attributes: {
                        class: ["ck", "ck-text-alternative-form", "ck-responsive-form"],
                        tabindex: "-1"
                    },
                    children: [this.labeledInput, this.saveButtonView, this.cancelButtonView]
                });
                Iy(this)
            }
            render() {
                super.render();
                this.keystrokes.listenTo(this.element);
                Ny({
                    view: this
                });
                [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((t => {
                    this._focusables.add(t);
                    this.focusTracker.add(t.element)
                }))
            }
            _createButton(t, e, n, o) {
                const i = new cw(this.locale);
                i.set({
                    label: t,
                    icon: e,
                    tooltip: true
                });
                i.extendTemplate({
                    attributes: {
                        class: n
                    }
                });
                if (o) {
                    i.delegate("execute").to(this, o)
                }
                return i
            }
            _createLabeledInputView() {
                const t = this.locale.t;
                const e = new _y(this.locale, Sy);
                e.label = t("Text alternative");
                return e
            }
        }
        var Ky = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>';
        var Yy = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>';
        var Hy = n(36);
        var qy = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        qy.insert = "head";
        qy.singleton = true;
        var Wy = rk()(Hy["a"], qy);
        var Qy = Hy["a"].locals || {};
        var $y = n(37);
        var Zy = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        Zy.insert = "head";
        Zy.singleton = true;
        var Jy = rk()($y["a"], Zy);
        var Xy = $y["a"].locals || {};
        const tx = wb("px");
        class ex extends nA {
            static get pluginName() {
                return "ContextualBalloon"
            }
            constructor(t) {
                super(t);
                this.positionLimiter = () => {
                    const t = this.editor.editing.view;
                    const e = t.document;
                    const n = e.selection.editableElement;
                    if (n) {
                        return t.domConverter.mapViewToDom(n.root)
                    }
                    return null
                };
                this.set("visibleView", null);
                this.view = new nv(t.locale);
                t.ui.view.body.add(this.view);
                t.ui.focusTracker.add(this.view.element);
                this._viewToStack = new Map;
                this._idToStack = new Map;
                this.set("_numberOfStacks", 0);
                this.set("_singleViewMode", false);
                this._rotatorView = this._createRotatorView();
                this._fakePanelsView = this._createFakePanelsView()
            }
            hasView(t) {
                return Array.from(this._viewToStack.keys()).includes(t)
            }
            add(t) {
                if (this.hasView(t.view)) {
                    throw new ss["a"]("contextualballoon-add-view-exist", [this, t])
                }
                const e = t.stackId || "main";
                if (!this._idToStack.has(e)) {
                    this._idToStack.set(e, new Map([
                        [t.view, t]
                    ]));
                    this._viewToStack.set(t.view, this._idToStack.get(e));
                    this._numberOfStacks = this._idToStack.size;
                    if (!this._visibleStack || t.singleViewMode) {
                        this.showStack(e)
                    }
                    return
                }
                const n = this._idToStack.get(e);
                if (t.singleViewMode) {
                    this.showStack(e)
                }
                n.set(t.view, t);
                this._viewToStack.set(t.view, n);
                if (n === this._visibleStack) {
                    this._showView(t)
                }
            }
            remove(t) {
                if (!this.hasView(t)) {
                    throw new ss["a"]("contextualballoon-remove-view-not-exist", [this, t])
                }
                const e = this._viewToStack.get(t);
                if (this._singleViewMode && this.visibleView === t) {
                    this._singleViewMode = false
                }
                if (this.visibleView === t) {
                    if (e.size === 1) {
                        if (this._idToStack.size > 1) {
                            this._showNextStack()
                        } else {
                            this.view.hide();
                            this.visibleView = null;
                            this._rotatorView.hideView()
                        }
                    } else {
                        this._showView(Array.from(e.values())[e.size - 2])
                    }
                }
                if (e.size === 1) {
                    this._idToStack.delete(this._getStackId(e));
                    this._numberOfStacks = this._idToStack.size
                } else {
                    e.delete(t)
                }
                this._viewToStack.delete(t)
            }
            updatePosition(t) {
                if (t) {
                    this._visibleStack.get(this.visibleView).position = t
                }
                this.view.pin(this._getBalloonPosition());
                this._fakePanelsView.updatePosition()
            }
            showStack(t) {
                this.visibleStack = t;
                const e = this._idToStack.get(t);
                if (!e) {
                    throw new ss["a"]("contextualballoon-showstack-stack-not-exist", this)
                }
                if (this._visibleStack === e) {
                    return
                }
                this._showView(Array.from(e.values()).pop())
            }
            get _visibleStack() {
                return this._viewToStack.get(this.visibleView)
            }
            _getStackId(t) {
                const e = Array.from(this._idToStack.entries()).find((e => e[1] === t));
                return e[0]
            }
            _showNextStack() {
                const t = Array.from(this._idToStack.values());
                let e = t.indexOf(this._visibleStack) + 1;
                if (!t[e]) {
                    e = 0
                }
                this.showStack(this._getStackId(t[e]))
            }
            _showPrevStack() {
                const t = Array.from(this._idToStack.values());
                let e = t.indexOf(this._visibleStack) - 1;
                if (!t[e]) {
                    e = t.length - 1
                }
                this.showStack(this._getStackId(t[e]))
            }
            _createRotatorView() {
                const t = new nx(this.editor.locale);
                const e = this.editor.locale.t;
                this.view.content.add(t);
                t.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", ((t, e) => !e && t > 1));
                t.on("change:isNavigationVisible", (() => this.updatePosition()), {
                    priority: "low"
                });
                t.bind("counter").to(this, "visibleView", this, "_numberOfStacks", ((t, n) => {
                    if (n < 2) {
                        return ""
                    }
                    const o = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
                    return e("%0 of %1", [o, n])
                }));
                t.buttonNextView.on("execute", (() => {
                    if (t.focusTracker.isFocused) {
                        this.editor.editing.view.focus()
                    }
                    this._showNextStack()
                }));
                t.buttonPrevView.on("execute", (() => {
                    if (t.focusTracker.isFocused) {
                        this.editor.editing.view.focus()
                    }
                    this._showPrevStack()
                }));
                return t
            }
            _createFakePanelsView() {
                const t = new ox(this.editor.locale, this.view);
                t.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", ((t, e) => {
                    const n = !e && t >= 2;
                    return n ? Math.min(t - 1, 2) : 0
                }));
                t.listenTo(this.view, "change:top", (() => t.updatePosition()));
                t.listenTo(this.view, "change:left", (() => t.updatePosition()));
                this.editor.ui.view.body.add(t);
                return t
            }
            _showView({
                view: t,
                balloonClassName: e = "",
                withArrow: n = true,
                singleViewMode: o = false
            }) {
                this.view.class = e;
                this.view.withArrow = n;
                this._rotatorView.showView(t);
                this.visibleView = t;
                this.view.pin(this._getBalloonPosition());
                this._fakePanelsView.updatePosition();
                if (o) {
                    this._singleViewMode = true
                }
            }
            _getBalloonPosition() {
                let t = Array.from(this._visibleStack.values()).pop().position;
                if (t && !t.limiter) {
                    t = Object.assign({}, t, {
                        limiter: this.positionLimiter
                    })
                }
                return t
            }
        }
        class nx extends tb {
            constructor(t) {
                super(t);
                const e = t.t;
                const n = this.bindTemplate;
                this.set("isNavigationVisible", true);
                this.focusTracker = new tk;
                this.buttonPrevView = this._createButtonView(e("Previous"), Ky);
                this.buttonNextView = this._createButtonView(e("Next"), Yy);
                this.content = this.createCollection();
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-balloon-rotator"],
                        "z-index": "-1"
                    },
                    children: [{
                        tag: "div",
                        attributes: {
                            class: ["ck-balloon-rotator__navigation", n.to("isNavigationVisible", (t => t ? "" : "ck-hidden"))]
                        },
                        children: [this.buttonPrevView, {
                            tag: "span",
                            attributes: {
                                class: ["ck-balloon-rotator__counter"]
                            },
                            children: [{
                                text: n.to("counter")
                            }]
                        }, this.buttonNextView]
                    }, {
                        tag: "div",
                        attributes: {
                            class: "ck-balloon-rotator__content"
                        },
                        children: this.content
                    }]
                })
            }
            render() {
                super.render();
                this.focusTracker.add(this.element)
            }
            showView(t) {
                this.hideView();
                this.content.add(t)
            }
            hideView() {
                this.content.clear()
            }
            _createButtonView(t, e) {
                const n = new cw(this.locale);
                n.set({
                    label: t,
                    icon: e,
                    tooltip: true
                });
                return n
            }
        }
        class ox extends tb {
            constructor(t, e) {
                super(t);
                const n = this.bindTemplate;
                this.set("top", 0);
                this.set("left", 0);
                this.set("height", 0);
                this.set("width", 0);
                this.set("numberOfPanels", 0);
                this.content = this.createCollection();
                this._balloonPanelView = e;
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck-fake-panel", n.to("numberOfPanels", (t => t ? "" : "ck-hidden"))],
                        style: {
                            top: n.to("top", tx),
                            left: n.to("left", tx),
                            width: n.to("width", tx),
                            height: n.to("height", tx)
                        }
                    },
                    children: this.content
                });
                this.on("change:numberOfPanels", ((t, e, n, o) => {
                    if (n > o) {
                        this._addPanels(n - o)
                    } else {
                        this._removePanels(o - n)
                    }
                    this.updatePosition()
                }))
            }
            _addPanels(t) {
                while (t--) {
                    const t = new tb;
                    t.setTemplate({
                        tag: "div"
                    });
                    this.content.add(t);
                    this.registerChild(t)
                }
            }
            _removePanels(t) {
                while (t--) {
                    const t = this.content.last;
                    this.content.remove(t);
                    this.deregisterChild(t);
                    t.destroy()
                }
            }
            updatePosition() {
                if (this.numberOfPanels) {
                    const {
                        top: t,
                        left: e
                    } = this._balloonPanelView;
                    const {
                        width: n,
                        height: o
                    } = new Mh(this._balloonPanelView.element);
                    Object.assign(this, {
                        top: t,
                        left: e,
                        width: n,
                        height: o
                    })
                }
            }
        }
        var ix = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22L2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21l-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>';

        function rx(t) {
            const e = t.plugins.get("ContextualBalloon");
            if (Ev(t.editing.view.document.selection)) {
                const n = sx(t);
                e.updatePosition(n)
            }
        }

        function sx(t) {
            const e = t.editing.view;
            const n = nv.defaultPositions;
            return {
                target: e.domConverter.viewToDom(e.document.selection.getSelectedElement()),
                positions: [n.northArrowSouth, n.northArrowSouthWest, n.northArrowSouthEast, n.southArrowNorth, n.southArrowNorthWest, n.southArrowNorthEast]
            }
        }
        class ax extends nA {
            static get requires() {
                return [ex]
            }
            static get pluginName() {
                return "ImageTextAlternativeUI"
            }
            init() {
                this._createButton();
                this._createForm()
            }
            destroy() {
                super.destroy();
                this._form.destroy()
            }
            _createButton() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add("imageTextAlternative", (n => {
                    const o = t.commands.get("imageTextAlternative");
                    const i = new cw(n);
                    i.set({
                        label: e("Change image text alternative"),
                        icon: ix,
                        tooltip: true
                    });
                    i.bind("isEnabled").to(o, "isEnabled");
                    this.listenTo(i, "execute", (() => {
                        this._showForm()
                    }));
                    return i
                }))
            }
            _createForm() {
                const t = this.editor;
                const e = t.editing.view;
                const n = e.document;
                this._balloon = this.editor.plugins.get("ContextualBalloon");
                this._form = new Gy(t.locale);
                this._form.render();
                this.listenTo(this._form, "submit", (() => {
                    t.execute("imageTextAlternative", {
                        newValue: this._form.labeledInput.fieldView.element.value
                    });
                    this._hideForm(true)
                }));
                this.listenTo(this._form, "cancel", (() => {
                    this._hideForm(true)
                }));
                this._form.keystrokes.set("Esc", ((t, e) => {
                    this._hideForm(true);
                    e()
                }));
                this.listenTo(t.ui, "update", (() => {
                    if (!Ev(n.selection)) {
                        this._hideForm(true)
                    } else if (this._isVisible) {
                        rx(t)
                    }
                }));
                vw({
                    emitter: this._form,
                    activator: () => this._isVisible,
                    contextElements: [this._balloon.view.element],
                    callback: () => this._hideForm()
                })
            }
            _showForm() {
                if (this._isVisible) {
                    return
                }
                const t = this.editor;
                const e = t.commands.get("imageTextAlternative");
                const n = this._form.labeledInput;
                this._form.disableCssTransitions();
                if (!this._isInBalloon) {
                    this._balloon.add({
                        view: this._form,
                        position: sx(t)
                    })
                }
                n.fieldView.value = n.fieldView.element.value = e.value || "";
                this._form.labeledInput.fieldView.select();
                this._form.enableCssTransitions()
            }
            _hideForm(t) {
                if (!this._isInBalloon) {
                    return
                }
                if (this._form.focusTracker.isFocused) {
                    this._form.saveButtonView.focus()
                }
                this._balloon.remove(this._form);
                if (t) {
                    this.editor.editing.view.focus()
                }
            }
            get _isVisible() {
                return this._balloon.visibleView === this._form
            }
            get _isInBalloon() {
                return this._balloon.hasView(this._form)
            }
        }
        class cx extends nA {
            static get requires() {
                return [ky, ax]
            }
            static get pluginName() {
                return "ImageTextAlternative"
            }
        }
        var lx = n(38);
        var dx = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        dx.insert = "head";
        dx.singleton = true;
        var ux = rk()(lx["a"], dx);
        var hx = lx["a"].locals || {};
        class fx extends nA {
            static get requires() {
                return [Vv, fy, cx]
            }
            static get pluginName() {
                return "Image"
            }
        }
        class px extends tb {
            constructor(t) {
                super(t);
                this.buttonView = new cw(t);
                this._fileInputView = new mx(t);
                this._fileInputView.bind("acceptedType").to(this);
                this._fileInputView.bind("allowMultipleFiles").to(this);
                this._fileInputView.delegate("done").to(this);
                this.setTemplate({
                    tag: "span",
                    attributes: {
                        class: "ck-file-dialog-button"
                    },
                    children: [this.buttonView, this._fileInputView]
                });
                this.buttonView.on("execute", (() => {
                    this._fileInputView.open()
                }))
            }
            focus() {
                this.buttonView.focus()
            }
        }
        class mx extends tb {
            constructor(t) {
                super(t);
                this.set("acceptedType");
                this.set("allowMultipleFiles", false);
                const e = this.bindTemplate;
                this.setTemplate({
                    tag: "input",
                    attributes: {
                        class: ["ck-hidden"],
                        type: "file",
                        tabindex: "-1",
                        accept: e.to("acceptedType"),
                        multiple: e.to("allowMultipleFiles")
                    },
                    on: {
                        change: e.to((() => {
                            if (this.element && this.element.files && this.element.files.length) {
                                this.fire("done", this.element.files)
                            }
                            this.element.value = ""
                        }))
                    }
                })
            }
            open() {
                this.element.click()
            }
        }

        function gx(t) {
            const e = t.map((t => t.replace("+", "\\+")));
            return new RegExp(`^image\\/(${e.join("|")})$`)
        }

        function kx(t) {
            return new Promise(((e, n) => {
                const o = t.getAttribute("src");
                fetch(o).then((t => t.blob())).then((t => {
                    const n = wx(t, o);
                    const i = n.replace("image/", "");
                    const r = `image.${i}`;
                    const s = new File([t], r, {
                        type: n
                    });
                    e(s)
                })).catch(n)
            }))
        }

        function bx(t) {
            if (!t.is("element", "img") || !t.getAttribute("src")) {
                return false
            }
            return t.getAttribute("src").match(/^data:image\/\w+;base64,/g) || t.getAttribute("src").match(/^blob:/g)
        }

        function wx(t, e) {
            if (t.type) {
                return t.type
            } else if (e.match(/data:(image\/\w+);base64/)) {
                return e.match(/data:(image\/\w+);base64/)[1].toLowerCase()
            } else {
                return "image/jpeg"
            }
        }
        var Ax = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>';
        class Cx extends nA {
            static get pluginName() {
                return "ImageUploadUI"
            }
            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add("imageUpload", (n => {
                    const o = new px(n);
                    const i = t.commands.get("imageUpload");
                    const r = t.config.get("image.upload.types");
                    const s = gx(r);
                    o.set({
                        acceptedType: r.map((t => `image/${t}`)).join(","),
                        allowMultipleFiles: true
                    });
                    o.buttonView.set({
                        label: e("Insert image"),
                        icon: Ax,
                        tooltip: true
                    });
                    o.buttonView.bind("isEnabled").to(i);
                    o.on("done", ((e, n) => {
                        const o = Array.from(n).filter((t => s.test(t.type)));
                        if (o.length) {
                            t.execute("imageUpload", {
                                file: o
                            })
                        }
                    }));
                    return o
                }))
            }
        }
        class _x {
            constructor(t) {
                this.context = t
            }
            destroy() {
                this.stopListening()
            }
            static get isContextPlugin() {
                return true
            }
        }
        _s(_x, Zc);
        class vx extends _x {
            static get pluginName() {
                return "PendingActions"
            }
            init() {
                this.set("hasAny", false);
                this._actions = new vs({
                    idProperty: "_id"
                });
                this._actions.delegate("add", "remove").to(this)
            }
            add(t) {
                if (typeof t !== "string") {
                    throw new ss["a"]("pendingactions-add-invalid-message", this)
                }
                const e = Object.create(Zc);
                e.set("message", t);
                this._actions.add(e);
                this.hasAny = true;
                return e
            }
            remove(t) {
                this._actions.remove(t);
                this.hasAny = !!this._actions.length
            }
            get first() {
                return this._actions.get(0)
            } [Symbol.iterator]() {
                return this._actions[Symbol.iterator]()
            }
        }
        class yx {
            constructor() {
                const t = new window.FileReader;
                this._reader = t;
                this._data = undefined;
                this.set("loaded", 0);
                t.onprogress = t => {
                    this.loaded = t.loaded
                }
            }
            get error() {
                return this._reader.error
            }
            get data() {
                return this._data
            }
            read(t) {
                const e = this._reader;
                this.total = t.size;
                return new Promise(((n, o) => {
                    e.onload = () => {
                        const t = e.result;
                        this._data = t;
                        n(t)
                    };
                    e.onerror = () => {
                        o("error")
                    };
                    e.onabort = () => {
                        o("aborted")
                    };
                    this._reader.readAsDataURL(t)
                }))
            }
            abort() {
                this._reader.abort()
            }
        }
        _s(yx, Zc);
        class xx extends nA {
            static get pluginName() {
                return "FileRepository"
            }
            static get requires() {
                return [vx]
            }
            init() {
                this.loaders = new vs;
                this.loaders.on("add", (() => this._updatePendingAction()));
                this.loaders.on("remove", (() => this._updatePendingAction()));
                this._loadersMap = new Map;
                this._pendingAction = null;
                this.set("uploaded", 0);
                this.set("uploadTotal", null);
                this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", ((t, e) => e ? t / e * 100 : 0))
            }
            getLoader(t) {
                return this._loadersMap.get(t) || null
            }
            createLoader(t) {
                if (!this.createUploadAdapter) {
                    Object(ss["c"])("filerepository-no-upload-adapter");
                    return null
                }
                const e = new Dx(Promise.resolve(t), this.createUploadAdapter);
                this.loaders.add(e);
                this._loadersMap.set(t, e);
                if (t instanceof Promise) {
                    e.file.then((t => {
                        this._loadersMap.set(t, e)
                    })).catch((() => {}))
                }
                e.on("change:uploaded", (() => {
                    let t = 0;
                    for (const e of this.loaders) {
                        t += e.uploaded
                    }
                    this.uploaded = t
                }));
                e.on("change:uploadTotal", (() => {
                    let t = 0;
                    for (const e of this.loaders) {
                        if (e.uploadTotal) {
                            t += e.uploadTotal
                        }
                    }
                    this.uploadTotal = t
                }));
                return e
            }
            destroyLoader(t) {
                const e = t instanceof Dx ? t : this.getLoader(t);
                e._destroy();
                this.loaders.remove(e);
                this._loadersMap.forEach(((t, n) => {
                    if (t === e) {
                        this._loadersMap.delete(n)
                    }
                }))
            }
            _updatePendingAction() {
                const t = this.editor.plugins.get(vx);
                if (this.loaders.length) {
                    if (!this._pendingAction) {
                        const e = this.editor.t;
                        const n = t => `${e("Upload in progress")} ${parseInt(t)}%.`;
                        this._pendingAction = t.add(n(this.uploadedPercent));
                        this._pendingAction.bind("message").to(this, "uploadedPercent", n)
                    }
                } else {
                    t.remove(this._pendingAction);
                    this._pendingAction = null
                }
            }
        }
        _s(xx, Zc);
        class Dx {
            constructor(t, e) {
                this.id = ns();
                this._filePromiseWrapper = this._createFilePromiseWrapper(t);
                this._adapter = e(this);
                this._reader = new yx;
                this.set("status", "idle");
                this.set("uploaded", 0);
                this.set("uploadTotal", null);
                this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", ((t, e) => e ? t / e * 100 : 0));
                this.set("uploadResponse", null)
            }
            get file() {
                if (!this._filePromiseWrapper) {
                    return Promise.resolve(null)
                } else {
                    return this._filePromiseWrapper.promise.then((t => this._filePromiseWrapper ? t : null))
                }
            }
            get data() {
                return this._reader.data
            }
            read() {
                if (this.status != "idle") {
                    throw new ss["a"]("filerepository-read-wrong-status", this)
                }
                this.status = "reading";
                return this.file.then((t => this._reader.read(t))).then((t => {
                    if (this.status !== "reading") {
                        throw this.status
                    }
                    this.status = "idle";
                    return t
                })).catch((t => {
                    if (t === "aborted") {
                        this.status = "aborted";
                        throw "aborted"
                    }
                    this.status = "error";
                    throw this._reader.error ? this._reader.error : t
                }))
            }
            upload() {
                if (this.status != "idle") {
                    throw new ss["a"]("filerepository-upload-wrong-status", this)
                }
                this.status = "uploading";
                return this.file.then((() => this._adapter.upload())).then((t => {
                    this.uploadResponse = t;
                    this.status = "idle";
                    return t
                })).catch((t => {
                    if (this.status === "aborted") {
                        throw "aborted"
                    }
                    this.status = "error";
                    throw t
                }))
            }
            abort() {
                const t = this.status;
                this.status = "aborted";
                if (!this._filePromiseWrapper.isFulfilled) {
                    this._filePromiseWrapper.promise.catch((() => {}));
                    this._filePromiseWrapper.rejecter("aborted")
                } else if (t == "reading") {
                    this._reader.abort()
                } else if (t == "uploading" && this._adapter.abort) {
                    this._adapter.abort()
                }
                this._destroy()
            }
            _destroy() {
                this._filePromiseWrapper = undefined;
                this._reader = undefined;
                this._adapter = undefined;
                this.uploadResponse = undefined
            }
            _createFilePromiseWrapper(t) {
                const e = {};
                e.promise = new Promise(((n, o) => {
                    e.rejecter = o;
                    e.isFulfilled = false;
                    t.then((t => {
                        e.isFulfilled = true;
                        n(t)
                    })).catch((t => {
                        e.isFulfilled = true;
                        o(t)
                    }))
                }));
                return e
            }
        }
        _s(Dx, Zc);
        var Mx = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 700 250"><rect rx="4"/></svg>';
        var Ex = n(39);
        var Sx = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        Sx.insert = "head";
        Sx.singleton = true;
        var Tx = rk()(Ex["a"], Sx);
        var Ix = Ex["a"].locals || {};
        var Nx = n(40);
        var Px = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        Px.insert = "head";
        Px.singleton = true;
        var Bx = rk()(Nx["a"], Px);
        var Lx = Nx["a"].locals || {};
        var Ox = n(41);
        var zx = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        zx.insert = "head";
        zx.singleton = true;
        var jx = rk()(Ox["a"], zx);
        var Fx = Ox["a"].locals || {};
        class Rx extends nA {
            constructor(t) {
                super(t);
                this.placeholder = "data:image/svg+xml;utf8," + encodeURIComponent(Mx)
            }
            init() {
                const t = this.editor;
                t.editing.downcastDispatcher.on("attribute:uploadStatus:image", ((...t) => this.uploadStatusChange(...t)))
            }
            uploadStatusChange(t, e, n) {
                const o = this.editor;
                const i = e.item;
                const r = i.getAttribute("uploadId");
                if (!n.consumable.consume(e.item, t.name)) {
                    return
                }
                const s = o.plugins.get(xx);
                const a = r ? e.attributeNewValue : null;
                const c = this.placeholder;
                const l = o.editing.mapper.toViewElement(i);
                const d = n.writer;
                if (a == "reading") {
                    Vx(l, d);
                    Gx(c, l, d);
                    return
                }
                if (a == "uploading") {
                    const t = s.loaders.get(r);
                    Vx(l, d);
                    if (!t) {
                        Gx(c, l, d)
                    } else {
                        Kx(l, d);
                        Yx(l, d, t, o.editing.view);
                        Jx(l, d, t)
                    }
                    return
                }
                if (a == "complete" && s.loaders.get(r)) {
                    qx(l, d, o.editing.view)
                }
                Hx(l, d);
                Kx(l, d);
                Ux(l, d)
            }
        }

        function Vx(t, e) {
            if (!t.hasClass("ck-appear")) {
                e.addClass("ck-appear", t)
            }
        }

        function Ux(t, e) {
            e.removeClass("ck-appear", t)
        }

        function Gx(t, e, n) {
            if (!e.hasClass("ck-image-upload-placeholder")) {
                n.addClass("ck-image-upload-placeholder", e)
            }
            const o = Nv(e);
            if (o.getAttribute("src") !== t) {
                n.setAttribute("src", t, o)
            }
            if (!$x(e, "placeholder")) {
                n.insert(n.createPositionAfter(o), Qx(n))
            }
        }

        function Kx(t, e) {
            if (t.hasClass("ck-image-upload-placeholder")) {
                e.removeClass("ck-image-upload-placeholder", t)
            }
            Zx(t, e, "placeholder")
        }

        function Yx(t, e, n, o) {
            const i = Wx(e);
            e.insert(e.createPositionAt(t, "end"), i);
            n.on("change:uploadedPercent", ((t, e, n) => {
                o.change((t => {
                    t.setStyle("width", n + "%", i)
                }))
            }))
        }

        function Hx(t, e) {
            Zx(t, e, "progressBar")
        }

        function qx(t, e, n) {
            const o = e.createUIElement("div", {
                class: "ck-image-upload-complete-icon"
            });
            e.insert(e.createPositionAt(t, "end"), o);
            setTimeout((() => {
                n.change((t => t.remove(t.createRangeOn(o))))
            }), 3e3)
        }

        function Wx(t) {
            const e = t.createUIElement("div", {
                class: "ck-progress-bar"
            });
            t.setCustomProperty("progressBar", true, e);
            return e
        }

        function Qx(t) {
            const e = t.createUIElement("div", {
                class: "ck-upload-placeholder-loader"
            });
            t.setCustomProperty("placeholder", true, e);
            return e
        }

        function $x(t, e) {
            for (const n of t.getChildren()) {
                if (n.getCustomProperty(e)) {
                    return n
                }
            }
        }

        function Zx(t, e, n) {
            const o = $x(t, n);
            if (o) {
                e.remove(e.createRangeOn(o))
            }
        }

        function Jx(t, e, n) {
            if (n.data) {
                const o = Nv(t);
                e.setAttribute("src", n.data, o)
            }
        }
        class Xx extends _x {
            static get pluginName() {
                return "Notification"
            }
            init() {
                this.on("show:warning", ((t, e) => {
                    window.alert(e.message)
                }), {
                    priority: "lowest"
                })
            }
            showSuccess(t, e = {}) {
                this._showNotification({
                    message: t,
                    type: "success",
                    namespace: e.namespace,
                    title: e.title
                })
            }
            showInfo(t, e = {}) {
                this._showNotification({
                    message: t,
                    type: "info",
                    namespace: e.namespace,
                    title: e.title
                })
            }
            showWarning(t, e = {}) {
                this._showNotification({
                    message: t,
                    type: "warning",
                    namespace: e.namespace,
                    title: e.title
                })
            }
            _showNotification(t) {
                const e = `show:${t.type}` + (t.namespace ? `:${t.namespace}` : "");
                this.fire(e, {
                    message: t.message,
                    type: t.type,
                    title: t.title || ""
                })
            }
        }
        class tD {
            constructor(t) {
                this.document = t
            }
            createDocumentFragment(t) {
                return new Zl(this.document, t)
            }
            createElement(t, e, n) {
                return new Fc(this.document, t, e, n)
            }
            createText(t) {
                return new Vs(this.document, t)
            }
            clone(t, e = false) {
                return t._clone(e)
            }
            appendChild(t, e) {
                return e._appendChild(t)
            }
            insertChild(t, e, n) {
                return n._insertChild(t, e)
            }
            removeChildren(t, e, n) {
                return n._removeChildren(t, e)
            }
            remove(t) {
                const e = t.parent;
                if (e) {
                    return this.removeChildren(e.getChildIndex(t), 1, e)
                }
                return []
            }
            replace(t, e) {
                const n = t.parent;
                if (n) {
                    const o = n.getChildIndex(t);
                    this.removeChildren(o, 1, n);
                    this.insertChild(o, e, n);
                    return true
                }
                return false
            }
            unwrapElement(t) {
                const e = t.parent;
                if (e) {
                    const n = e.getChildIndex(t);
                    this.remove(t);
                    this.insertChild(n, t.getChildren(), e)
                }
            }
            rename(t, e) {
                const n = new Fc(this.document, t, e.getAttributes(), e.getChildren());
                return this.replace(e, n) ? n : null
            }
            setAttribute(t, e, n) {
                n._setAttribute(t, e)
            }
            removeAttribute(t, e) {
                e._removeAttribute(t)
            }
            addClass(t, e) {
                e._addClass(t)
            }
            removeClass(t, e) {
                e._removeClass(t)
            }
            setStyle(t, e, n) {
                if (B(t) && n === undefined) {
                    n = e
                }
                n._setStyle(t, e)
            }
            removeStyle(t, e) {
                e._removeStyle(t)
            }
            setCustomProperty(t, e, n) {
                n._setCustomProperty(t, e)
            }
            removeCustomProperty(t, e) {
                return e._removeCustomProperty(t)
            }
            createPositionAt(t, e) {
                return hl._createAt(t, e)
            }
            createPositionAfter(t) {
                return hl._createAfter(t)
            }
            createPositionBefore(t) {
                return hl._createBefore(t)
            }
            createRange(t, e) {
                return new fl(t, e)
            }
            createRangeOn(t) {
                return fl._createOn(t)
            }
            createRangeIn(t) {
                return fl._createIn(t)
            }
            createSelection(t, e, n) {
                return new gl(t, e, n)
            }
        }
        class eD extends iA {
            refresh() {
                const t = this.editor.model.document.selection.getSelectedElement();
                const e = t && t.name === "image" || false;
                this.isEnabled = Iv(this.editor.model) || e
            }
            execute(t) {
                const e = this.editor;
                const n = e.model;
                const o = e.plugins.get(xx);
                for (const e of xs(t.file)) {
                    nD(n, o, e)
                }
            }
        }

        function nD(t, e, n) {
            const o = e.createLoader(n);
            if (!o) {
                return
            }
            Tv(t, {
                uploadId: o.id
            })
        }
        class oD extends nA {
            static get requires() {
                return [xx, Xx, _A]
            }
            static get pluginName() {
                return "ImageUploadEditing"
            }
            constructor(t) {
                super(t);
                t.config.define("image", {
                    upload: {
                        types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"]
                    }
                })
            }
            init() {
                const t = this.editor;
                const e = t.model.document;
                const n = t.model.schema;
                const o = t.conversion;
                const i = t.plugins.get(xx);
                const r = gx(t.config.get("image.upload.types"));
                n.extend("image", {
                    allowAttributes: ["uploadId", "uploadStatus"]
                });
                t.commands.add("imageUpload", new eD(t));
                o.for("upcast").attributeToAttribute({
                    view: {
                        name: "img",
                        key: "uploadId"
                    },
                    model: "uploadId"
                });
                this.listenTo(t.editing.view.document, "clipboardInput", ((e, n) => {
                    if (iD(n.dataTransfer)) {
                        return
                    }
                    const o = Array.from(n.dataTransfer.files).filter((t => {
                        if (!t) {
                            return false
                        }
                        return r.test(t.type)
                    }));
                    const i = n.targetRanges.map((e => t.editing.mapper.toModelRange(e)));
                    t.model.change((n => {
                        n.setSelection(i);
                        if (o.length) {
                            e.stop();
                            t.model.enqueueChange("default", (() => {
                                t.execute("imageUpload", {
                                    file: o
                                })
                            }))
                        }
                    }))
                }));
                this.listenTo(t.plugins.get(_A), "inputTransformation", ((e, n) => {
                    const o = Array.from(t.editing.view.createRangeIn(n.content)).filter((t => bx(t.item) && !t.item.getAttribute("uploadProcessed"))).map((t => ({
                        promise: kx(t.item),
                        imageElement: t.item
                    })));
                    if (!o.length) {
                        return
                    }
                    const r = new tD(t.editing.view.document);
                    for (const t of o) {
                        r.setAttribute("uploadProcessed", true, t.imageElement);
                        const e = i.createLoader(t.promise);
                        if (e) {
                            r.setAttribute("src", "", t.imageElement);
                            r.setAttribute("uploadId", e.id, t.imageElement)
                        }
                    }
                }));
                t.editing.view.document.on("dragover", ((t, e) => {
                    e.preventDefault()
                }));
                e.on("change", (() => {
                    const n = e.differ.getChanges({
                        includeChangesInGraveyard: true
                    });
                    for (const e of n) {
                        if (e.type == "insert" && e.name != "$text") {
                            const n = e.position.nodeAfter;
                            const o = e.position.root.rootName == "$graveyard";
                            for (const e of rD(t, n)) {
                                const t = e.getAttribute("uploadId");
                                if (!t) {
                                    continue
                                }
                                const n = i.loaders.get(t);
                                if (!n) {
                                    continue
                                }
                                if (o) {
                                    n.abort()
                                } else if (n.status == "idle") {
                                    this._readAndUpload(n, e)
                                }
                            }
                        }
                    }
                }))
            }
            _readAndUpload(t, e) {
                const n = this.editor;
                const o = n.model;
                const i = n.locale.t;
                const r = n.plugins.get(xx);
                const s = n.plugins.get(Xx);
                o.enqueueChange("transparent", (t => {
                    t.setAttribute("uploadStatus", "reading", e)
                }));
                return t.read().then((() => {
                    const i = t.upload();
                    if (Ml.isSafari) {
                        const t = n.editing.mapper.toViewElement(e);
                        const o = Nv(t);
                        n.editing.view.once("render", (() => {
                            if (!o.parent) {
                                return
                            }
                            const t = n.editing.view.domConverter.mapViewToDom(o.parent);
                            if (!t) {
                                return
                            }
                            const e = t.style.display;
                            t.style.display = "none";
                            t._ckHack = t.offsetHeight;
                            t.style.display = e
                        }))
                    }
                    o.enqueueChange("transparent", (t => {
                        t.setAttribute("uploadStatus", "uploading", e)
                    }));
                    return i
                })).then((t => {
                    o.enqueueChange("transparent", (n => {
                        n.setAttributes({
                            uploadStatus: "complete",
                            src: t.default
                        }, e);
                        this._parseAndSetSrcsetAttributeOnImage(t, e, n)
                    }));
                    a()
                })).catch((n => {
                    if (t.status !== "error" && t.status !== "aborted") {
                        throw n
                    }
                    if (t.status == "error" && n) {
                        s.showWarning(n, {
                            title: i("Upload failed"),
                            namespace: "upload"
                        })
                    }
                    a();
                    o.enqueueChange("transparent", (t => {
                        t.remove(e)
                    }))
                }));

                function a() {
                    o.enqueueChange("transparent", (t => {
                        t.removeAttribute("uploadId", e);
                        t.removeAttribute("uploadStatus", e)
                    }));
                    r.destroyLoader(t)
                }
            }
            _parseAndSetSrcsetAttributeOnImage(t, e, n) {
                let o = 0;
                const i = Object.keys(t).filter((t => {
                    const e = parseInt(t, 10);
                    if (!isNaN(e)) {
                        o = Math.max(o, e);
                        return true
                    }
                })).map((e => `${t[e]} ${e}w`)).join(", ");
                if (i != "") {
                    n.setAttribute("srcset", {
                        data: i,
                        width: o
                    }, e)
                }
            }
        }

        function iD(t) {
            return Array.from(t.types).includes("text/html") && t.getData("text/html") !== ""
        }

        function rD(t, e) {
            return Array.from(t.model.createRangeOn(e)).filter((t => t.item.is("element", "image"))).map((t => t.item))
        }
        class sD extends nA {
            static get pluginName() {
                return "ImageUpload"
            }
            static get requires() {
                return [oD, Cx, Rx]
            }
        }
        const aD = "italic";
        class cD extends nA {
            static get pluginName() {
                return "ItalicEditing"
            }
            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {
                    allowAttributes: aD
                });
                t.model.schema.setAttributeProperties(aD, {
                    isFormatting: true,
                    copyOnEnter: true
                });
                t.conversion.attributeToElement({
                    model: aD,
                    view: "i",
                    upcastAlso: ["em", {
                        styles: {
                            "font-style": "italic"
                        }
                    }]
                });
                t.commands.add(aD, new sA(t, aD));
                t.keystrokes.set("CTRL+I", aD)
            }
        }
        var lD = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.586 14.633l.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>';
        const dD = "italic";
        class uD extends nA {
            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add(dD, (n => {
                    const o = t.commands.get(dD);
                    const i = new cw(n);
                    i.set({
                        label: e("Italic"),
                        icon: lD,
                        keystroke: "CTRL+I",
                        tooltip: true,
                        isToggleable: true
                    });
                    i.bind("isOn", "isEnabled").to(o, "value", "isEnabled");
                    this.listenTo(i, "execute", (() => {
                        t.execute(dD);
                        t.editing.view.focus()
                    }));
                    return i
                }))
            }
        }
        class hD extends nA {
            static get requires() {
                return [cD, uD]
            }
            static get pluginName() {
                return "Italic"
            }
        }
        class fD extends nA {
            static get pluginName() {
                return "TwoStepCaretMovement"
            }
            constructor(t) {
                super(t);
                this.attributes = new Set;
                this._overrideUid = null
            }
            init() {
                const t = this.editor;
                const e = t.model;
                const n = t.editing.view;
                const o = t.locale;
                const i = e.document.selection;
                this.listenTo(n.document, "keydown", ((t, e) => {
                    if (!i.isCollapsed) {
                        return
                    }
                    if (e.shiftKey || e.altKey || e.ctrlKey) {
                        return
                    }
                    const n = e.keyCode == Ol.arrowright;
                    const r = e.keyCode == Ol.arrowleft;
                    if (!n && !r) {
                        return
                    }
                    const s = o.contentLanguageDirection;
                    let a = false;
                    if (s === "ltr" && n || s === "rtl" && r) {
                        a = this._handleForwardMovement(e)
                    } else {
                        a = this._handleBackwardMovement(e)
                    }
                    if (a === true) {
                        t.stop()
                    }
                }), {
                    priority: is.get("high") + 1
                });
                this._isNextGravityRestorationSkipped = false;
                this.listenTo(i, "change:range", ((t, e) => {
                    if (this._isNextGravityRestorationSkipped) {
                        this._isNextGravityRestorationSkipped = false;
                        return
                    }
                    if (!this._isGravityOverridden) {
                        return
                    }
                    if (!e.directChange && bD(i.getFirstPosition(), this.attributes)) {
                        return
                    }
                    this._restoreGravity()
                }))
            }
            registerAttribute(t) {
                this.attributes.add(t)
            }
            _handleForwardMovement(t) {
                const e = this.attributes;
                const n = this.editor.model;
                const o = n.document.selection;
                const i = o.getFirstPosition();
                if (this._isGravityOverridden) {
                    return false
                }
                if (i.isAtStart && pD(o, e)) {
                    return false
                }
                if (bD(i, e)) {
                    gD(t);
                    this._overrideGravity();
                    return true
                }
            }
            _handleBackwardMovement(t) {
                const e = this.attributes;
                const n = this.editor.model;
                const o = n.document.selection;
                const i = o.getFirstPosition();
                if (this._isGravityOverridden) {
                    gD(t);
                    this._restoreGravity();
                    mD(n, e, i);
                    return true
                } else {
                    if (i.isAtStart) {
                        if (pD(o, e)) {
                            gD(t);
                            mD(n, e, i);
                            return true
                        }
                        return false
                    }
                    if (kD(i, e)) {
                        if (i.isAtEnd && !pD(o, e) && bD(i, e)) {
                            gD(t);
                            mD(n, e, i);
                            return true
                        }
                        this._isNextGravityRestorationSkipped = true;
                        this._overrideGravity();
                        return false
                    }
                }
            }
            get _isGravityOverridden() {
                return !!this._overrideUid
            }
            _overrideGravity() {
                this._overrideUid = this.editor.model.change((t => t.overrideSelectionGravity()))
            }
            _restoreGravity() {
                this.editor.model.change((t => {
                    t.restoreSelectionGravity(this._overrideUid);
                    this._overrideUid = null
                }))
            }
        }

        function pD(t, e) {
            for (const n of e) {
                if (t.hasAttribute(n)) {
                    return true
                }
            }
            return false
        }

        function mD(t, e, n) {
            const o = n.nodeBefore;
            t.change((t => {
                if (o) {
                    t.setSelectionAttribute(o.getAttributes())
                } else {
                    t.removeSelectionAttribute(e)
                }
            }))
        }

        function gD(t) {
            t.preventDefault()
        }

        function kD(t, e) {
            const n = t.getShiftedBy(-1);
            return bD(n, e)
        }

        function bD(t, e) {
            const {
                nodeBefore: n,
                nodeAfter: o
            } = t;
            for (const t of e) {
                const e = n ? n.getAttribute(t) : undefined;
                const i = o ? o.getAttribute(t) : undefined;
                if (i !== e) {
                    return true
                }
            }
            return false
        }

        function wD(t, e, n, o) {
            return o.createRange(AD(t, e, n, true, o), AD(t, e, n, false, o))
        }

        function AD(t, e, n, o, i) {
            let r = t.textNode || (o ? t.nodeBefore : t.nodeAfter);
            let s = null;
            while (r && r.getAttribute(e) == n) {
                s = r;
                r = o ? r.previousSibling : r.nextSibling
            }
            return s ? i.createPositionAt(s, o ? "before" : "after") : t
        }

        function CD(t, e, n, o) {
            const i = t.editing.view;
            const r = new Set;
            i.document.registerPostFixer((i => {
                const s = t.model.document.selection;
                let a = false;
                if (s.hasAttribute(e)) {
                    const c = wD(s.getFirstPosition(), e, s.getAttribute(e), t.model);
                    const l = t.editing.mapper.toViewRange(c);
                    for (const t of l.getItems()) {
                        if (t.is("element", n) && !t.hasClass(o)) {
                            i.addClass(o, t);
                            r.add(t);
                            a = true
                        }
                    }
                }
                return a
            }));
            t.conversion.for("editingDowncast").add((t => {
                t.on("insert", e, {
                    priority: "highest"
                });
                t.on("remove", e, {
                    priority: "highest"
                });
                t.on("attribute", e, {
                    priority: "highest"
                });
                t.on("selection", e, {
                    priority: "highest"
                });

                function e() {
                    i.change((t => {
                        for (const e of r.values()) {
                            t.removeClass(o, e);
                            r.delete(e)
                        }
                    }))
                }
            }))
        }
        class _D {
            constructor() {
                this._definitions = new Set
            }
            get length() {
                return this._definitions.size
            }
            add(t) {
                if (Array.isArray(t)) {
                    t.forEach((t => this._definitions.add(t)))
                } else {
                    this._definitions.add(t)
                }
            }
            getDispatcher() {
                return t => {
                    t.on("attribute:linkHref", ((t, e, n) => {
                        if (!n.consumable.test(e.item, "attribute:linkHref")) {
                            return
                        }
                        const o = n.writer;
                        const i = o.document.selection;
                        for (const t of this._definitions) {
                            const r = o.createAttributeElement("a", t.attributes, {
                                priority: 5
                            });
                            o.setCustomProperty("link", true, r);
                            if (t.callback(e.attributeNewValue)) {
                                if (e.item.is("selection")) {
                                    o.wrap(i.getFirstRange(), r)
                                } else {
                                    o.wrap(n.mapper.toViewRange(e.range), r)
                                }
                            } else {
                                o.unwrap(n.mapper.toViewRange(e.range), r)
                            }
                        }
                    }), {
                        priority: "high"
                    })
                }
            }
            getDispatcherForLinkedImage() {
                return t => {
                    t.on("attribute:linkHref:image", ((t, e, n) => {
                        const o = n.mapper.toViewElement(e.item);
                        const i = Array.from(o.getChildren()).find((t => t.name === "a"));
                        for (const t of this._definitions) {
                            const o = Ks(t.attributes);
                            if (t.callback(e.attributeNewValue)) {
                                for (const [t, e] of o) {
                                    if (t === "class") {
                                        n.writer.addClass(e, i)
                                    } else {
                                        n.writer.setAttribute(t, e, i)
                                    }
                                }
                            } else {
                                for (const [t, e] of o) {
                                    if (t === "class") {
                                        n.writer.removeClass(e, i)
                                    } else {
                                        n.writer.removeAttribute(t, i)
                                    }
                                }
                            }
                        }
                    }))
                }
            }
        }

        function vD(t, e, n) {
            var o = t.length;
            n = n === undefined ? o : n;
            return !e && n >= o ? t : Pa(t, e, n)
        }
        var yD = vD;
        var xD = "\\ud800-\\udfff",
            DD = "\\u0300-\\u036f",
            MD = "\\ufe20-\\ufe2f",
            ED = "\\u20d0-\\u20ff",
            SD = DD + MD + ED,
            TD = "\\ufe0e\\ufe0f";
        var ID = "\\u200d";
        var ND = RegExp("[" + ID + xD + SD + TD + "]");

        function PD(t) {
            return ND.test(t)
        }
        var BD = PD;

        function LD(t) {
            return t.split("")
        }
        var OD = LD;
        var zD = "\\ud800-\\udfff",
            jD = "\\u0300-\\u036f",
            FD = "\\ufe20-\\ufe2f",
            RD = "\\u20d0-\\u20ff",
            VD = jD + FD + RD,
            UD = "\\ufe0e\\ufe0f";
        var GD = "[" + zD + "]",
            KD = "[" + VD + "]",
            YD = "\\ud83c[\\udffb-\\udfff]",
            HD = "(?:" + KD + "|" + YD + ")",
            qD = "[^" + zD + "]",
            WD = "(?:\\ud83c[\\udde6-\\uddff]){2}",
            QD = "[\\ud800-\\udbff][\\udc00-\\udfff]",
            $D = "\\u200d";
        var ZD = HD + "?",
            JD = "[" + UD + "]?",
            XD = "(?:" + $D + "(?:" + [qD, WD, QD].join("|") + ")" + JD + ZD + ")*",
            tM = JD + ZD + XD,
            eM = "(?:" + [qD + KD + "?", KD, WD, QD, GD].join("|") + ")";
        var nM = RegExp(YD + "(?=" + YD + ")|" + eM + tM, "g");

        function oM(t) {
            return t.match(nM) || []
        }
        var iM = oM;

        function rM(t) {
            return BD(t) ? iM(t) : OD(t)
        }
        var sM = rM;

        function aM(t) {
            return function(e) {
                e = _a(e);
                var n = BD(e) ? sM(e) : undefined;
                var o = n ? n[0] : e.charAt(0);
                var i = n ? yD(n, 1).join("") : e.slice(1);
                return o[t]() + i
            }
        }
        var cM = aM;
        var lM = cM("toUpperCase");
        var dM = lM;
        const uM = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
        const hM = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i;
        const fM = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i;
        const pM = /^((\w+:(\/{2,})?)|(\W))/i;
        const mM = "Ctrl+K";

        function gM(t) {
            return t.is("attributeElement") && !!t.getCustomProperty("link")
        }

        function kM(t, {
            writer: e
        }) {
            const n = e.createAttributeElement("a", {
                href: t
            }, {
                priority: 5
            });
            e.setCustomProperty("link", true, n);
            return n
        }

        function bM(t) {
            t = String(t);
            return wM(t) ? t : "#"
        }

        function wM(t) {
            const e = t.replace(uM, "");
            return e.match(hM)
        }

        function AM(t, e) {
            const n = {
                "Open in a new tab": t("Open in a new tab"),
                Downloadable: t("Downloadable")
            };
            e.forEach((t => {
                if (t.label && n[t.label]) {
                    t.label = n[t.label]
                }
                return t
            }));
            return e
        }

        function CM(t) {
            const e = [];
            if (t) {
                for (const [n, o] of Object.entries(t)) {
                    const t = Object.assign({}, o, {
                        id: `link${dM(n)}`
                    });
                    e.push(t)
                }
            }
            return e
        }

        function _M(t, e) {
            if (!t) {
                return false
            }
            return t.is("element", "image") && e.checkAttribute("image", "linkHref")
        }

        function vM(t) {
            return fM.test(t)
        }

        function yM(t, e) {
            const n = vM(t) ? "mailto:" : e;
            const o = !!n && !pM.test(t);
            return t && o ? n + t : t
        }
        class xM extends iA {
            constructor(t) {
                super(t);
                this.manualDecorators = new vs;
                this.automaticDecorators = new _D
            }
            restoreManualDecoratorStates() {
                for (const t of this.manualDecorators) {
                    t.value = this._getDecoratorStateFromModel(t.id)
                }
            }
            refresh() {
                const t = this.editor.model;
                const e = t.document;
                const n = Y_(e.selection.getSelectedBlocks());
                if (_M(n, t.schema)) {
                    this.value = n.getAttribute("linkHref");
                    this.isEnabled = t.schema.checkAttribute(n, "linkHref")
                } else {
                    this.value = e.selection.getAttribute("linkHref");
                    this.isEnabled = t.schema.checkAttributeInSelection(e.selection, "linkHref")
                }
                for (const t of this.manualDecorators) {
                    t.value = this._getDecoratorStateFromModel(t.id)
                }
            }
            execute(t, e = {}) {
                const n = this.editor.model;
                const o = n.document.selection;
                const i = [];
                const r = [];
                for (const t in e) {
                    if (e[t]) {
                        i.push(t)
                    } else {
                        r.push(t)
                    }
                }
                n.change((e => {
                    if (o.isCollapsed) {
                        const s = o.getFirstPosition();
                        if (o.hasAttribute("linkHref")) {
                            const a = wD(s, "linkHref", o.getAttribute("linkHref"), n);
                            e.setAttribute("linkHref", t, a);
                            i.forEach((t => {
                                e.setAttribute(t, true, a)
                            }));
                            r.forEach((t => {
                                e.removeAttribute(t, a)
                            }));
                            e.setSelection(e.createPositionAfter(a.end.nodeBefore))
                        } else if (t !== "") {
                            const r = Ks(o.getAttributes());
                            r.set("linkHref", t);
                            i.forEach((t => {
                                r.set(t, true)
                            }));
                            const {
                                end: a
                            } = n.insertContent(e.createText(t, r), s);
                            e.setSelection(a)
                        } ["linkHref", ...i, ...r].forEach((t => {
                            e.removeSelectionAttribute(t)
                        }))
                    } else {
                        const s = n.schema.getValidRanges(o.getRanges(), "linkHref");
                        const a = [];
                        for (const t of o.getSelectedBlocks()) {
                            if (n.schema.checkAttribute(t, "linkHref")) {
                                a.push(e.createRangeOn(t))
                            }
                        }
                        const c = a.slice();
                        for (const t of s) {
                            if (this._isRangeToUpdate(t, a)) {
                                c.push(t)
                            }
                        }
                        for (const n of c) {
                            e.setAttribute("linkHref", t, n);
                            i.forEach((t => {
                                e.setAttribute(t, true, n)
                            }));
                            r.forEach((t => {
                                e.removeAttribute(t, n)
                            }))
                        }
                    }
                }))
            }
            _getDecoratorStateFromModel(t) {
                const e = this.editor.model;
                const n = e.document;
                const o = Y_(n.selection.getSelectedBlocks());
                if (_M(o, e.schema)) {
                    return o.getAttribute(t)
                }
                return n.selection.getAttribute(t)
            }
            _isRangeToUpdate(t, e) {
                for (const n of e) {
                    if (n.containsRange(t)) {
                        return false
                    }
                }
                return true
            }
        }
        class DM extends iA {
            refresh() {
                const t = this.editor.model;
                const e = t.document;
                const n = Y_(e.selection.getSelectedBlocks());
                if (_M(n, t.schema)) {
                    this.isEnabled = t.schema.checkAttribute(n, "linkHref")
                } else {
                    this.isEnabled = t.schema.checkAttributeInSelection(e.selection, "linkHref")
                }
            }
            execute() {
                const t = this.editor;
                const e = this.editor.model;
                const n = e.document.selection;
                const o = t.commands.get("link");
                e.change((t => {
                    const i = n.isCollapsed ? [wD(n.getFirstPosition(), "linkHref", n.getAttribute("linkHref"), e)] : e.schema.getValidRanges(n.getRanges(), "linkHref");
                    for (const e of i) {
                        t.removeAttribute("linkHref", e);
                        if (o) {
                            for (const n of o.manualDecorators) {
                                t.removeAttribute(n.id, e)
                            }
                        }
                    }
                }))
            }
        }
        class MM {
            constructor({
                id: t,
                label: e,
                attributes: n,
                defaultValue: o
            }) {
                this.id = t;
                this.set("value");
                this.defaultValue = o;
                this.label = e;
                this.attributes = n
            }
        }
        _s(MM, Zc);
        var EM = n(42);
        var SM = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        SM.insert = "head";
        SM.singleton = true;
        var TM = rk()(EM["a"], SM);
        var IM = EM["a"].locals || {};
        const NM = "ck-link_selected";
        const PM = "automatic";
        const BM = "manual";
        const LM = /^(https?:)?\/\//;
        class OM extends nA {
            static get pluginName() {
                return "LinkEditing"
            }
            static get requires() {
                return [fD, oC, _A]
            }
            constructor(t) {
                super(t);
                t.config.define("link", {
                    addTargetToExternalLinks: false
                })
            }
            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {
                    allowAttributes: "linkHref"
                });
                t.conversion.for("dataDowncast").attributeToElement({
                    model: "linkHref",
                    view: kM
                });
                t.conversion.for("editingDowncast").attributeToElement({
                    model: "linkHref",
                    view: (t, e) => kM(bM(t), e)
                });
                t.conversion.for("upcast").elementToAttribute({
                    view: {
                        name: "a",
                        attributes: {
                            href: true
                        }
                    },
                    model: {
                        key: "linkHref",
                        value: t => t.getAttribute("href")
                    }
                });
                t.commands.add("link", new xM(t));
                t.commands.add("unlink", new DM(t));
                const e = AM(t.t, CM(t.config.get("link.decorators")));
                this._enableAutomaticDecorators(e.filter((t => t.mode === PM)));
                this._enableManualDecorators(e.filter((t => t.mode === BM)));
                const n = t.plugins.get(fD);
                n.registerAttribute("linkHref");
                CD(t, "linkHref", "a", NM);
                this._enableInsertContentSelectionAttributesFixer();
                this._enableClickingAfterLink();
                this._enableTypingOverLink();
                this._handleDeleteContentAfterLink()
            }
            _enableAutomaticDecorators(t) {
                const e = this.editor;
                const n = e.commands.get("link");
                const o = n.automaticDecorators;
                if (e.config.get("link.addTargetToExternalLinks")) {
                    o.add({
                        id: "linkIsExternal",
                        mode: PM,
                        callback: t => LM.test(t),
                        attributes: {
                            target: "_blank",
                            rel: "noopener noreferrer"
                        }
                    })
                }
                o.add(t);
                if (o.length) {
                    e.conversion.for("downcast").add(o.getDispatcher())
                }
            }
            _enableManualDecorators(t) {
                if (!t.length) {
                    return
                }
                const e = this.editor;
                const n = e.commands.get("link");
                const o = n.manualDecorators;
                t.forEach((t => {
                    e.model.schema.extend("$text", {
                        allowAttributes: t.id
                    });
                    o.add(new MM(t));
                    e.conversion.for("downcast").attributeToElement({
                        model: t.id,
                        view: (e, {
                            writer: n
                        }) => {
                            if (e) {
                                const e = o.get(t.id).attributes;
                                const i = n.createAttributeElement("a", e, {
                                    priority: 5
                                });
                                n.setCustomProperty("link", true, i);
                                return i
                            }
                        }
                    });
                    e.conversion.for("upcast").elementToAttribute({
                        view: {
                            name: "a",
                            attributes: o.get(t.id).attributes
                        },
                        model: {
                            key: t.id
                        }
                    })
                }))
            }
            _enableInsertContentSelectionAttributesFixer() {
                const t = this.editor;
                const e = t.model;
                const n = e.document.selection;
                const o = t.commands.get("link");
                this.listenTo(e, "insertContent", (() => {
                    const t = n.anchor.nodeBefore;
                    const i = n.anchor.nodeAfter;
                    if (!n.hasAttribute("linkHref")) {
                        return
                    }
                    if (!t) {
                        return
                    }
                    if (!t.hasAttribute("linkHref")) {
                        return
                    }
                    if (i && i.hasAttribute("linkHref")) {
                        return
                    }
                    e.change((t => {
                        zM(t, o.manualDecorators)
                    }))
                }), {
                    priority: "low"
                })
            }
            _enableClickingAfterLink() {
                const t = this.editor;
                const e = t.commands.get("link");
                t.editing.view.addObserver(Gv);
                let n = false;
                this.listenTo(t.editing.view.document, "mousedown", (() => {
                    n = true
                }));
                this.listenTo(t.editing.view.document, "selectionChange", (() => {
                    if (!n) {
                        return
                    }
                    n = false;
                    const o = t.model.document.selection;
                    if (!o.isCollapsed) {
                        return
                    }
                    if (!o.hasAttribute("linkHref")) {
                        return
                    }
                    const i = o.getFirstPosition();
                    const r = wD(i, "linkHref", o.getAttribute("linkHref"), t.model);
                    if (i.isTouching(r.start) || i.isTouching(r.end)) {
                        t.model.change((t => {
                            zM(t, e.manualDecorators)
                        }))
                    }
                }))
            }
            _enableTypingOverLink() {
                const t = this.editor;
                const e = t.editing.view;
                let n;
                let o;
                this.listenTo(e.document, "delete", (() => {
                    o = true
                }), {
                    priority: "high"
                });
                this.listenTo(t.model, "deleteContent", (() => {
                    const e = t.model.document.selection;
                    if (e.isCollapsed) {
                        return
                    }
                    if (o) {
                        o = false;
                        return
                    }
                    if (!FM(t)) {
                        return
                    }
                    if (jM(t.model)) {
                        n = e.getAttributes()
                    }
                }), {
                    priority: "high"
                });
                this.listenTo(t.model, "insertContent", ((e, [i]) => {
                    o = false;
                    if (!FM(t)) {
                        return
                    }
                    if (!n) {
                        return
                    }
                    t.model.change((t => {
                        for (const [e, o] of n) {
                            t.setAttribute(e, o, i)
                        }
                    }));
                    n = null
                }), {
                    priority: "high"
                })
            }
            _handleDeleteContentAfterLink() {
                const t = this.editor;
                const e = t.model;
                const n = e.document.selection;
                const o = t.editing.view;
                const i = t.commands.get("link");
                let r = false;
                let s = false;
                this.listenTo(o.document, "delete", ((t, e) => {
                    s = e.domEvent.keyCode === Ol.backspace
                }), {
                    priority: "high"
                });
                this.listenTo(e, "deleteContent", (() => {
                    r = false;
                    const t = n.getFirstPosition();
                    const o = n.getAttribute("linkHref");
                    if (!o) {
                        return
                    }
                    const i = wD(t, "linkHref", o, e);
                    r = i.containsPosition(t) || i.end.isEqual(t)
                }), {
                    priority: "high"
                });
                this.listenTo(e, "deleteContent", (() => {
                    if (!s) {
                        return
                    }
                    s = false;
                    if (r) {
                        return
                    }
                    t.model.enqueueChange((t => {
                        zM(t, i.manualDecorators)
                    }))
                }), {
                    priority: "low"
                })
            }
        }

        function zM(t, e) {
            t.removeSelectionAttribute("linkHref");
            for (const n of e) {
                t.removeSelectionAttribute(n.id)
            }
        }

        function jM(t) {
            const e = t.document.selection;
            const n = e.getFirstPosition();
            const o = e.getLastPosition();
            const i = n.nodeAfter;
            if (!i) {
                return false
            }
            if (!i.is("$text")) {
                return false
            }
            if (!i.hasAttribute("linkHref")) {
                return false
            }
            const r = o.textNode || o.nodeBefore;
            if (i === r) {
                return true
            }
            const s = wD(n, "linkHref", i.getAttribute("linkHref"), t);
            return s.containsRange(t.createRange(n, o), true)
        }

        function FM(t) {
            const e = t.plugins.get("Input");
            return e.isInput(t.model.change((t => t.batch)))
        }
        class RM extends nh {
            constructor(t) {
                super(t);
                this.domEventType = "click"
            }
            onDomEvent(t) {
                this.fire(t.type, t)
            }
        }
        var VM = n(43);
        var UM = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        UM.insert = "head";
        UM.singleton = true;
        var GM = rk()(VM["a"], UM);
        var KM = VM["a"].locals || {};
        class YM extends tb {
            constructor(t, e) {
                super(t);
                const n = t.t;
                this.focusTracker = new tk;
                this.keystrokes = new Vg;
                this.urlInputView = this._createUrlInput();
                this.saveButtonView = this._createButton(n("Save"), Py, "ck-button-save");
                this.saveButtonView.type = "submit";
                this.cancelButtonView = this._createButton(n("Cancel"), By, "ck-button-cancel", "cancel");
                this._manualDecoratorSwitches = this._createManualDecoratorSwitches(e);
                this.children = this._createFormChildren(e.manualDecorators);
                this._focusables = new Ck;
                this._focusCycler = new Db({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {
                        focusPrevious: "shift + tab",
                        focusNext: "tab"
                    }
                });
                const o = ["ck", "ck-link-form", "ck-responsive-form"];
                if (e.manualDecorators.length) {
                    o.push("ck-link-form_layout-vertical", "ck-vertical-form")
                }
                this.setTemplate({
                    tag: "form",
                    attributes: {
                        class: o,
                        tabindex: "-1"
                    },
                    children: this.children
                });
                Iy(this)
            }
            getDecoratorSwitchesState() {
                return Array.from(this._manualDecoratorSwitches).reduce(((t, e) => {
                    t[e.name] = e.isOn;
                    return t
                }), {})
            }
            render() {
                super.render();
                Ny({
                    view: this
                });
                const t = [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView];
                t.forEach((t => {
                    this._focusables.add(t);
                    this.focusTracker.add(t.element)
                }));
                this.keystrokes.listenTo(this.element)
            }
            focus() {
                this._focusCycler.focusFirst()
            }
            _createUrlInput() {
                const t = this.locale.t;
                const e = new _y(this.locale, Sy);
                e.label = t("Link URL");
                return e
            }
            _createButton(t, e, n, o) {
                const i = new cw(this.locale);
                i.set({
                    label: t,
                    icon: e,
                    tooltip: true
                });
                i.extendTemplate({
                    attributes: {
                        class: n
                    }
                });
                if (o) {
                    i.delegate("execute").to(this, o)
                }
                return i
            }
            _createManualDecoratorSwitches(t) {
                const e = this.createCollection();
                for (const n of t.manualDecorators) {
                    const o = new _w(this.locale);
                    o.set({
                        name: n.id,
                        label: n.label,
                        withText: true
                    });
                    o.bind("isOn").toMany([n, t], "value", ((t, e) => e === undefined && t === undefined ? n.defaultValue : t));
                    o.on("execute", (() => {
                        n.set("value", !o.isOn)
                    }));
                    e.add(o)
                }
                return e
            }
            _createFormChildren(t) {
                const e = this.createCollection();
                e.add(this.urlInputView);
                if (t.length) {
                    const t = new tb;
                    t.setTemplate({
                        tag: "ul",
                        children: this._manualDecoratorSwitches.map((t => ({
                            tag: "li",
                            children: [t],
                            attributes: {
                                class: ["ck", "ck-list__item"]
                            }
                        }))),
                        attributes: {
                            class: ["ck", "ck-reset", "ck-list"]
                        }
                    });
                    e.add(t)
                }
                e.add(this.saveButtonView);
                e.add(this.cancelButtonView);
                return e
            }
        }
        var HM = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.077 15l.991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562l-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>';
        var qM = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7.3 17.37l-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506L13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5L9.375 17H19v1.5H8z"/></svg>';
        var WM = n(44);
        var QM = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        QM.insert = "head";
        QM.singleton = true;
        var $M = rk()(WM["a"], QM);
        var ZM = WM["a"].locals || {};
        class JM extends tb {
            constructor(t) {
                super(t);
                const e = t.t;
                this.focusTracker = new tk;
                this.keystrokes = new Vg;
                this.previewButtonView = this._createPreviewButton();
                this.unlinkButtonView = this._createButton(e("Unlink"), HM, "unlink");
                this.editButtonView = this._createButton(e("Edit link"), qM, "edit");
                this.set("href");
                this._focusables = new Ck;
                this._focusCycler = new Db({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {
                        focusPrevious: "shift + tab",
                        focusNext: "tab"
                    }
                });
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-link-actions", "ck-responsive-form"],
                        tabindex: "-1"
                    },
                    children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView]
                })
            }
            render() {
                super.render();
                const t = [this.previewButtonView, this.editButtonView, this.unlinkButtonView];
                t.forEach((t => {
                    this._focusables.add(t);
                    this.focusTracker.add(t.element)
                }));
                this.keystrokes.listenTo(this.element)
            }
            focus() {
                this._focusCycler.focusFirst()
            }
            _createButton(t, e, n) {
                const o = new cw(this.locale);
                o.set({
                    label: t,
                    icon: e,
                    tooltip: true
                });
                o.delegate("execute").to(this, n);
                return o
            }
            _createPreviewButton() {
                const t = new cw(this.locale);
                const e = this.bindTemplate;
                const n = this.t;
                t.set({
                    withText: true,
                    tooltip: n("Open link in new tab")
                });
                t.extendTemplate({
                    attributes: {
                        class: ["ck", "ck-link-actions__preview"],
                        href: e.to("href", (t => t && bM(t))),
                        target: "_blank",
                        rel: "noopener noreferrer"
                    }
                });
                t.bind("label").to(this, "href", (t => t || n("This link has no URL")));
                t.bind("isEnabled").to(this, "href", (t => !!t));
                t.template.tag = "a";
                t.template.eventListeners = {};
                return t
            }
        }
        var XM = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.077 15l.991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>';
        const tE = "link-ui";
        class eE extends nA {
            static get requires() {
                return [ex]
            }
            static get pluginName() {
                return "LinkUI"
            }
            init() {
                const t = this.editor;
                t.editing.view.addObserver(RM);
                this.actionsView = this._createActionsView();
                this.formView = this._createFormView();
                this._balloon = t.plugins.get(ex);
                this._createToolbarLinkButton();
                this._enableUserBalloonInteractions();
                t.conversion.for("editingDowncast").markerToHighlight({
                    model: tE,
                    view: {
                        classes: ["ck-fake-link-selection"]
                    }
                });
                t.conversion.for("editingDowncast").markerToElement({
                    model: tE,
                    view: {
                        name: "span",
                        classes: ["ck-fake-link-selection", "ck-fake-link-selection_collapsed"]
                    }
                })
            }
            destroy() {
                super.destroy();
                this.formView.destroy()
            }
            _createActionsView() {
                const t = this.editor;
                const e = new JM(t.locale);
                const n = t.commands.get("link");
                const o = t.commands.get("unlink");
                e.bind("href").to(n, "value");
                e.editButtonView.bind("isEnabled").to(n);
                e.unlinkButtonView.bind("isEnabled").to(o);
                this.listenTo(e, "edit", (() => {
                    this._addFormView()
                }));
                this.listenTo(e, "unlink", (() => {
                    t.execute("unlink");
                    this._hideUI()
                }));
                e.keystrokes.set("Esc", ((t, e) => {
                    this._hideUI();
                    e()
                }));
                e.keystrokes.set(mM, ((t, e) => {
                    this._addFormView();
                    e()
                }));
                return e
            }
            _createFormView() {
                const t = this.editor;
                const e = t.commands.get("link");
                const n = t.config.get("link.defaultProtocol");
                const o = new YM(t.locale, e);
                o.urlInputView.fieldView.bind("value").to(e, "value");
                o.urlInputView.bind("isReadOnly").to(e, "isEnabled", (t => !t));
                o.saveButtonView.bind("isEnabled").to(e);
                this.listenTo(o, "submit", (() => {
                    const {
                        value: e
                    } = o.urlInputView.fieldView.element;
                    const i = yM(e, n);
                    t.execute("link", i, o.getDecoratorSwitchesState());
                    this._closeFormView()
                }));
                this.listenTo(o, "cancel", (() => {
                    this._closeFormView()
                }));
                o.keystrokes.set("Esc", ((t, e) => {
                    this._closeFormView();
                    e()
                }));
                return o
            }
            _createToolbarLinkButton() {
                const t = this.editor;
                const e = t.commands.get("link");
                const n = t.t;
                t.keystrokes.set(mM, ((t, n) => {
                    n();
                    if (e.isEnabled) {
                        this._showUI(true)
                    }
                }));
                t.ui.componentFactory.add("link", (t => {
                    const o = new cw(t);
                    o.isEnabled = true;
                    o.label = n("Link");
                    o.icon = XM;
                    o.keystroke = mM;
                    o.tooltip = true;
                    o.isToggleable = true;
                    o.bind("isEnabled").to(e, "isEnabled");
                    o.bind("isOn").to(e, "value", (t => !!t));
                    this.listenTo(o, "execute", (() => this._showUI(true)));
                    return o
                }))
            }
            _enableUserBalloonInteractions() {
                const t = this.editor.editing.view.document;
                this.listenTo(t, "click", (() => {
                    const t = this._getSelectedLinkElement();
                    if (t) {
                        this._showUI()
                    }
                }));
                this.editor.keystrokes.set("Tab", ((t, e) => {
                    if (this._areActionsVisible && !this.actionsView.focusTracker.isFocused) {
                        this.actionsView.focus();
                        e()
                    }
                }), {
                    priority: "high"
                });
                this.editor.keystrokes.set("Esc", ((t, e) => {
                    if (this._isUIVisible) {
                        this._hideUI();
                        e()
                    }
                }));
                vw({
                    emitter: this.formView,
                    activator: () => this._isUIInPanel,
                    contextElements: [this._balloon.view.element],
                    callback: () => this._hideUI()
                })
            }
            _addActionsView() {
                if (this._areActionsInPanel) {
                    return
                }
                this._balloon.add({
                    view: this.actionsView,
                    position: this._getBalloonPositionData()
                })
            }
            _addFormView() {
                if (this._isFormInPanel) {
                    return
                }
                const t = this.editor;
                const e = t.commands.get("link");
                this.formView.disableCssTransitions();
                this._balloon.add({
                    view: this.formView,
                    position: this._getBalloonPositionData()
                });
                if (this._balloon.visibleView === this.formView) {
                    this.formView.urlInputView.fieldView.select()
                }
                this.formView.enableCssTransitions();
                this.formView.urlInputView.fieldView.element.value = e.value || ""
            }
            _closeFormView() {
                const t = this.editor.commands.get("link");
                t.restoreManualDecoratorStates();
                if (t.value !== undefined) {
                    this._removeFormView()
                } else {
                    this._hideUI()
                }
            }
            _removeFormView() {
                if (this._isFormInPanel) {
                    this.formView.saveButtonView.focus();
                    this._balloon.remove(this.formView);
                    this.editor.editing.view.focus();
                    this._hideFakeVisualSelection()
                }
            }
            _showUI(t = false) {
                if (!this._getSelectedLinkElement()) {
                    this._showFakeVisualSelection();
                    this._addActionsView();
                    if (t) {
                        this._balloon.showStack("main")
                    }
                    this._addFormView()
                } else {
                    if (this._areActionsVisible) {
                        this._addFormView()
                    } else {
                        this._addActionsView()
                    }
                    if (t) {
                        this._balloon.showStack("main")
                    }
                }
                this._startUpdatingUI()
            }
            _hideUI() {
                if (!this._isUIInPanel) {
                    return
                }
                const t = this.editor;
                this.stopListening(t.ui, "update");
                this.stopListening(this._balloon, "change:visibleView");
                t.editing.view.focus();
                this._removeFormView();
                this._balloon.remove(this.actionsView);
                this._hideFakeVisualSelection()
            }
            _startUpdatingUI() {
                const t = this.editor;
                const e = t.editing.view.document;
                let n = this._getSelectedLinkElement();
                let o = r();
                const i = () => {
                    const t = this._getSelectedLinkElement();
                    const e = r();
                    if (n && !t || !n && e !== o) {
                        this._hideUI()
                    } else if (this._isUIVisible) {
                        this._balloon.updatePosition(this._getBalloonPositionData())
                    }
                    n = t;
                    o = e
                };

                function r() {
                    return e.selection.focus.getAncestors().reverse().find((t => t.is("element")))
                }
                this.listenTo(t.ui, "update", i);
                this.listenTo(this._balloon, "change:visibleView", i)
            }
            get _isFormInPanel() {
                return this._balloon.hasView(this.formView)
            }
            get _areActionsInPanel() {
                return this._balloon.hasView(this.actionsView)
            }
            get _areActionsVisible() {
                return this._balloon.visibleView === this.actionsView
            }
            get _isUIInPanel() {
                return this._isFormInPanel || this._areActionsInPanel
            }
            get _isUIVisible() {
                const t = this._balloon.visibleView;
                return t == this.formView || this._areActionsVisible
            }
            _getBalloonPositionData() {
                const t = this.editor.editing.view;
                const e = this.editor.model;
                const n = t.document;
                let o = null;
                if (e.markers.has(tE)) {
                    const e = Array.from(this.editor.editing.mapper.markerNameToElements(tE));
                    const n = t.createRange(t.createPositionBefore(e[0]), t.createPositionAfter(e[e.length - 1]));
                    o = t.domConverter.viewRangeToDom(n)
                } else {
                    const e = this._getSelectedLinkElement();
                    const i = n.selection.getFirstRange();
                    o = e ? t.domConverter.mapViewToDom(e) : t.domConverter.viewRangeToDom(i)
                }
                return {
                    target: o
                }
            }
            _getSelectedLinkElement() {
                const t = this.editor.editing.view;
                const e = t.document.selection;
                if (e.isCollapsed) {
                    return nE(e.getFirstPosition())
                } else {
                    const n = e.getFirstRange().getTrimmed();
                    const o = nE(n.start);
                    const i = nE(n.end);
                    if (!o || o != i) {
                        return null
                    }
                    if (t.createRangeIn(o).getTrimmed().isEqual(n)) {
                        return o
                    } else {
                        return null
                    }
                }
            }
            _showFakeVisualSelection() {
                const t = this.editor.model;
                t.change((e => {
                    const n = t.document.selection.getFirstRange();
                    if (t.markers.has(tE)) {
                        e.updateMarker(tE, {
                            range: n
                        })
                    } else {
                        if (n.start.isAtEnd) {
                            const o = t.document.selection.focus;
                            const i = oE(n, o, e);
                            e.addMarker(tE, {
                                usingOperation: false,
                                affectsData: false,
                                range: i
                            })
                        } else {
                            e.addMarker(tE, {
                                usingOperation: false,
                                affectsData: false,
                                range: n
                            })
                        }
                    }
                }))
            }
            _hideFakeVisualSelection() {
                const t = this.editor.model;
                if (t.markers.has(tE)) {
                    t.change((t => {
                        t.removeMarker(tE)
                    }))
                }
            }
        }

        function nE(t) {
            return t.getAncestors().find((t => gM(t)))
        }

        function oE(t, e, n) {
            const o = [t.start.path[0] + 1, 0];
            const i = n.createPositionFromPath(t.start.root, o, "toNext");
            const r = n.createRange(i, t.end);
            if (r.start.path[0] > t.end.path[0]) {
                return n.createRange(e)
            }
            if (i.isAtStart && i.isAtEnd) {
                return oE(r, e, n)
            }
            return r
        }

        function iE(t, e) {
            let n = t.start;
            const o = Array.from(t.getItems()).reduce(((t, o) => {
                if (!(o.is("$text") || o.is("$textProxy"))) {
                    n = e.createPositionAfter(o);
                    return ""
                }
                return t + o.data
            }), "");
            return {
                text: o,
                range: e.createRange(n, t.end)
            }
        }
        class rE {
            constructor(t, e) {
                this.model = t;
                this.testCallback = e;
                this.hasMatch = false;
                this.set("isEnabled", true);
                this.on("change:isEnabled", (() => {
                    if (this.isEnabled) {
                        this._startListening()
                    } else {
                        this.stopListening(t.document.selection);
                        this.stopListening(t.document)
                    }
                }));
                this._startListening()
            }
            _startListening() {
                const t = this.model;
                const e = t.document;
                this.listenTo(e.selection, "change:range", ((t, {
                    directChange: n
                }) => {
                    if (!n) {
                        return
                    }
                    if (!e.selection.isCollapsed) {
                        if (this.hasMatch) {
                            this.fire("unmatched");
                            this.hasMatch = false
                        }
                        return
                    }
                    this._evaluateTextBeforeSelection("selection")
                }));
                this.listenTo(e, "change:data", ((t, e) => {
                    if (e.type == "transparent") {
                        return
                    }
                    this._evaluateTextBeforeSelection("data", {
                        batch: e
                    })
                }))
            }
            _evaluateTextBeforeSelection(t, e = {}) {
                const n = this.model;
                const o = n.document;
                const i = o.selection;
                const r = n.createRange(n.createPositionAt(i.focus.parent, 0), i.focus);
                const {
                    text: s,
                    range: a
                } = iE(r, n);
                const c = this.testCallback(s);
                if (!c && this.hasMatch) {
                    this.fire("unmatched")
                }
                this.hasMatch = !!c;
                if (c) {
                    const n = Object.assign(e, {
                        text: s,
                        range: a
                    });
                    if (typeof c == "object") {
                        Object.assign(n, c)
                    }
                    this.fire(`matched:${t}`, n)
                }
            }
        }
        _s(rE, Zc);
        const sE = 4;
        const aE = new RegExp("(^|\\s)" + "(" + "(" + "(?:(?:(?:https?|ftp):)?\\/\\/)" + "(?:\\S+(?::\\S*)?@)?" + "(?:" + "(?![-_])(?:[-\\w\\u00a1-\\uffff]{0,63}[^-_]\\.)+" + "(?:[a-z\\u00a1-\\uffff]{2,})" + ")" + "(?::\\d{2,5})?" + "(?:[/?#]\\S*)?" + ")" + "|" + "(" + "(www.|(\\S+@))" + "((?![-_])(?:[-\\w\\u00a1-\\uffff]{0,63}[^-_]\\.))+" + "(?:[a-z\\u00a1-\\uffff]{2,})" + ")" + ")$", "i");
        const cE = 2;
        class lE extends nA {
            static get pluginName() {
                return "AutoLink"
            }
            init() {
                const t = this.editor;
                const e = t.model.document.selection;
                e.on("change:range", (() => {
                    this.isEnabled = !e.anchor.parent.is("element", "codeBlock")
                }));
                this._enableTypingHandling()
            }
            afterInit() {
                this._enableEnterHandling();
                this._enableShiftEnterHandling()
            }
            _enableTypingHandling() {
                const t = this.editor;
                const e = new rE(t.model, (t => {
                    if (!dE(t)) {
                        return
                    }
                    const e = uE(t.substr(0, t.length - 1));
                    if (e) {
                        return {
                            url: e
                        }
                    }
                }));
                const n = t.plugins.get("Input");
                e.on("matched:data", ((e, o) => {
                    const {
                        batch: i,
                        range: r,
                        url: s
                    } = o;
                    if (!n.isInput(i)) {
                        return
                    }
                    const a = r.end.getShiftedBy(-1);
                    const c = a.getShiftedBy(-s.length);
                    const l = t.model.createRange(c, a);
                    this._applyAutoLink(s, l)
                }));
                e.bind("isEnabled").to(this)
            }
            _enableEnterHandling() {
                const t = this.editor;
                const e = t.model;
                const n = t.commands.get("enter");
                if (!n) {
                    return
                }
                n.on("execute", (() => {
                    const t = e.document.selection.getFirstPosition();
                    if (!t.parent.previousSibling) {
                        return
                    }
                    const n = e.createRangeIn(t.parent.previousSibling);
                    this._checkAndApplyAutoLinkOnRange(n)
                }))
            }
            _enableShiftEnterHandling() {
                const t = this.editor;
                const e = t.model;
                const n = t.commands.get("shiftEnter");
                if (!n) {
                    return
                }
                n.on("execute", (() => {
                    const t = e.document.selection.getFirstPosition();
                    const n = e.createRange(e.createPositionAt(t.parent, 0), t.getShiftedBy(-1));
                    this._checkAndApplyAutoLinkOnRange(n)
                }))
            }
            _checkAndApplyAutoLinkOnRange(t) {
                const e = this.editor.model;
                const {
                    text: n,
                    range: o
                } = iE(t, e);
                const i = uE(n);
                if (i) {
                    const t = e.createRange(o.end.getShiftedBy(-i.length), o.end);
                    this._applyAutoLink(i, t)
                }
            }
            _applyAutoLink(t, e) {
                const n = this.editor.model;
                if (!this.isEnabled || !hE(e, n)) {
                    return
                }
                n.enqueueChange((n => {
                    const o = this.editor.config.get("link.defaultProtocol");
                    const i = yM(t, o);
                    n.setAttribute("linkHref", i, e)
                }))
            }
        }

        function dE(t) {
            return t.length > sE && t[t.length - 1] === " " && t[t.length - 2] !== " "
        }

        function uE(t) {
            const e = aE.exec(t);
            return e ? e[cE] : null
        }

        function hE(t, e) {
            return e.schema.checkAttributeInSelection(e.createSelection(t), "linkHref")
        }
        class fE extends nA {
            static get requires() {
                return [OM, eE, lE]
            }
            static get pluginName() {
                return "Link"
            }
        }
        class pE extends iA {
            constructor(t, e) {
                super(t);
                this.type = e
            }
            refresh() {
                this.value = this._getValue();
                this.isEnabled = this._checkEnabled()
            }
            execute() {
                const t = this.editor.model;
                const e = t.document;
                const n = Array.from(e.selection.getSelectedBlocks()).filter((e => gE(e, t.schema)));
                const o = this.value === true;
                t.change((t => {
                    if (o) {
                        let e = n[n.length - 1].nextSibling;
                        let o = Number.POSITIVE_INFINITY;
                        let i = [];
                        while (e && e.name == "listItem" && e.getAttribute("listIndent") !== 0) {
                            const t = e.getAttribute("listIndent");
                            if (t < o) {
                                o = t
                            }
                            const n = t - o;
                            i.push({
                                element: e,
                                listIndent: n
                            });
                            e = e.nextSibling
                        }
                        i = i.reverse();
                        for (const e of i) {
                            t.setAttribute("listIndent", e.listIndent, e.element)
                        }
                    }
                    if (!o) {
                        let t = Number.POSITIVE_INFINITY;
                        for (const e of n) {
                            if (e.is("element", "listItem") && e.getAttribute("listIndent") < t) {
                                t = e.getAttribute("listIndent")
                            }
                        }
                        t = t === 0 ? 1 : t;
                        mE(n, true, t);
                        mE(n, false, t)
                    }
                    for (const e of n.reverse()) {
                        if (o && e.name == "listItem") {
                            t.rename(e, "paragraph")
                        } else if (!o && e.name != "listItem") {
                            t.setAttributes({
                                listType: this.type,
                                listIndent: 0
                            }, e);
                            t.rename(e, "listItem")
                        } else if (!o && e.name == "listItem" && e.getAttribute("listType") != this.type) {
                            t.setAttribute("listType", this.type, e)
                        }
                    }
                    this.fire("_executeCleanup", n)
                }))
            }
            _getValue() {
                const t = Y_(this.editor.model.document.selection.getSelectedBlocks());
                return !!t && t.is("element", "listItem") && t.getAttribute("listType") == this.type
            }
            _checkEnabled() {
                if (this.value) {
                    return true
                }
                const t = this.editor.model.document.selection;
                const e = this.editor.model.schema;
                const n = Y_(t.getSelectedBlocks());
                if (!n) {
                    return false
                }
                return gE(n, e)
            }
        }

        function mE(t, e, n) {
            const o = e ? t[0] : t[t.length - 1];
            if (o.is("element", "listItem")) {
                let i = o[e ? "previousSibling" : "nextSibling"];
                let r = o.getAttribute("listIndent");
                while (i && i.is("element", "listItem") && i.getAttribute("listIndent") >= n) {
                    if (r > i.getAttribute("listIndent")) {
                        r = i.getAttribute("listIndent")
                    }
                    if (i.getAttribute("listIndent") == r) {
                        t[e ? "unshift" : "push"](i)
                    }
                    i = i[e ? "previousSibling" : "nextSibling"]
                }
            }
        }

        function gE(t, e) {
            return e.checkChild(t.parent, "listItem") && !e.isObject(t)
        }
        class kE extends iA {
            constructor(t, e) {
                super(t);
                this._indentBy = e == "forward" ? 1 : -1
            }
            refresh() {
                this.isEnabled = this._checkEnabled()
            }
            execute() {
                const t = this.editor.model;
                const e = t.document;
                let n = Array.from(e.selection.getSelectedBlocks());
                t.change((t => {
                    const e = n[n.length - 1];
                    let o = e.nextSibling;
                    while (o && o.name == "listItem" && o.getAttribute("listIndent") > e.getAttribute("listIndent")) {
                        n.push(o);
                        o = o.nextSibling
                    }
                    if (this._indentBy < 0) {
                        n = n.reverse()
                    }
                    for (const e of n) {
                        const n = e.getAttribute("listIndent") + this._indentBy;
                        if (n < 0) {
                            t.rename(e, "paragraph")
                        } else {
                            t.setAttribute("listIndent", n, e)
                        }
                    }
                    this.fire("_executeCleanup", n)
                }))
            }
            _checkEnabled() {
                const t = Y_(this.editor.model.document.selection.getSelectedBlocks());
                if (!t || !t.is("element", "listItem")) {
                    return false
                }
                if (this._indentBy > 0) {
                    const e = t.getAttribute("listIndent");
                    const n = t.getAttribute("listType");
                    let o = t.previousSibling;
                    while (o && o.is("element", "listItem") && o.getAttribute("listIndent") >= e) {
                        if (o.getAttribute("listIndent") == e) {
                            return o.getAttribute("listType") == n
                        }
                        o = o.previousSibling
                    }
                    return false
                }
                return true
            }
        }
        class bE extends iA {
            refresh() {
                const t = this.editor.model;
                const e = t.document;
                const n = Y_(e.selection.getSelectedBlocks());
                this.value = !!n && n.is("element", "paragraph");
                this.isEnabled = !!n && wE(n, t.schema)
            }
            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                e.change((o => {
                    const i = (t.selection || n.selection).getSelectedBlocks();
                    for (const t of i) {
                        if (!t.is("element", "paragraph") && wE(t, e.schema)) {
                            o.rename(t, "paragraph")
                        }
                    }
                }))
            }
        }

        function wE(t, e) {
            return e.checkChild(t.parent, "paragraph") && !e.isObject(t)
        }
        class AE extends iA {
            execute(t) {
                const e = this.editor.model;
                let n = t.position;
                e.change((t => {
                    const o = t.createElement("paragraph");
                    if (!e.schema.checkChild(n.parent, o)) {
                        const i = e.schema.findAllowedParent(n, o);
                        if (!i) {
                            return
                        }
                        n = t.split(n, i).position
                    }
                    e.insertContent(o, n);
                    t.setSelection(o, "in")
                }))
            }
        }
        class CE extends nA {
            static get pluginName() {
                return "Paragraph"
            }
            init() {
                const t = this.editor;
                const e = t.model;
                t.commands.add("paragraph", new bE(t));
                t.commands.add("insertParagraph", new AE(t));
                e.schema.register("paragraph", {
                    inheritAllFrom: "$block"
                });
                t.conversion.elementToElement({
                    model: "paragraph",
                    view: "p"
                });
                t.conversion.for("upcast").elementToElement({
                    model: (t, {
                        writer: e
                    }) => {
                        if (!CE.paragraphLikeElements.has(t.name)) {
                            return null
                        }
                        if (t.isEmpty) {
                            return null
                        }
                        return e.createElement("paragraph")
                    },
                    view: /.+/,
                    converterPriority: "low"
                })
            }
        }
        CE.paragraphLikeElements = new Set(["blockquote", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "li", "p", "td", "th"]);

        function _E(t) {
            const e = t.createContainerElement("li");
            e.getFillerOffset = IE;
            return e
        }

        function vE(t, e) {
            const n = e.mapper;
            const o = e.writer;
            const i = t.getAttribute("listType") == "numbered" ? "ol" : "ul";
            const r = _E(o);
            const s = o.createContainerElement(i, null);
            o.insert(o.createPositionAt(s, 0), r);
            n.bindElements(t, r);
            return r
        }

        function yE(t, e, n, o) {
            const i = e.parent;
            const r = n.mapper;
            const s = n.writer;
            let a = r.toViewPosition(o.createPositionBefore(t));
            const c = ME(t.previousSibling, {
                sameIndent: true,
                smallerIndent: true,
                listIndent: t.getAttribute("listIndent")
            });
            const l = t.previousSibling;
            if (c && c.getAttribute("listIndent") == t.getAttribute("listIndent")) {
                const t = r.toViewElement(c);
                a = s.breakContainer(s.createPositionAfter(t))
            } else {
                if (l && l.name == "listItem") {
                    a = r.toViewPosition(o.createPositionAt(l, "end"));
                    const t = r.findMappedViewAncestor(a);
                    const e = SE(t);
                    if (e) {
                        a = s.createPositionBefore(e)
                    } else {
                        a = s.createPositionAt(t, "end")
                    }
                } else {
                    a = r.toViewPosition(o.createPositionBefore(t))
                }
            }
            a = DE(a);
            s.insert(a, i);
            if (l && l.name == "listItem") {
                const t = r.toViewElement(l);
                const n = s.createRange(s.createPositionAt(t, 0), a);
                const o = n.getWalker({
                    ignoreElementEnd: true
                });
                for (const t of o) {
                    if (t.item.is("element", "li")) {
                        const n = s.breakContainer(s.createPositionBefore(t.item));
                        const i = t.item.parent;
                        const r = s.createPositionAt(e, "end");
                        xE(s, r.nodeBefore, r.nodeAfter);
                        s.move(s.createRangeOn(i), r);
                        o.position = n
                    }
                }
            } else {
                const n = i.nextSibling;
                if (n && (n.is("element", "ul") || n.is("element", "ol"))) {
                    let o = null;
                    for (const e of n.getChildren()) {
                        const n = r.toModelElement(e);
                        if (n && n.getAttribute("listIndent") > t.getAttribute("listIndent")) {
                            o = e
                        } else {
                            break
                        }
                    }
                    if (o) {
                        s.breakContainer(s.createPositionAfter(o));
                        s.move(s.createRangeOn(o.parent), s.createPositionAt(e, "end"))
                    }
                }
            }
            xE(s, i, i.nextSibling);
            xE(s, i.previousSibling, i)
        }

        function xE(t, e, n) {
            if (!e || !n || e.name != "ul" && e.name != "ol") {
                return null
            }
            if (e.name != n.name || e.getAttribute("class") !== n.getAttribute("class")) {
                return null
            }
            return t.mergeContainers(t.createPositionAfter(e))
        }

        function DE(t) {
            return t.getLastMatchingPosition((t => t.item.is("uiElement")))
        }

        function ME(t, e) {
            const n = !!e.sameIndent;
            const o = !!e.smallerIndent;
            const i = e.listIndent;
            let r = t;
            while (r && r.name == "listItem") {
                const t = r.getAttribute("listIndent");
                if (n && i == t || o && i > t) {
                    return r
                }
                if (e.direction === "forward") {
                    r = r.nextSibling
                } else {
                    r = r.previousSibling
                }
            }
            return null
        }

        function EE(t, e, n, o) {
            t.ui.componentFactory.add(e, (i => {
                const r = t.commands.get(e);
                const s = new cw(i);
                s.set({
                    label: n,
                    icon: o,
                    tooltip: true,
                    isToggleable: true
                });
                s.bind("isOn", "isEnabled").to(r, "value", "isEnabled");
                s.on("execute", (() => {
                    t.execute(e);
                    t.editing.view.focus()
                }));
                return s
            }))
        }

        function SE(t) {
            for (const e of t.getChildren()) {
                if (e.name == "ul" || e.name == "ol") {
                    return e
                }
            }
            return null
        }

        function TE(t, e) {
            const n = [];
            const o = t.parent;
            const i = {
                ignoreElementEnd: true,
                startPosition: t,
                shallow: true,
                direction: e
            };
            const r = o.getAttribute("listIndent");
            const s = [...new Qh(i)].filter((t => t.item.is("element"))).map((t => t.item));
            for (const t of s) {
                if (!t.is("element", "listItem")) {
                    break
                }
                if (t.getAttribute("listIndent") < r) {
                    break
                }
                if (t.getAttribute("listIndent") > r) {
                    continue
                }
                if (t.getAttribute("listType") !== o.getAttribute("listType")) {
                    break
                }
                if (t.getAttribute("listStyle") !== o.getAttribute("listStyle")) {
                    break
                }
                if (e === "backward") {
                    n.unshift(t)
                } else {
                    n.push(t)
                }
            }
            return n
        }

        function IE() {
            const t = !this.isEmpty && (this.getChild(0).name == "ul" || this.getChild(0).name == "ol");
            if (this.isEmpty || t) {
                return 0
            }
            return Kc.call(this)
        }

        function NE(t) {
            return (e, n, o) => {
                const i = o.consumable;
                if (!i.test(n.item, "insert") || !i.test(n.item, "attribute:listType") || !i.test(n.item, "attribute:listIndent")) {
                    return
                }
                i.consume(n.item, "insert");
                i.consume(n.item, "attribute:listType");
                i.consume(n.item, "attribute:listIndent");
                const r = n.item;
                const s = vE(r, o);
                yE(r, s, o, t)
            }
        }

        function PE(t) {
            return (e, n, o) => {
                const i = o.mapper.toViewPosition(n.position);
                const r = i.getLastMatchingPosition((t => !t.item.is("element", "li")));
                const s = r.nodeAfter;
                const a = o.writer;
                a.breakContainer(a.createPositionBefore(s));
                a.breakContainer(a.createPositionAfter(s));
                const c = s.parent;
                const l = c.previousSibling;
                const d = a.createRangeOn(c);
                const u = a.remove(d);
                if (l && l.nextSibling) {
                    xE(a, l, l.nextSibling)
                }
                const h = o.mapper.toModelElement(s);
                WE(h.getAttribute("listIndent") + 1, n.position, d.start, s, o, t);
                for (const t of a.createRangeIn(u).getItems()) {
                    o.mapper.unbindViewElement(t)
                }
                e.stop()
            }
        }

        function BE(t, e, n) {
            if (!n.consumable.consume(e.item, "attribute:listType")) {
                return
            }
            const o = n.mapper.toViewElement(e.item);
            const i = n.writer;
            i.breakContainer(i.createPositionBefore(o));
            i.breakContainer(i.createPositionAfter(o));
            const r = o.parent;
            const s = e.attributeNewValue == "numbered" ? "ol" : "ul";
            i.rename(s, r)
        }

        function LE(t, e, n) {
            const o = n.mapper.toViewElement(e.item);
            const i = o.parent;
            const r = n.writer;
            xE(r, i, i.nextSibling);
            xE(r, i.previousSibling, i);
            for (const t of e.item.getChildren()) {
                n.consumable.consume(t, "insert")
            }
        }

        function OE(t) {
            return (e, n, o) => {
                if (!o.consumable.consume(n.item, "attribute:listIndent")) {
                    return
                }
                const i = o.mapper.toViewElement(n.item);
                const r = o.writer;
                r.breakContainer(r.createPositionBefore(i));
                r.breakContainer(r.createPositionAfter(i));
                const s = i.parent;
                const a = s.previousSibling;
                const c = r.createRangeOn(s);
                r.remove(c);
                if (a && a.nextSibling) {
                    xE(r, a, a.nextSibling)
                }
                WE(n.attributeOldValue + 1, n.range.start, c.start, i, o, t);
                yE(n.item, i, o, t);
                for (const t of n.item.getChildren()) {
                    o.consumable.consume(t, "insert")
                }
            }
        }

        function zE(t, e, n) {
            if (e.item.name != "listItem") {
                let t = n.mapper.toViewPosition(e.range.start);
                const o = n.writer;
                const i = [];
                while (t.parent.name == "ul" || t.parent.name == "ol") {
                    t = o.breakContainer(t);
                    if (t.parent.name != "li") {
                        break
                    }
                    const e = t;
                    const n = o.createPositionAt(t.parent, "end");
                    if (!e.isEqual(n)) {
                        const t = o.remove(o.createRange(e, n));
                        i.push(t)
                    }
                    t = o.createPositionAfter(t.parent)
                }
                if (i.length > 0) {
                    for (let e = 0; e < i.length; e++) {
                        const n = t.nodeBefore;
                        const r = o.insert(t, i[e]);
                        t = r.end;
                        if (e > 0) {
                            const e = xE(o, n, n.nextSibling);
                            if (e && e.parent == n) {
                                t.offset--
                            }
                        }
                    }
                    xE(o, t.nodeBefore, t.nodeAfter)
                }
            }
        }

        function jE(t, e, n) {
            const o = n.mapper.toViewPosition(e.position);
            const i = o.nodeBefore;
            const r = o.nodeAfter;
            xE(n.writer, i, r)
        }

        function FE(t, e, n) {
            if (n.consumable.consume(e.viewItem, {
                    name: true
                })) {
                const t = n.writer;
                const o = t.createElement("listItem");
                const i = $E(e.viewItem);
                t.setAttribute("listIndent", i, o);
                const r = e.viewItem.parent && e.viewItem.parent.name == "ol" ? "numbered" : "bulleted";
                t.setAttribute("listType", r, o);
                if (!n.safeInsert(o, e.modelCursor)) {
                    return
                }
                const s = HE(o, e.viewItem.getChildren(), n);
                e.modelRange = t.createRange(e.modelCursor, s);
                n.updateConversionResult(o, e)
            }
        }

        function RE(t, e, n) {
            if (n.consumable.test(e.viewItem, {
                    name: true
                })) {
                const t = Array.from(e.viewItem.getChildren());
                for (const e of t) {
                    const t = !(e.is("element", "li") || QE(e));
                    if (t) {
                        e._remove()
                    }
                }
            }
        }

        function VE(t, e, n) {
            if (n.consumable.test(e.viewItem, {
                    name: true
                })) {
                if (e.viewItem.childCount === 0) {
                    return
                }
                const t = [...e.viewItem.getChildren()];
                let n = false;
                let o = true;
                for (const e of t) {
                    if (n && !QE(e)) {
                        e._remove()
                    }
                    if (e.is("$text")) {
                        if (o) {
                            e._data = e.data.replace(/^\s+/, "")
                        }
                        if (!e.nextSibling || QE(e.nextSibling)) {
                            e._data = e.data.replace(/\s+$/, "")
                        }
                    } else if (QE(e)) {
                        n = true
                    }
                    o = false
                }
            }
        }

        function UE(t) {
            return (e, n) => {
                if (n.isPhantom) {
                    return
                }
                const o = n.modelPosition.nodeBefore;
                if (o && o.is("element", "listItem")) {
                    const e = n.mapper.toViewElement(o);
                    const i = e.getAncestors().find(QE);
                    const r = t.createPositionAt(e, 0).getWalker();
                    for (const t of r) {
                        if (t.type == "elementStart" && t.item.is("element", "li")) {
                            n.viewPosition = t.previousPosition;
                            break
                        } else if (t.type == "elementEnd" && t.item == i) {
                            n.viewPosition = t.nextPosition;
                            break
                        }
                    }
                }
            }
        }

        function GE(t) {
            return (e, n) => {
                const o = n.viewPosition;
                const i = o.parent;
                const r = n.mapper;
                if (i.name == "ul" || i.name == "ol") {
                    if (!o.isAtEnd) {
                        const e = r.toModelElement(o.nodeAfter);
                        n.modelPosition = t.createPositionBefore(e)
                    } else {
                        const e = r.toModelElement(o.nodeBefore);
                        const i = r.getModelLength(o.nodeBefore);
                        n.modelPosition = t.createPositionBefore(e).getShiftedBy(i)
                    }
                    e.stop()
                } else if (i.name == "li" && o.nodeBefore && (o.nodeBefore.name == "ul" || o.nodeBefore.name == "ol")) {
                    const s = r.toModelElement(i);
                    let a = 1;
                    let c = o.nodeBefore;
                    while (c && QE(c)) {
                        a += r.getModelLength(c);
                        c = c.previousSibling
                    }
                    n.modelPosition = t.createPositionBefore(s).getShiftedBy(a);
                    e.stop()
                }
            }
        }

        function KE(t, e) {
            const n = t.document.differ.getChanges();
            const o = new Map;
            let i = false;
            for (const o of n) {
                if (o.type == "insert" && o.name == "listItem") {
                    r(o.position)
                } else if (o.type == "insert" && o.name != "listItem") {
                    if (o.name != "$text") {
                        const n = o.position.nodeAfter;
                        if (n.hasAttribute("listIndent")) {
                            e.removeAttribute("listIndent", n);
                            i = true
                        }
                        if (n.hasAttribute("listType")) {
                            e.removeAttribute("listType", n);
                            i = true
                        }
                        if (n.hasAttribute("listStyle")) {
                            e.removeAttribute("listStyle", n);
                            i = true
                        }
                        for (const e of Array.from(t.createRangeIn(n)).filter((t => t.item.is("element", "listItem")))) {
                            r(e.previousPosition)
                        }
                    }
                    const n = o.position.getShiftedBy(o.length);
                    r(n)
                } else if (o.type == "remove" && o.name == "listItem") {
                    r(o.position)
                } else if (o.type == "attribute" && o.attributeKey == "listIndent") {
                    r(o.range.start)
                } else if (o.type == "attribute" && o.attributeKey == "listType") {
                    r(o.range.start)
                }
            }
            for (const t of o.values()) {
                s(t);
                a(t)
            }
            return i;

            function r(t) {
                const e = t.nodeBefore;
                if (!e || !e.is("element", "listItem")) {
                    const e = t.nodeAfter;
                    if (e && e.is("element", "listItem")) {
                        o.set(e, e)
                    }
                } else {
                    let t = e;
                    if (o.has(t)) {
                        return
                    }
                    for (let e = t.previousSibling; e && e.is("element", "listItem"); e = t.previousSibling) {
                        t = e;
                        if (o.has(t)) {
                            return
                        }
                    }
                    o.set(e, t)
                }
            }

            function s(t) {
                let n = 0;
                let o = null;
                while (t && t.is("element", "listItem")) {
                    const r = t.getAttribute("listIndent");
                    if (r > n) {
                        let s;
                        if (o === null) {
                            o = r - n;
                            s = n
                        } else {
                            if (o > r) {
                                o = r
                            }
                            s = r - o
                        }
                        e.setAttribute("listIndent", s, t);
                        i = true
                    } else {
                        o = null;
                        n = t.getAttribute("listIndent") + 1
                    }
                    t = t.nextSibling
                }
            }

            function a(t) {
                let n = [];
                let o = null;
                while (t && t.is("element", "listItem")) {
                    const r = t.getAttribute("listIndent");
                    if (o && o.getAttribute("listIndent") > r) {
                        n = n.slice(0, r + 1)
                    }
                    if (r != 0) {
                        if (n[r]) {
                            const o = n[r];
                            if (t.getAttribute("listType") != o) {
                                e.setAttribute("listType", o, t);
                                i = true
                            }
                        } else {
                            n[r] = t.getAttribute("listType")
                        }
                    }
                    o = t;
                    t = t.nextSibling
                }
            }
        }

        function YE(t, [e, n]) {
            let o = e.is("documentFragment") ? e.getChild(0) : e;
            let i;
            if (!n) {
                i = this.document.selection
            } else {
                i = this.createSelection(n)
            }
            if (o && o.is("element", "listItem")) {
                const t = i.getFirstPosition();
                let e = null;
                if (t.parent.is("element", "listItem")) {
                    e = t.parent
                } else if (t.nodeBefore && t.nodeBefore.is("element", "listItem")) {
                    e = t.nodeBefore
                }
                if (e) {
                    const t = e.getAttribute("listIndent");
                    if (t > 0) {
                        while (o && o.is("element", "listItem")) {
                            o._setAttribute("listIndent", o.getAttribute("listIndent") + t);
                            o = o.nextSibling
                        }
                    }
                }
            }
        }

        function HE(t, e, n) {
            const {
                writer: o,
                schema: i
            } = n;
            let r = o.createPositionAfter(t);
            for (const s of e) {
                if (s.name == "ul" || s.name == "ol") {
                    r = n.convertItem(s, r).modelCursor
                } else {
                    const e = n.convertItem(s, o.createPositionAt(t, "end"));
                    const a = e.modelRange.start.nodeAfter;
                    const c = a && a.is("element") && !i.checkChild(t, a.name);
                    if (c) {
                        if (e.modelCursor.parent.is("element", "listItem")) {
                            t = e.modelCursor.parent
                        } else {
                            t = qE(e.modelCursor)
                        }
                        r = o.createPositionAfter(t)
                    }
                }
            }
            return r
        }

        function qE(t) {
            const e = new Qh({
                startPosition: t
            });
            let n;
            do {
                n = e.next()
            } while (!n.value.item.is("element", "listItem"));
            return n.value.item
        }

        function WE(t, e, n, o, i, r) {
            const s = ME(e.nodeBefore, {
                sameIndent: true,
                smallerIndent: true,
                listIndent: t,
                foo: "b"
            });
            const a = i.mapper;
            const c = i.writer;
            const l = s ? s.getAttribute("listIndent") : null;
            let d;
            if (!s) {
                d = n
            } else if (l == t) {
                const t = a.toViewElement(s).parent;
                d = c.createPositionAfter(t)
            } else {
                const t = r.createPositionAt(s, "end");
                d = a.toViewPosition(t)
            }
            d = DE(d);
            for (const t of [...o.getChildren()]) {
                if (QE(t)) {
                    d = c.move(c.createRangeOn(t), d).end;
                    xE(c, t, t.nextSibling);
                    xE(c, t.previousSibling, t)
                }
            }
        }

        function QE(t) {
            return t.is("element", "ol") || t.is("element", "ul")
        }

        function $E(t) {
            let e = 0;
            let n = t.parent;
            while (n) {
                if (n.is("element", "li")) {
                    e++
                } else {
                    const t = n.previousSibling;
                    if (t && t.is("element", "li")) {
                        e++
                    }
                }
                n = n.parent
            }
            return e
        }
        class ZE extends nA {
            static get pluginName() {
                return "ListEditing"
            }
            static get requires() {
                return [CE]
            }
            init() {
                const t = this.editor;
                t.model.schema.register("listItem", {
                    inheritAllFrom: "$block",
                    allowAttributes: ["listType", "listIndent"]
                });
                const e = t.data;
                const n = t.editing;
                t.model.document.registerPostFixer((e => KE(t.model, e)));
                n.mapper.registerViewToModelLength("li", JE);
                e.mapper.registerViewToModelLength("li", JE);
                n.mapper.on("modelToViewPosition", UE(n.view));
                n.mapper.on("viewToModelPosition", GE(t.model));
                e.mapper.on("modelToViewPosition", UE(n.view));
                t.conversion.for("editingDowncast").add((e => {
                    e.on("insert", zE, {
                        priority: "high"
                    });
                    e.on("insert:listItem", NE(t.model));
                    e.on("attribute:listType:listItem", BE, {
                        priority: "high"
                    });
                    e.on("attribute:listType:listItem", LE, {
                        priority: "low"
                    });
                    e.on("attribute:listIndent:listItem", OE(t.model));
                    e.on("remove:listItem", PE(t.model));
                    e.on("remove", jE, {
                        priority: "low"
                    })
                }));
                t.conversion.for("dataDowncast").add((e => {
                    e.on("insert", zE, {
                        priority: "high"
                    });
                    e.on("insert:listItem", NE(t.model))
                }));
                t.conversion.for("upcast").add((t => {
                    t.on("element:ul", RE, {
                        priority: "high"
                    });
                    t.on("element:ol", RE, {
                        priority: "high"
                    });
                    t.on("element:li", VE, {
                        priority: "high"
                    });
                    t.on("element:li", FE)
                }));
                t.model.on("insertContent", YE, {
                    priority: "high"
                });
                t.commands.add("numberedList", new pE(t, "numbered"));
                t.commands.add("bulletedList", new pE(t, "bulleted"));
                t.commands.add("indentList", new kE(t, "forward"));
                t.commands.add("outdentList", new kE(t, "backward"));
                const o = n.view.document;
                this.listenTo(o, "enter", ((t, e) => {
                    const n = this.editor.model.document;
                    const o = n.selection.getLastPosition().parent;
                    if (n.selection.isCollapsed && o.name == "listItem" && o.isEmpty) {
                        this.editor.execute("outdentList");
                        e.preventDefault();
                        t.stop()
                    }
                }));
                this.listenTo(o, "delete", ((t, e) => {
                    if (e.direction !== "backward") {
                        return
                    }
                    const n = this.editor.model.document.selection;
                    if (!n.isCollapsed) {
                        return
                    }
                    const o = n.getFirstPosition();
                    if (!o.isAtStart) {
                        return
                    }
                    const i = o.parent;
                    if (i.name !== "listItem") {
                        return
                    }
                    const r = i.previousSibling && i.previousSibling.name === "listItem";
                    if (r) {
                        return
                    }
                    this.editor.execute("outdentList");
                    e.preventDefault();
                    t.stop()
                }), {
                    priority: "high"
                });
                const i = t => (e, n) => {
                    const o = this.editor.commands.get(t);
                    if (o.isEnabled) {
                        this.editor.execute(t);
                        n()
                    }
                };
                t.keystrokes.set("Tab", i("indentList"));
                t.keystrokes.set("Shift+Tab", i("outdentList"))
            }
            afterInit() {
                const t = this.editor.commands;
                const e = t.get("indent");
                const n = t.get("outdent");
                if (e) {
                    e.registerChildCommand(t.get("indentList"))
                }
                if (n) {
                    n.registerChildCommand(t.get("outdentList"))
                }
            }
        }

        function JE(t) {
            let e = 1;
            for (const n of t.getChildren()) {
                if (n.name == "ul" || n.name == "ol") {
                    for (const t of n.getChildren()) {
                        e += JE(t)
                    }
                }
            }
            return e
        }
        var XE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>';
        var tS = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>';
        class eS extends nA {
            init() {
                const t = this.editor.t;
                EE(this.editor, "numberedList", t("Numbered List"), XE);
                EE(this.editor, "bulletedList", t("Bulleted List"), tS)
            }
        }
        class nS extends nA {
            static get requires() {
                return [ZE, eS]
            }
            static get pluginName() {
                return "List"
            }
        }
        class oS extends iA {
            constructor(t, e) {
                super(t);
                this._defaultType = e
            }
            refresh() {
                this.value = this._getValue();
                this.isEnabled = this._checkEnabled()
            }
            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                let o = [...n.selection.getSelectedBlocks()].filter((t => t.is("element", "listItem"))).map((t => {
                    const n = e.change((e => e.createPositionAt(t, 0)));
                    return [...TE(n, "backward"), ...TE(n, "forward")]
                })).flat();
                o = [...new Set(o)];
                if (!o.length) {
                    return
                }
                e.change((e => {
                    for (const n of o) {
                        e.setAttribute("listStyle", t.type || this._defaultType, n)
                    }
                }))
            }
            _getValue() {
                const t = this.editor.model.document.selection.getFirstPosition().parent;
                if (t && t.is("element", "listItem")) {
                    return t.getAttribute("listStyle")
                }
                return null
            }
            _checkEnabled() {
                const t = this.editor;
                const e = t.commands.get("numberedList");
                const n = t.commands.get("bulletedList");
                return e.isEnabled || n.isEnabled
            }
        }
        const iS = "default";
        class rS extends nA {
            static get requires() {
                return [ZE]
            }
            static get pluginName() {
                return "ListStyleEditing"
            }
            init() {
                const t = this.editor;
                const e = t.model;
                e.schema.extend("listItem", {
                    allowAttributes: ["listStyle"]
                });
                t.commands.add("listStyle", new oS(t, iS));
                this.listenTo(t.commands.get("indentList"), "_executeCleanup", cS(t));
                this.listenTo(t.commands.get("outdentList"), "_executeCleanup", lS(t));
                this.listenTo(t.commands.get("bulletedList"), "_executeCleanup", pS(t));
                this.listenTo(t.commands.get("numberedList"), "_executeCleanup", pS(t));
                e.document.registerPostFixer(dS(t));
                t.conversion.for("upcast").add(sS());
                t.conversion.for("downcast").add(aS());
                this._mergeListStyleAttributeWhileMergingLists()
            }
            afterInit() {
                const t = this.editor;
                if (t.commands.get("todoList")) {
                    t.model.document.registerPostFixer(fS(t))
                }
            }
            _mergeListStyleAttributeWhileMergingLists() {
                const t = this.editor;
                const e = t.model;
                let n;
                this.listenTo(e, "deleteContent", ((t, [e]) => {
                    const o = e.getFirstPosition();
                    const i = e.getLastPosition();
                    if (o.parent === i.parent) {
                        return
                    }
                    if (!o.parent.is("element", "listItem")) {
                        return
                    }
                    const r = i.parent.nextSibling;
                    if (!r || !r.is("element", "listItem")) {
                        return
                    }
                    const s = ME(o.parent, {
                        sameIndent: true,
                        listIndent: r.getAttribute("listIndent")
                    });
                    if (!s) {
                        return
                    }
                    if (s.getAttribute("listType") === r.getAttribute("listType")) {
                        n = s
                    }
                }), {
                    priority: "high"
                });
                this.listenTo(e, "deleteContent", (() => {
                    if (!n) {
                        return
                    }
                    e.change((t => {
                        const e = ME(n.nextSibling, {
                            sameIndent: true,
                            listIndent: n.getAttribute("listIndent"),
                            direction: "forward"
                        });
                        const o = [e, ...TE(t.createPositionAt(e, 0), "forward")];
                        for (const e of o) {
                            t.setAttribute("listStyle", n.getAttribute("listStyle"), e)
                        }
                    }));
                    n = null
                }), {
                    priority: "low"
                })
            }
        }

        function sS() {
            return t => {
                t.on("element:li", ((t, e, n) => {
                    const o = e.viewItem.parent;
                    const i = o.getStyle("list-style-type") || iS;
                    const r = e.modelRange.start.nodeAfter || e.modelRange.end.nodeBefore;
                    n.writer.setAttribute("listStyle", i, r)
                }), {
                    priority: "low"
                })
            }
        }

        function aS() {
            return n => {
                n.on("attribute:listStyle:listItem", ((n, o, i) => {
                    const r = i.writer;
                    const s = o.item;
                    const a = ME(s.previousSibling, {
                        sameIndent: true,
                        listIndent: s.getAttribute("listIndent"),
                        direction: "backward"
                    });
                    const c = i.mapper.toViewElement(s);
                    if (!t(s, a)) {
                        r.breakContainer(r.createPositionBefore(c))
                    }
                    e(r, o.attributeNewValue, c.parent)
                }), {
                    priority: "low"
                })
            };

            function t(t, e) {
                return e && t.getAttribute("listType") === e.getAttribute("listType") && t.getAttribute("listIndent") === e.getAttribute("listIndent") && t.getAttribute("listStyle") === e.getAttribute("listStyle")
            }

            function e(t, e, n) {
                if (e && e !== iS) {
                    t.setStyle("list-style-type", e, n)
                } else {
                    t.removeStyle("list-style-type", n)
                }
            }
        }

        function cS(t) {
            return (e, n) => {
                let o;
                const i = n[0];
                const r = i.getAttribute("listIndent");
                const s = n.filter((t => t.getAttribute("listIndent") === r));
                if (i.previousSibling.getAttribute("listIndent") + 1 === r) {
                    o = iS
                } else {
                    const t = ME(i.previousSibling, {
                        sameIndent: true,
                        direction: "backward",
                        listIndent: r
                    });
                    o = t.getAttribute("listStyle")
                }
                t.model.change((t => {
                    for (const e of s) {
                        t.setAttribute("listStyle", o, e)
                    }
                }))
            }
        }

        function lS(t) {
            return (e, n) => {
                n = n.reverse().filter((t => t.is("element", "listItem")));
                if (!n.length) {
                    return
                }
                const o = n[0].getAttribute("listIndent");
                const i = n[0].getAttribute("listType");
                let r = n[0].previousSibling;
                if (r.is("element", "listItem")) {
                    while (r.getAttribute("listIndent") !== o) {
                        r = r.previousSibling
                    }
                } else {
                    r = null
                }
                if (!r) {
                    r = n[n.length - 1].nextSibling
                }
                if (!r || !r.is("element", "listItem")) {
                    return
                }
                if (r.getAttribute("listType") !== i) {
                    return
                }
                t.model.change((t => {
                    const e = n.filter((t => t.getAttribute("listIndent") === o));
                    for (const n of e) {
                        t.setAttribute("listStyle", r.getAttribute("listStyle"), n)
                    }
                }))
            }
        }

        function dS(t) {
            return e => {
                let n = false;
                const o = mS(t.model.document.differ.getChanges()).filter((t => t.getAttribute("listType") !== "todo"));
                if (!o.length) {
                    return n
                }
                let i = o[o.length - 1].nextSibling;
                if (!i || !i.is("element", "listItem")) {
                    i = o[o.length - 1].previousSibling;
                    if (i) {
                        const t = o[0].getAttribute("listIndent");
                        while (i.is("element", "listItem") && i.getAttribute("listIndent") !== t) {
                            i = i.previousSibling;
                            if (!i) {
                                break
                            }
                        }
                    }
                }
                for (const t of o) {
                    if (!t.hasAttribute("listStyle")) {
                        if (uS(i, t)) {
                            e.setAttribute("listStyle", i.getAttribute("listStyle"), t)
                        } else {
                            e.setAttribute("listStyle", iS, t)
                        }
                        n = true
                    } else {
                        const o = t.previousSibling;
                        if (hS(o, t)) {
                            e.setAttribute("listStyle", o.getAttribute("listStyle"), t);
                            n = true
                        }
                    }
                }
                return n
            }
        }

        function uS(t, e) {
            if (!t) {
                return false
            }
            const n = t.getAttribute("listStyle");
            if (!n) {
                return false
            }
            if (n === iS) {
                return false
            }
            if (t.getAttribute("listType") !== e.getAttribute("listType")) {
                return false
            }
            return true
        }

        function hS(t, e) {
            if (!t || !t.is("element", "listItem")) {
                return false
            }
            if (e.getAttribute("listType") !== t.getAttribute("listType")) {
                return false
            }
            const n = t.getAttribute("listIndent");
            if (n < 1 || n !== e.getAttribute("listIndent")) {
                return false
            }
            const o = t.getAttribute("listStyle");
            if (!o || o === e.getAttribute("listStyle")) {
                return false
            }
            return true
        }

        function fS(t) {
            return e => {
                const n = mS(t.model.document.differ.getChanges()).filter((t => t.getAttribute("listType") === "todo" && t.hasAttribute("listStyle")));
                if (!n.length) {
                    return false
                }
                for (const t of n) {
                    e.removeAttribute("listStyle", t)
                }
                return true
            }
        }

        function pS(t) {
            return (e, n) => {
                n = n.filter((t => t.is("element", "listItem")));
                t.model.change((t => {
                    for (const e of n) {
                        t.removeAttribute("listStyle", e)
                    }
                }))
            }
        }

        function mS(t) {
            const e = [];
            for (const n of t) {
                const t = gS(n);
                if (t && t.is("element", "listItem")) {
                    e.push(t)
                }
            }
            return e
        }

        function gS(t) {
            if (t.type === "attribute") {
                return t.range.start.nodeAfter
            }
            if (t.type === "insert") {
                return t.position.nodeAfter
            }
            return null
        }
        var kS = n(45);
        var bS = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        bS.insert = "head";
        bS.singleton = true;
        var wS = rk()(kS["a"], bS);
        var AS = kS["a"].locals || {};
        class CS extends tb {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("icon");
                this.set("isEnabled", true);
                this.set("isOn", false);
                this.set("isToggleable", false);
                this.set("isVisible", true);
                this.set("keystroke");
                this.set("label");
                this.set("tabindex", -1);
                this.set("tooltip");
                this.set("tooltipPosition", "s");
                this.set("type", "button");
                this.set("withText", false);
                this.children = this.createCollection();
                this.actionView = this._createActionView();
                this.arrowView = this._createArrowView();
                this.keystrokes = new Vg;
                this.focusTracker = new tk;
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-splitbutton", e.if("isVisible", "ck-hidden", (t => !t)), this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")]
                    },
                    children: this.children
                })
            }
            render() {
                super.render();
                this.children.add(this.actionView);
                this.children.add(this.arrowView);
                this.focusTracker.add(this.actionView.element);
                this.focusTracker.add(this.arrowView.element);
                this.keystrokes.listenTo(this.element);
                this.keystrokes.set("arrowright", ((t, e) => {
                    if (this.focusTracker.focusedElement === this.actionView.element) {
                        this.arrowView.focus();
                        e()
                    }
                }));
                this.keystrokes.set("arrowleft", ((t, e) => {
                    if (this.focusTracker.focusedElement === this.arrowView.element) {
                        this.actionView.focus();
                        e()
                    }
                }))
            }
            focus() {
                this.actionView.focus()
            }
            _createActionView() {
                const t = new cw;
                t.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this);
                t.extendTemplate({
                    attributes: {
                        class: "ck-splitbutton__action"
                    }
                });
                t.delegate("execute").to(this);
                return t
            }
            _createArrowView() {
                const t = new cw;
                const e = t.bindTemplate;
                t.icon = lw;
                t.extendTemplate({
                    attributes: {
                        class: "ck-splitbutton__arrow",
                        "aria-haspopup": true,
                        "aria-expanded": e.to("isOn", (t => String(t)))
                    }
                });
                t.bind("isEnabled").to(this);
                t.delegate("execute").to(this, "open");
                return t
            }
        }
        var _S = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6z"/></svg>';
        var vS = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4z"/></svg>';
        var yS = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M14 27v6H8v-6h6zm0-9v6H8v-6h6zm0-9v6H8V9h6z"/></svg>';
        var xS = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M10.29 15V8.531H9.286c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.343 0v-1.235h-1.235V15h1.235zM11.3 24v-1.147H8.848c.064-.111.148-.226.252-.343.104-.117.351-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.494-.824.104-.263.156-.539.156-.829 0-.51-.182-.936-.545-1.279-.363-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.153-.155.358-.233.616-.233.26 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.468.536-1.024 1.055-.692.641-1.155 1.156-1.389 1.544-.234.389-.375.8-.422 1.233H11.3zm2.333 0v-1.235h-1.235V24h1.235zM9.204 34.11c.615 0 1.129-.2 1.542-.598.413-.398.62-.88.62-1.446 0-.39-.11-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.619-.337.928-.788.928-1.353 0-.399-.151-.756-.453-1.073-.366-.386-.852-.58-1.459-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.668.55c-.16.232-.28.544-.358.933l1.138.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.215 0 .386.065.515.194s.193.302.193.518c0 .255-.087.46-.263.613-.176.154-.43.227-.765.218l-.136 1.006c.22-.061.409-.092.567-.092.24 0 .444.09.61.272.168.182.251.428.251.739 0 .328-.087.589-.261.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.307-.698l-1.196.145c.062.542.285.98.668 1.316.384.335.868.503 1.45.503zm4.43-.11v-1.235h-1.236V34h1.235z"/></svg>';
        var DS = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M5.714 15.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm6.078.914V8.531H10.79c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.344 0v-1.235h-1.235V15h1.235zm-9.422 9.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm7.088.914v-1.147H10.35c.065-.111.149-.226.253-.343.104-.117.35-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.493-.824.104-.263.156-.539.156-.829 0-.51-.181-.936-.544-1.279-.364-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.152-.155.357-.233.615-.233.261 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.467.536-1.024 1.055-.691.641-1.154 1.156-1.388 1.544-.235.389-.375.8-.422 1.233h4.328zm2.334 0v-1.235h-1.235V24h1.235zM5.714 34.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm4.992 1.024c.616 0 1.13-.2 1.543-.598.413-.398.62-.88.62-1.446 0-.39-.111-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.618-.337.927-.788.927-1.353 0-.399-.15-.756-.452-1.073-.366-.386-.853-.58-1.46-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.667.55c-.16.232-.28.544-.359.933l1.139.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.214 0 .386.065.515.194s.193.302.193.518c0 .255-.088.46-.264.613-.175.154-.43.227-.764.218l-.136 1.006c.22-.061.408-.092.566-.092.24 0 .444.09.611.272.167.182.25.428.25.739 0 .328-.086.589-.26.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.308-.698l-1.195.145c.062.542.284.98.668 1.316.384.335.867.503 1.45.503zm4.43-.11v-1.235h-1.235V34h1.235z"/></svg>';
        var MS = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.88 8.7V7.558h-1.234V8.7h1.234zm0 5.3V9.333h-1.234V14h1.234zm2.5 0v-1.235h-1.234V14h1.235zm-4.75 4.7v-1.142H8.395V18.7H9.63zm0 5.3v-4.667H8.395V24H9.63zm2.5-5.3v-1.142h-1.234V18.7h1.235zm0 5.3v-4.667h-1.234V24h1.235zm2.501 0v-1.235h-1.235V24h1.235zM7.38 28.7v-1.142H6.145V28.7H7.38zm0 5.3v-4.667H6.145V34H7.38zm2.5-5.3v-1.142H8.646V28.7H9.88zm0 5.3v-4.667H8.646V34H9.88zm2.5-5.3v-1.142h-1.234V28.7h1.235zm0 5.3v-4.667h-1.234V34h1.235zm2.501 0v-1.235h-1.235V34h1.235z"/></svg>';
        var ES = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.916 15V8.558h-1.301V15h1.3zm2.465 0v-1.235h-1.235V15h1.235zM9.665 25v-6.442h-1.3V25h1.3zm2.5 0v-6.442h-1.3V25h1.3zm2.466 0v-1.235h-1.235V25h1.235zm-7.216 9v-6.442h-1.3V34h1.3zm2.5 0v-6.442h-1.3V34h1.3zm2.501 0v-6.442h-1.3V34h1.3zm2.465 0v-1.235h-1.235V34h1.235z"/></svg>';
        var SS = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M9.62 14.105c.272 0 .528-.05.768-.153s.466-.257.677-.462c.009.024.023.072.044.145.047.161.086.283.119.365h1.221a2.649 2.649 0 0 1-.222-.626c-.04-.195-.059-.498-.059-.908l.013-1.441c0-.536-.055-.905-.165-1.105-.11-.201-.3-.367-.569-.497-.27-.13-.68-.195-1.23-.195-.607 0-1.064.108-1.371.325-.308.217-.525.55-.65 1.002l1.12.202c.076-.217.176-.369.299-.455.123-.086.294-.13.514-.13.325 0 .546.05.663.152.118.101.176.27.176.508v.123c-.222.093-.622.194-1.2.303-.427.082-.755.178-.982.288-.227.11-.403.268-.53.474a1.327 1.327 0 0 0-.188.706c0 .398.138.728.415.988.277.261.656.391 1.136.391zm.368-.87a.675.675 0 0 1-.492-.189.606.606 0 0 1-.193-.448c0-.176.08-.32.241-.435.106-.07.33-.142.673-.215a7.19 7.19 0 0 0 .751-.19v.247c0 .296-.016.496-.048.602a.773.773 0 0 1-.295.409 1.07 1.07 0 0 1-.637.22zm4.645.765v-1.235h-1.235V14h1.235zM10.2 25.105c.542 0 1.003-.215 1.382-.646.38-.43.57-1.044.57-1.84 0-.771-.187-1.362-.559-1.774a1.82 1.82 0 0 0-1.41-.617c-.522 0-.973.216-1.354.65v-2.32H7.594V25h1.147v-.686a1.9 1.9 0 0 0 .67.592c.26.133.523.2.79.2zm-.299-.975c-.354 0-.638-.164-.852-.492-.153-.232-.229-.59-.229-1.073 0-.468.098-.818.295-1.048a.93.93 0 0 1 .738-.345c.302 0 .55.118.743.354.193.236.29.62.29 1.154 0 .5-.096.868-.288 1.1-.192.233-.424.35-.697.35zm4.478.87v-1.235h-1.234V25h1.234zm-4.017 9.105c.6 0 1.08-.142 1.437-.426.357-.284.599-.704.725-1.261l-1.213-.207c-.061.326-.167.555-.316.688a.832.832 0 0 1-.576.2.916.916 0 0 1-.75-.343c-.185-.228-.278-.62-.278-1.173 0-.498.091-.853.274-1.066.183-.212.429-.318.736-.318.232 0 .42.061.565.184.145.123.238.306.28.55l1.216-.22c-.146-.501-.387-.874-.722-1.119-.336-.244-.788-.366-1.356-.366-.695 0-1.245.214-1.653.643-.407.43-.61 1.03-.61 1.8 0 .762.202 1.358.608 1.788.406.431.95.646 1.633.646zM14.633 34v-1.235h-1.235V34h1.235z"/></svg>';
        var TS = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M7.88 15l.532-1.463h2.575L11.549 15h1.415l-2.58-6.442H9.01L6.5 15h1.38zm2.69-2.549H8.811l.87-2.39.887 2.39zM14.88 15v-1.235h-1.234V15h1.234zM9.352 25c.83-.006 1.352-.02 1.569-.044.346-.038.636-.14.872-.305.236-.166.422-.387.558-.664.137-.277.205-.562.205-.855 0-.372-.106-.695-.317-.97-.21-.276-.512-.471-.905-.585a1.51 1.51 0 0 0 .661-.567 1.5 1.5 0 0 0 .244-.83c0-.28-.066-.53-.197-.754a1.654 1.654 0 0 0-.495-.539 1.676 1.676 0 0 0-.672-.266c-.25-.042-.63-.063-1.14-.063H7.158V25h2.193zm.142-3.88H8.46v-1.49h.747c.612 0 .983.007 1.112.022.217.026.38.102.49.226.11.125.165.287.165.486a.68.68 0 0 1-.192.503.86.86 0 0 1-.525.23 11.47 11.47 0 0 1-.944.023h.18zm.17 2.795H8.46v-1.723h1.05c.592 0 .977.03 1.154.092.177.062.313.16.406.295a.84.84 0 0 1 .14.492c0 .228-.06.41-.181.547a.806.806 0 0 1-.473.257c-.126.026-.423.04-.892.04zM14.88 25v-1.235h-1.234V25h1.234zm-5.018 9.11c.691 0 1.262-.17 1.711-.512.45-.341.772-.864.965-1.567l-1.261-.4c-.109.472-.287.818-.536 1.037-.25.22-.547.33-.892.33-.47 0-.85-.173-1.143-.519-.293-.345-.44-.925-.44-1.74 0-.767.15-1.322.447-1.665.297-.343.684-.514 1.162-.514.346 0 .64.096.881.29.242.193.4.457.477.79l1.288-.307c-.147-.516-.367-.911-.66-1.187-.492-.465-1.132-.698-1.92-.698-.902 0-1.63.296-2.184.89-.554.593-.83 1.426-.83 2.498 0 1.014.275 1.813.825 2.397.551.585 1.254.877 2.11.877zM14.88 34v-1.235h-1.234V34h1.234z"/></svg>';
        var IS = n(46);
        var NS = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        NS.insert = "head";
        NS.singleton = true;
        var PS = rk()(IS["a"], NS);
        var BS = IS["a"].locals || {};
        class LS extends nA {
            static get pluginName() {
                return "ListStyleUI"
            }
            init() {
                const t = this.editor;
                const e = t.locale.t;
                t.ui.componentFactory.add("bulletedList", OS({
                    editor: t,
                    parentCommandName: "bulletedList",
                    buttonLabel: e("Bulleted List"),
                    buttonIcon: tS,
                    toolbarAriaLabel: e("Bulleted list styles toolbar"),
                    styleDefinitions: [{
                        label: e("Toggle the disc list style"),
                        tooltip: e("Disc"),
                        type: "disc",
                        icon: _S
                    }, {
                        label: e("Toggle the circle list style"),
                        tooltip: e("Circle"),
                        type: "circle",
                        icon: vS
                    }, {
                        label: e("Toggle the square list style"),
                        tooltip: e("Square"),
                        type: "square",
                        icon: yS
                    }]
                }));
                t.ui.componentFactory.add("numberedList", OS({
                    editor: t,
                    parentCommandName: "numberedList",
                    buttonLabel: e("Numbered List"),
                    buttonIcon: XE,
                    toolbarAriaLabel: e("Numbered list styles toolbar"),
                    styleDefinitions: [{
                        label: e("Toggle the decimal list style"),
                        tooltip: e("Decimal"),
                        type: "decimal",
                        icon: xS
                    }, {
                        label: e("Toggle the decimal with leading zero list style"),
                        tooltip: e("Decimal with leading zero"),
                        type: "decimal-leading-zero",
                        icon: DS
                    }, {
                        label: e("Toggle the lower–roman list style"),
                        tooltip: e("Lower–roman"),
                        type: "lower-roman",
                        icon: MS
                    }, {
                        label: e("Toggle the upper–roman list style"),
                        tooltip: e("Upper-roman"),
                        type: "upper-roman",
                        icon: ES
                    }, {
                        label: e("Toggle the lower–latin list style"),
                        tooltip: e("Lower-latin"),
                        type: "lower-latin",
                        icon: SS
                    }, {
                        label: e("Toggle the upper–latin list style"),
                        tooltip: e("Upper-latin"),
                        type: "upper-latin",
                        icon: TS
                    }]
                }))
            }
        }

        function OS({
            editor: t,
            parentCommandName: e,
            buttonLabel: n,
            buttonIcon: o,
            toolbarAriaLabel: i,
            styleDefinitions: r
        }) {
            const s = t.commands.get(e);
            const a = t.commands.get("listStyle");
            return c => {
                const l = Nw(c, CS);
                const d = l.buttonView;
                const u = zS({
                    editor: t,
                    parentCommandName: e,
                    listStyleCommand: a
                });
                Pw(l, r.map(u));
                l.bind("isEnabled").to(s);
                l.toolbarView.ariaLabel = i;
                l.class = "ck-list-styles-dropdown";
                d.on("execute", (() => {
                    t.execute(e);
                    t.editing.view.focus()
                }));
                d.set({
                    label: n,
                    icon: o,
                    tooltip: true,
                    isToggleable: true
                });
                d.bind("isOn").to(s, "value", (t => !!t));
                return l
            }
        }

        function zS({
            editor: t,
            listStyleCommand: e,
            parentCommandName: n
        }) {
            const o = t.locale;
            const i = t.commands.get(n);
            return ({
                label: r,
                type: s,
                icon: a,
                tooltip: c
            }) => {
                const l = new cw(o);
                l.set({
                    label: r,
                    icon: a,
                    tooltip: c
                });
                e.on("change:value", (() => {
                    l.isOn = e.value === s
                }));
                l.on("execute", (() => {
                    if (i.value) {
                        if (e.value !== s) {
                            t.execute("listStyle", {
                                type: s
                            })
                        } else {
                            t.execute("listStyle", {
                                type: e._defaultType
                            })
                        }
                    } else {
                        t.model.change((() => {
                            t.execute(n);
                            t.execute("listStyle", {
                                type: s
                            })
                        }))
                    }
                    t.editing.view.focus()
                }));
                return l
            }
        }
        class jS extends nA {
            static get requires() {
                return [rS, LS]
            }
            static get pluginName() {
                return "ListStyle"
            }
        }

        function FS(t, e) {
            return t => {
                t.on("attribute:url:media", n)
            };

            function n(n, o, i) {
                if (!i.consumable.consume(o.item, n.name)) {
                    return
                }
                const r = o.attributeNewValue;
                const s = i.writer;
                const a = i.mapper.toViewElement(o.item);
                const c = [...a.getChildren()].find((t => t.getCustomProperty("media-content")));
                s.remove(c);
                const l = t.getMediaViewElement(s, r, e);
                s.insert(s.createPositionAt(a, 0), l)
            }
        }

        function RS(t, e, n) {
            e.setCustomProperty("media", true, t);
            return gv(t, e, {
                label: n
            })
        }

        function VS(t) {
            const e = t.getSelectedElement();
            if (e && US(e)) {
                return e
            }
            return null
        }

        function US(t) {
            return !!t.getCustomProperty("media") && mv(t)
        }

        function GS(t, e, n, o) {
            const i = t.createContainerElement("figure", {
                class: "media"
            });
            t.insert(t.createPositionAt(i, 0), e.getMediaViewElement(t, n, o));
            return i
        }

        function KS(t) {
            const e = t.getSelectedElement();
            if (e && e.is("element", "media")) {
                return e
            }
            return null
        }

        function YS(t, e, n) {
            t.change((o => {
                const i = o.createElement("media", {
                    url: e
                });
                t.insertContent(i, n);
                o.setSelection(i, "on")
            }))
        }
        class HS extends iA {
            refresh() {
                const t = this.editor.model;
                const e = t.document.selection;
                const n = t.schema;
                const o = Cv(e, t);
                const i = KS(e);
                let r = o.parent;
                if (r.isEmpty && !t.schema.isLimit(r)) {
                    r = r.parent
                }
                this.value = i ? i.getAttribute("url") : null;
                this.isEnabled = n.checkChild(r, "media")
            }
            execute(t) {
                const e = this.editor.model;
                const n = e.document.selection;
                const o = KS(n);
                if (o) {
                    e.change((e => {
                        e.setAttribute("url", t, o)
                    }))
                } else {
                    const o = Cv(n, e);
                    YS(e, t, o)
                }
            }
        }
        var qS = '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>';
        const WS = "0 0 64 42";
        class QS {
            constructor(t, e) {
                const n = e.providers;
                const o = e.extraProviders || [];
                const i = new Set(e.removeProviders);
                const r = n.concat(o).filter((t => {
                    const e = t.name;
                    if (!e) {
                        Object(ss["c"])("media-embed-no-provider-name", {
                            provider: t
                        });
                        return false
                    }
                    return !i.has(e)
                }));
                this.locale = t;
                this.providerDefinitions = r
            }
            hasMedia(t) {
                return !!this._getMedia(t)
            }
            getMediaViewElement(t, e, n) {
                return this._getMedia(e).getViewElement(t, n)
            }
            _getMedia(t) {
                if (!t) {
                    return new $S(this.locale)
                }
                t = t.trim();
                for (const e of this.providerDefinitions) {
                    const n = e.html;
                    const o = xs(e.url);
                    for (const e of o) {
                        const o = this._getUrlMatches(t, e);
                        if (o) {
                            return new $S(this.locale, t, o, n)
                        }
                    }
                }
                return null
            }
            _getUrlMatches(t, e) {
                let n = t.match(e);
                if (n) {
                    return n
                }
                let o = t.replace(/^https?:\/\//, "");
                n = o.match(e);
                if (n) {
                    return n
                }
                o = o.replace(/^www\./, "");
                n = o.match(e);
                if (n) {
                    return n
                }
                return null
            }
        }
        class $S {
            constructor(t, e, n, o) {
                this.url = this._getValidUrl(e);
                this._t = t.t;
                this._match = n;
                this._previewRenderer = o
            }
            getViewElement(t, e) {
                const n = {};
                let o;
                if (e.renderForEditingView || e.renderMediaPreview && this.url && this._previewRenderer) {
                    if (this.url) {
                        n["data-oembed-url"] = this.url
                    }
                    if (e.renderForEditingView) {
                        n.class = "ck-media__wrapper"
                    }
                    const i = this._getPreviewHtml(e);
                    o = t.createRawElement("div", n, (function(t) {
                        t.innerHTML = i
                    }))
                } else {
                    if (this.url) {
                        n.url = this.url
                    }
                    o = t.createEmptyElement("oembed", n)
                }
                t.setCustomProperty("media-content", true, o);
                return o
            }
            _getPreviewHtml(t) {
                if (this._previewRenderer) {
                    return this._previewRenderer(this._match)
                } else {
                    if (this.url && t.renderForEditingView) {
                        return this._getPlaceholderHtml()
                    }
                    return ""
                }
            }
            _getPlaceholderHtml() {
                const t = new ow;
                const e = new Jb;
                t.text = this._t("Open media in new tab");
                e.content = qS;
                e.viewBox = WS;
                const n = new yk({
                    tag: "div",
                    attributes: {
                        class: "ck ck-reset_all ck-media__placeholder"
                    },
                    children: [{
                        tag: "div",
                        attributes: {
                            class: "ck-media__placeholder__icon"
                        },
                        children: [e]
                    }, {
                        tag: "a",
                        attributes: {
                            class: "ck-media__placeholder__url",
                            target: "_blank",
                            rel: "noopener noreferrer",
                            href: this.url
                        },
                        children: [{
                            tag: "span",
                            attributes: {
                                class: "ck-media__placeholder__url__text"
                            },
                            children: [this.url]
                        }, t]
                    }]
                }).render();
                return n.outerHTML
            }
            _getValidUrl(t) {
                if (!t) {
                    return null
                }
                if (t.match(/^https?/)) {
                    return t
                }
                return "https://" + t
            }
        }
        var ZS = n(47);
        var JS = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        JS.insert = "head";
        JS.singleton = true;
        var XS = rk()(ZS["a"], JS);
        var tT = ZS["a"].locals || {};
        class eT extends nA {
            static get pluginName() {
                return "MediaEmbedEditing"
            }
            constructor(t) {
                super(t);
                t.config.define("mediaEmbed", {
                    providers: [{
                        name: "dailymotion",
                        url: /^dailymotion\.com\/video\/(\w+)/,
                        html: t => {
                            const e = t[1];
                            return '<div style="position: relative; padding-bottom: 100%; height: 0; ">' + `<iframe src="https://www.dailymotion.com/embed/video/${e}" ` + 'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' + 'frameborder="0" width="480" height="270" allowfullscreen allow="autoplay">' + "</iframe>" + "</div>"
                        }
                    }, {
                        name: "spotify",
                        url: [/^open\.spotify\.com\/(artist\/\w+)/, /^open\.spotify\.com\/(album\/\w+)/, /^open\.spotify\.com\/(track\/\w+)/],
                        html: t => {
                            const e = t[1];
                            return '<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;">' + `<iframe src="https://open.spotify.com/embed/${e}" ` + 'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' + 'frameborder="0" allowtransparency="true" allow="encrypted-media">' + "</iframe>" + "</div>"
                        }
                    }, {
                        name: "youtube",
                        url: [/^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)/, /^(?:m\.)?youtube\.com\/v\/([\w-]+)/, /^youtube\.com\/embed\/([\w-]+)/, /^youtu\.be\/([\w-]+)/],
                        html: t => {
                            const e = t[1];
                            return '<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;">' + `<iframe src="https://www.youtube.com/embed/${e}" ` + 'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' + 'frameborder="0" allow="autoplay; encrypted-media" allowfullscreen>' + "</iframe>" + "</div>"
                        }
                    }, {
                        name: "vimeo",
                        url: [/^vimeo\.com\/(\d+)/, /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/channels\/[^/]+\/(\d+)/, /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/, /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/, /^player\.vimeo\.com\/video\/(\d+)/],
                        html: t => {
                            const e = t[1];
                            return '<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;">' + `<iframe src="https://player.vimeo.com/video/${e}" ` + 'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' + 'frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen>' + "</iframe>" + "</div>"
                        }
                    }, {
                        name: "instagram",
                        url: /^instagram\.com\/p\/(\w+)/
                    }, {
                        name: "twitter",
                        url: /^twitter\.com/
                    }, {
                        name: "googleMaps",
                        url: /^google\.com\/maps/
                    }, {
                        name: "flickr",
                        url: /^flickr\.com/
                    }, {
                        name: "facebook",
                        url: /^facebook\.com/
                    }]
                });
                this.registry = new QS(t.locale, t.config.get("mediaEmbed"))
            }
            init() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.t;
                const o = t.conversion;
                const i = t.config.get("mediaEmbed.previewsInData");
                const r = this.registry;
                t.commands.add("mediaEmbed", new HS(t));
                e.register("media", {
                    isObject: true,
                    isBlock: true,
                    allowWhere: "$block",
                    allowAttributes: ["url"]
                });
                o.for("dataDowncast").elementToElement({
                    model: "media",
                    view: (t, {
                        writer: e
                    }) => {
                        const n = t.getAttribute("url");
                        return GS(e, r, n, {
                            renderMediaPreview: n && i
                        })
                    }
                });
                o.for("dataDowncast").add(FS(r, {
                    renderMediaPreview: i
                }));
                o.for("editingDowncast").elementToElement({
                    model: "media",
                    view: (t, {
                        writer: e
                    }) => {
                        const o = t.getAttribute("url");
                        const i = GS(e, r, o, {
                            renderForEditingView: true
                        });
                        return RS(i, e, n("media widget"))
                    }
                });
                o.for("editingDowncast").add(FS(r, {
                    renderForEditingView: true
                }));
                o.for("upcast").elementToElement({
                    view: {
                        name: "oembed",
                        attributes: {
                            url: true
                        }
                    },
                    model: (t, {
                        writer: e
                    }) => {
                        const n = t.getAttribute("url");
                        if (r.hasMedia(n)) {
                            return e.createElement("media", {
                                url: n
                            })
                        }
                    }
                }).elementToElement({
                    view: {
                        name: "div",
                        attributes: {
                            "data-oembed-url": true
                        }
                    },
                    model: (t, {
                        writer: e
                    }) => {
                        const n = t.getAttribute("data-oembed-url");
                        if (r.hasMedia(n)) {
                            return e.createElement("media", {
                                url: n
                            })
                        }
                    }
                })
            }
        }
        const nT = /^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w.-]+)+[\w\-._~:/?#[\]@!$&'()*+,;=%]+$/;
        class oT extends nA {
            static get requires() {
                return [_A, TC]
            }
            static get pluginName() {
                return "AutoMediaEmbed"
            }
            constructor(t) {
                super(t);
                this._timeoutId = null;
                this._positionToInsert = null
            }
            init() {
                const t = this.editor;
                const e = t.model.document;
                this.listenTo(t.plugins.get(_A), "inputTransformation", (() => {
                    const t = e.selection.getFirstRange();
                    const n = eg.fromPosition(t.start);
                    n.stickiness = "toPrevious";
                    const o = eg.fromPosition(t.end);
                    o.stickiness = "toNext";
                    e.once("change:data", (() => {
                        this._embedMediaBetweenPositions(n, o);
                        n.detach();
                        o.detach()
                    }), {
                        priority: "high"
                    })
                }));
                t.commands.get("undo").on("execute", (() => {
                    if (this._timeoutId) {
                        Fd.window.clearTimeout(this._timeoutId);
                        this._positionToInsert.detach();
                        this._timeoutId = null;
                        this._positionToInsert = null
                    }
                }), {
                    priority: "high"
                })
            }
            _embedMediaBetweenPositions(t, e) {
                const n = this.editor;
                const o = n.plugins.get(eT).registry;
                const i = new kf(t, e);
                const r = i.getWalker({
                    ignoreElementEnd: true
                });
                let s = "";
                for (const t of r) {
                    if (t.item.is("$textProxy")) {
                        s += t.item.data
                    }
                }
                s = s.trim();
                if (!s.match(nT)) {
                    i.detach();
                    return
                }
                if (!o.hasMedia(s)) {
                    i.detach();
                    return
                }
                const a = n.commands.get("mediaEmbed");
                if (!a.isEnabled) {
                    i.detach();
                    return
                }
                this._positionToInsert = eg.fromPosition(t);
                this._timeoutId = Fd.window.setTimeout((() => {
                    n.model.change((t => {
                        this._timeoutId = null;
                        t.remove(i);
                        i.detach();
                        let e;
                        if (this._positionToInsert.root.rootName !== "$graveyard") {
                            e = this._positionToInsert
                        }
                        YS(n.model, s, e);
                        this._positionToInsert.detach();
                        this._positionToInsert = null
                    }))
                }), 100)
            }
        }
        var iT = n(48);
        var rT = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        rT.insert = "head";
        rT.singleton = true;
        var sT = rk()(iT["a"], rT);
        var aT = iT["a"].locals || {};
        class cT extends tb {
            constructor(t, e) {
                super(e);
                const n = e.t;
                this.focusTracker = new tk;
                this.keystrokes = new Vg;
                this.set("mediaURLInputValue", "");
                this.urlInputView = this._createUrlInput();
                this.saveButtonView = this._createButton(n("Save"), Py, "ck-button-save");
                this.saveButtonView.type = "submit";
                this.saveButtonView.bind("isEnabled").to(this, "mediaURLInputValue", (t => !!t));
                this.cancelButtonView = this._createButton(n("Cancel"), By, "ck-button-cancel", "cancel");
                this._focusables = new Ck;
                this._focusCycler = new Db({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {
                        focusPrevious: "shift + tab",
                        focusNext: "tab"
                    }
                });
                this._validators = t;
                this.setTemplate({
                    tag: "form",
                    attributes: {
                        class: ["ck", "ck-media-form", "ck-responsive-form"],
                        tabindex: "-1"
                    },
                    children: [this.urlInputView, this.saveButtonView, this.cancelButtonView]
                });
                Iy(this)
            }
            render() {
                super.render();
                Ny({
                    view: this
                });
                const t = [this.urlInputView, this.saveButtonView, this.cancelButtonView];
                t.forEach((t => {
                    this._focusables.add(t);
                    this.focusTracker.add(t.element)
                }));
                this.keystrokes.listenTo(this.element);
                const e = t => t.stopPropagation();
                this.keystrokes.set("arrowright", e);
                this.keystrokes.set("arrowleft", e);
                this.keystrokes.set("arrowup", e);
                this.keystrokes.set("arrowdown", e);
                this.listenTo(this.urlInputView.element, "selectstart", ((t, e) => {
                    e.stopPropagation()
                }), {
                    priority: "high"
                })
            }
            focus() {
                this._focusCycler.focusFirst()
            }
            get url() {
                return this.urlInputView.fieldView.element.value.trim()
            }
            set url(t) {
                this.urlInputView.fieldView.element.value = t.trim()
            }
            isValid() {
                this.resetFormStatus();
                for (const t of this._validators) {
                    const e = t(this);
                    if (e) {
                        this.urlInputView.errorText = e;
                        return false
                    }
                }
                return true
            }
            resetFormStatus() {
                this.urlInputView.errorText = null;
                this.urlInputView.infoText = this._urlInputViewInfoDefault
            }
            _createUrlInput() {
                const t = this.locale.t;
                const e = new _y(this.locale, Sy);
                const n = e.fieldView;
                this._urlInputViewInfoDefault = t("Paste the media URL in the input.");
                this._urlInputViewInfoTip = t("Tip: Paste the URL into the content to embed faster.");
                e.label = t("Media URL");
                e.infoText = this._urlInputViewInfoDefault;
                n.on("input", (() => {
                    e.infoText = n.element.value ? this._urlInputViewInfoTip : this._urlInputViewInfoDefault;
                    this.mediaURLInputValue = n.element.value.trim()
                }));
                return e
            }
            _createButton(t, e, n, o) {
                const i = new cw(this.locale);
                i.set({
                    label: t,
                    icon: e,
                    tooltip: true
                });
                i.extendTemplate({
                    attributes: {
                        class: n
                    }
                });
                if (o) {
                    i.delegate("execute").to(this, o)
                }
                return i
            }
        }
        var lT = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M18.68 3.03c.6 0 .59-.03.59.55v12.84c0 .59.01.56-.59.56H1.29c-.6 0-.59.03-.59-.56V3.58c0-.58-.01-.55.6-.55h17.38zM15.77 15V5H4.2v10h11.57zM2 4v1h1V4H2zm0 2v1h1V6H2zm0 2v1h1V8H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zM17 4v1h1V4h-1zm0 2v1h1V6h-1zm0 2v1h1V8h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zM7.5 7.177a.4.4 0 0 1 .593-.351l5.133 2.824a.4.4 0 0 1 0 .7l-5.133 2.824a.4.4 0 0 1-.593-.35V7.176v.001z"/></svg>';
        class dT extends nA {
            static get requires() {
                return [eT]
            }
            static get pluginName() {
                return "MediaEmbedUI"
            }
            init() {
                const t = this.editor;
                const e = t.commands.get("mediaEmbed");
                const n = t.plugins.get(eT).registry;
                t.ui.componentFactory.add("mediaEmbed", (o => {
                    const i = Nw(o);
                    const r = new cT(uT(t.t, n), t.locale);
                    this._setUpDropdown(i, r, e, t);
                    this._setUpForm(i, r, e);
                    return i
                }))
            }
            _setUpDropdown(t, e, n) {
                const o = this.editor;
                const i = o.t;
                const r = t.buttonView;
                t.bind("isEnabled").to(n);
                t.panelView.children.add(e);
                r.set({
                    label: i("Insert media"),
                    icon: lT,
                    tooltip: true
                });
                r.on("open", (() => {
                    e.disableCssTransitions();
                    e.url = n.value || "";
                    e.urlInputView.fieldView.select();
                    e.focus();
                    e.enableCssTransitions()
                }), {
                    priority: "low"
                });
                t.on("submit", (() => {
                    if (e.isValid()) {
                        o.execute("mediaEmbed", e.url);
                        s()
                    }
                }));
                t.on("change:isOpen", (() => e.resetFormStatus()));
                t.on("cancel", (() => s()));

                function s() {
                    o.editing.view.focus();
                    t.isOpen = false
                }
            }
            _setUpForm(t, e, n) {
                e.delegate("submit", "cancel").to(t);
                e.urlInputView.bind("value").to(n, "value");
                e.urlInputView.bind("isReadOnly").to(n, "isEnabled", (t => !t))
            }
        }

        function uT(t, e) {
            return [e => {
                if (!e.url.length) {
                    return t("The URL must not be empty.")
                }
            }, n => {
                if (!e.hasMedia(n.url)) {
                    return t("This media URL is not supported.")
                }
            }]
        }
        var hT = n(49);
        var fT = {
            injectType: "singletonStyleTag",
            attributes: {
                "data-cke": true
            }
        };
        fT.insert = "head";
        fT.singleton = true;
        var pT = rk()(hT["a"], fT);
        var mT = hT["a"].locals || {};
        class gT extends nA {
            static get requires() {
                return [eT, dT, oT, fy]
            }
            static get pluginName() {
                return "MediaEmbed"
            }
        }
        const kT = "strikethrough";
        class bT extends nA {
            static get pluginName() {
                return "StrikethroughEditing"
            }
            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {
                    allowAttributes: kT
                });
                t.model.schema.setAttributeProperties(kT, {
                    isFormatting: true,
                    copyOnEnter: true
                });
                t.conversion.attributeToElement({
                    model: kT,
                    view: "s",
                    upcastAlso: ["del", "strike", {
                        styles: {
                            "text-decoration": "line-through"
                        }
                    }]
                });
                t.commands.add(kT, new sA(t, kT));
                t.keystrokes.set("CTRL+SHIFT+X", "strikethrough")
            }
        }
        var wT = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9L6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>';
        const AT = "strikethrough";
        class CT extends nA {
            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add(AT, (n => {
                    const o = t.commands.get(AT);
                    const i = new cw(n);
                    i.set({
                        label: e("Strikethrough"),
                        icon: wT,
                        keystroke: "CTRL+SHIFT+X",
                        tooltip: true,
                        isToggleable: true
                    });
                    i.bind("isOn", "isEnabled").to(o, "value", "isEnabled");
                    this.listenTo(i, "execute", (() => {
                        t.execute(AT);
                        t.editing.view.focus()
                    }));
                    return i
                }))
            }
        }
        class _T extends nA {
            static get requires() {
                return [bT, CT]
            }
            static get pluginName() {
                return "Strikethrough"
            }
        }
        const vT = "underline";
        class yT extends nA {
            static get pluginName() {
                return "UnderlineEditing"
            }
            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {
                    allowAttributes: vT
                });
                t.model.schema.setAttributeProperties(vT, {
                    isFormatting: true,
                    copyOnEnter: true
                });
                t.conversion.attributeToElement({
                    model: vT,
                    view: "u",
                    upcastAlso: {
                        styles: {
                            "text-decoration": "underline"
                        }
                    }
                });
                t.commands.add(vT, new sA(t, vT));
                t.keystrokes.set("CTRL+U", "underline")
            }
        }
        var xT = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>';
        const DT = "underline";
        class MT extends nA {
            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add(DT, (n => {
                    const o = t.commands.get(DT);
                    const i = new cw(n);
                    i.set({
                        label: e("Underline"),
                        icon: xT,
                        keystroke: "CTRL+U",
                        tooltip: true,
                        isToggleable: true
                    });
                    i.bind("isOn", "isEnabled").to(o, "value", "isEnabled");
                    this.listenTo(i, "execute", (() => {
                        t.execute(DT);
                        t.editing.view.focus()
                    }));
                    return i
                }))
            }
        }
        class ET extends nA {
            static get requires() {
                return [yT, MT]
            }
            static get pluginName() {
                return "Underline"
            }
        }
        class ST extends tA {}
        ST.builtinPlugins = [hA, IC, j_, G_, fx, sD, hD, fE, nS, jS, gT, CE, _T, ET];
        var TT = e["default"] = ST
    }])["default"]
}));
//# sourceMappingURL=ckeditor.js.map